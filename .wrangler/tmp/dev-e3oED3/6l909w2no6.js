var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// .wrangler/tmp/bundle-1HjA2m/checked-fetch.js
function checkURL(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-1HjA2m/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init2] = argArray;
        checkURL(request, init2);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/astro_BO0wYrHs.mjs
function getDefaultExportFromCjs(x4) {
  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, "default") ? x4["default"] : x4;
}
function normalizeLF(code) {
  return code.replace(/\r\n|\r(?!\n)|\n/g, "\n");
}
function codeFrame(src, loc) {
  if (!loc || loc.line === void 0 || loc.column === void 0) {
    return "";
  }
  const lines = normalizeLF(src).split("\n").map((ln2) => ln2.replace(/\t/g, "  "));
  const visibleLines = [];
  for (let n5 = -2; n5 <= 2; n5++) {
    if (lines[loc.line + n5])
      visibleLines.push(loc.line + n5);
  }
  let gutterWidth = 0;
  for (const lineNo of visibleLines) {
    let w5 = `> ${lineNo}`;
    if (w5.length > gutterWidth)
      gutterWidth = w5.length;
  }
  let output = "";
  for (const lineNo of visibleLines) {
    const isFocusedLine = lineNo === loc.line - 1;
    output += isFocusedLine ? "> " : "  ";
    output += `${lineNo + 1} | ${lines[lineNo]}
`;
    if (isFocusedLine)
      output += `${Array.from({ length: gutterWidth }).join(" ")}  | ${Array.from({
        length: loc.column
      }).join(" ")}^
`;
  }
  return output;
}
function init(x4, y3) {
  let rgx = new RegExp(`\\x1b\\[${y3}m`, "g");
  let open = `\x1B[${x4}m`, close = `\x1B[${y3}m`;
  return function(txt) {
    if (!$.enabled || txt == null)
      return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
async function renderEndpoint(mod, context, ssr, logger2) {
  const { request, url } = context;
  const method = request.method.toUpperCase();
  const handler = mod[method] ?? mod["ALL"];
  if (!ssr && ssr === false && method !== "GET") {
    logger2.warn(
      "router",
      `${url.pathname} ${bold(
        method
      )} requests are not available for a static site. Update your config to \`output: 'server'\` or \`output: 'hybrid'\` to enable.`
    );
  }
  if (handler === void 0) {
    logger2.warn(
      "router",
      `No API Route handler exists for the method "${method}" for the route "${url.pathname}".
Found handlers: ${Object.keys(mod).map((exp) => JSON.stringify(exp)).join(", ")}
` + ("all" in mod ? `One of the exported handlers is "all" (lowercase), did you mean to export 'ALL'?
` : "")
    );
    return new Response(null, { status: 404 });
  }
  if (typeof handler !== "function") {
    logger2.error(
      "router",
      `The route "${url.pathname}" exports a value for the method "${method}", but it is of the type ${typeof handler} instead of a function.`
    );
    return new Response(null, { status: 500 });
  }
  const response = await handler.call(mod, context);
  if (!response || response instanceof Response === false) {
    throw new AstroError(EndpointDidNotReturnAResponse);
  }
  if (REROUTABLE_STATUS_CODES.includes(response.status)) {
    response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
  }
  return response;
}
function validateArgs(args) {
  if (args.length !== 3)
    return false;
  if (!args[0] || typeof args[0] !== "object")
    return false;
  return true;
}
function baseCreateComponent(cb3, moduleId, propagation) {
  const name = moduleId?.split("/").pop()?.replace(".astro", "") ?? "";
  const fn2 = (...args) => {
    if (!validateArgs(args)) {
      throw new AstroError({
        ...InvalidComponentArgs,
        message: InvalidComponentArgs.message(name)
      });
    }
    return cb3(...args);
  };
  Object.defineProperty(fn2, "name", { value: name, writable: false });
  fn2.isAstroComponentFactory = true;
  fn2.moduleId = moduleId;
  fn2.propagation = propagation;
  return fn2;
}
function createComponentWithOptions(opts2) {
  const cb3 = baseCreateComponent(opts2.factory, opts2.moduleId, opts2.propagation);
  return cb3;
}
function createComponent(arg1, moduleId, propagation) {
  if (typeof arg1 === "function") {
    return baseCreateComponent(arg1, moduleId, propagation);
  } else {
    return createComponentWithOptions(arg1);
  }
}
function createAstroGlobFn() {
  const globHandler = (importMetaGlobResult) => {
    if (typeof importMetaGlobResult === "string") {
      throw new AstroError({
        ...AstroGlobUsedOutside,
        message: AstroGlobUsedOutside.message(JSON.stringify(importMetaGlobResult))
      });
    }
    let allEntries = [...Object.values(importMetaGlobResult)];
    if (allEntries.length === 0) {
      throw new AstroError({
        ...AstroGlobNoMatch,
        message: AstroGlobNoMatch.message(JSON.stringify(importMetaGlobResult))
      });
    }
    return Promise.all(allEntries.map((fn2) => fn2()));
  };
  return globHandler;
}
function createAstro(site) {
  return {
    // TODO: this is no longer neccessary for `Astro.site`
    // but it somehow allows working around caching issues in content collections for some tests
    site: site ? new URL(site) : void 0,
    generator: `Astro v${ASTRO_VERSION}`,
    glob: createAstroGlobFn()
  };
}
function isPromise(value) {
  return !!value && typeof value === "object" && typeof value.then === "function";
}
function isHTMLString(value) {
  return Object.prototype.toString.call(value) === "[object HTMLString]";
}
function isVNode(vnode) {
  return vnode && typeof vnode === "object" && vnode[AstroJSX];
}
function createRenderInstruction(instruction) {
  return Object.defineProperty(instruction, RenderInstructionSymbol, {
    value: true
  });
}
function isRenderInstruction(chunk) {
  return chunk && typeof chunk === "object" && chunk[RenderInstructionSymbol];
}
function r(e2) {
  var t5, f3, n5 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n5 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o3 = e2.length;
      for (t5 = 0; t5 < o3; t5++)
        e2[t5] && (f3 = r(e2[t5])) && (n5 && (n5 += " "), n5 += f3);
    } else
      for (f3 in e2)
        e2[f3] && (n5 && (n5 += " "), n5 += f3);
  return n5;
}
function clsx() {
  for (var e2, t5, f3 = 0, n5 = "", o3 = arguments.length; f3 < o3; f3++)
    (e2 = arguments[f3]) && (t5 = r(e2)) && (n5 && (n5 += " "), n5 += t5);
  return n5;
}
function serializeArray(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  if (parents.has(value)) {
    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!

Cyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);
  }
  parents.add(value);
  const serialized = value.map((v4) => {
    return convertToSerializedForm(v4, metadata, parents);
  });
  parents.delete(value);
  return serialized;
}
function serializeObject(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  if (parents.has(value)) {
    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!

Cyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);
  }
  parents.add(value);
  const serialized = Object.fromEntries(
    Object.entries(value).map(([k4, v4]) => {
      return [k4, convertToSerializedForm(v4, metadata, parents)];
    })
  );
  parents.delete(value);
  return serialized;
}
function convertToSerializedForm(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  const tag = Object.prototype.toString.call(value);
  switch (tag) {
    case "[object Date]": {
      return [PROP_TYPE.Date, value.toISOString()];
    }
    case "[object RegExp]": {
      return [PROP_TYPE.RegExp, value.source];
    }
    case "[object Map]": {
      return [PROP_TYPE.Map, serializeArray(Array.from(value), metadata, parents)];
    }
    case "[object Set]": {
      return [PROP_TYPE.Set, serializeArray(Array.from(value), metadata, parents)];
    }
    case "[object BigInt]": {
      return [PROP_TYPE.BigInt, value.toString()];
    }
    case "[object URL]": {
      return [PROP_TYPE.URL, value.toString()];
    }
    case "[object Array]": {
      return [PROP_TYPE.JSON, serializeArray(value, metadata, parents)];
    }
    case "[object Uint8Array]": {
      return [PROP_TYPE.Uint8Array, Array.from(value)];
    }
    case "[object Uint16Array]": {
      return [PROP_TYPE.Uint16Array, Array.from(value)];
    }
    case "[object Uint32Array]": {
      return [PROP_TYPE.Uint32Array, Array.from(value)];
    }
    default: {
      if (value !== null && typeof value === "object") {
        return [PROP_TYPE.Value, serializeObject(value, metadata, parents)];
      } else if (value === void 0) {
        return [PROP_TYPE.Value];
      } else {
        return [PROP_TYPE.Value, value];
      }
    }
  }
}
function serializeProps(props, metadata) {
  const serialized = JSON.stringify(serializeObject(props, metadata));
  return serialized;
}
function extractDirectives(inputProps, clientDirectives) {
  let extracted = {
    isPage: false,
    hydration: null,
    props: {},
    propsWithoutTransitionAttributes: {}
  };
  for (const [key, value] of Object.entries(inputProps)) {
    if (key.startsWith("server:")) {
      if (key === "server:root") {
        extracted.isPage = true;
      }
    }
    if (key.startsWith("client:")) {
      if (!extracted.hydration) {
        extracted.hydration = {
          directive: "",
          value: "",
          componentUrl: "",
          componentExport: { value: "" }
        };
      }
      switch (key) {
        case "client:component-path": {
          extracted.hydration.componentUrl = value;
          break;
        }
        case "client:component-export": {
          extracted.hydration.componentExport.value = value;
          break;
        }
        case "client:component-hydration": {
          break;
        }
        case "client:display-name": {
          break;
        }
        default: {
          extracted.hydration.directive = key.split(":")[1];
          extracted.hydration.value = value;
          if (!clientDirectives.has(extracted.hydration.directive)) {
            const hydrationMethods = Array.from(clientDirectives.keys()).map((d2) => `client:${d2}`).join(", ");
            throw new Error(
              `Error: invalid hydration directive "${key}". Supported hydration methods: ${hydrationMethods}`
            );
          }
          if (extracted.hydration.directive === "media" && typeof extracted.hydration.value !== "string") {
            throw new AstroError(MissingMediaQueryDirective);
          }
          break;
        }
      }
    } else {
      extracted.props[key] = value;
      if (!transitionDirectivesToCopyOnIsland.includes(key)) {
        extracted.propsWithoutTransitionAttributes[key] = value;
      }
    }
  }
  for (const sym of Object.getOwnPropertySymbols(inputProps)) {
    extracted.props[sym] = inputProps[sym];
    extracted.propsWithoutTransitionAttributes[sym] = inputProps[sym];
  }
  return extracted;
}
async function generateHydrateScript(scriptOptions, metadata) {
  const { renderer, result, astroId, props, attrs } = scriptOptions;
  const { hydrate, componentUrl, componentExport } = metadata;
  if (!componentExport.value) {
    throw new AstroError({
      ...NoMatchingImport,
      message: NoMatchingImport.message(metadata.displayName)
    });
  }
  const island = {
    children: "",
    props: {
      // This is for HMR, probably can avoid it in prod
      uid: astroId
    }
  };
  if (attrs) {
    for (const [key, value] of Object.entries(attrs)) {
      island.props[key] = escapeHTML(value);
    }
  }
  island.props["component-url"] = await result.resolve(decodeURI(componentUrl));
  if (renderer.clientEntrypoint) {
    island.props["component-export"] = componentExport.value;
    island.props["renderer-url"] = await result.resolve(decodeURI(renderer.clientEntrypoint));
    island.props["props"] = escapeHTML(serializeProps(props, metadata));
  }
  island.props["ssr"] = "";
  island.props["client"] = hydrate;
  let beforeHydrationUrl = await result.resolve("astro:scripts/before-hydration.js");
  if (beforeHydrationUrl.length) {
    island.props["before-hydration-url"] = beforeHydrationUrl;
  }
  island.props["opts"] = escapeHTML(
    JSON.stringify({
      name: metadata.displayName,
      value: metadata.hydrateArgs || ""
    })
  );
  transitionDirectivesToCopyOnIsland.forEach((name) => {
    if (typeof props[name] !== "undefined") {
      island.props[name] = props[name];
    }
  });
  return island;
}
function bitwise(str) {
  let hash = 0;
  if (str.length === 0)
    return hash;
  for (let i2 = 0; i2 < str.length; i2++) {
    const ch2 = str.charCodeAt(i2);
    hash = (hash << 5) - hash + ch2;
    hash = hash & hash;
  }
  return hash;
}
function shorthash(text3) {
  let num;
  let result = "";
  let integer2 = bitwise(text3);
  const sign = integer2 < 0 ? "Z" : "";
  integer2 = Math.abs(integer2);
  while (integer2 >= binary) {
    num = integer2 % binary;
    integer2 = Math.floor(integer2 / binary);
    result = dictionary[num] + result;
  }
  if (integer2 > 0) {
    result = dictionary[integer2] + result;
  }
  return sign + result;
}
function isAstroComponentFactory(obj) {
  return obj == null ? false : obj.isAstroComponentFactory === true;
}
function isAPropagatingComponent(result, factory) {
  let hint = factory.propagation || "none";
  if (factory.moduleId && result.componentMetadata.has(factory.moduleId) && hint === "none") {
    hint = result.componentMetadata.get(factory.moduleId).propagation;
  }
  return hint === "in-tree" || hint === "self";
}
function isHeadAndContent(obj) {
  return typeof obj === "object" && !!obj[headAndContentSym];
}
function determineIfNeedsHydrationScript(result) {
  if (result._metadata.hasHydrationScript) {
    return false;
  }
  return result._metadata.hasHydrationScript = true;
}
function determinesIfNeedsDirectiveScript(result, directive) {
  if (result._metadata.hasDirectives.has(directive)) {
    return false;
  }
  result._metadata.hasDirectives.add(directive);
  return true;
}
function getDirectiveScriptText(result, directive) {
  const clientDirectives = result.clientDirectives;
  const clientDirective = clientDirectives.get(directive);
  if (!clientDirective) {
    throw new Error(`Unknown directive: ${directive}`);
  }
  return clientDirective;
}
function getPrescripts(result, type, directive) {
  switch (type) {
    case "both":
      return `${ISLAND_STYLES}<script>${getDirectiveScriptText(result, directive)};${astro_island_prebuilt_default}<\/script>`;
    case "directive":
      return `<script>${getDirectiveScriptText(result, directive)}<\/script>`;
  }
  return "";
}
function defineScriptVars(vars) {
  let output = "";
  for (const [key, value] of Object.entries(vars)) {
    output += `const ${toIdent(key)} = ${JSON.stringify(value)?.replace(
      /<\/script>/g,
      "\\x3C/script>"
    )};
`;
  }
  return markHTMLString(output);
}
function formatList(values) {
  if (values.length === 1) {
    return values[0];
  }
  return `${values.slice(0, -1).join(", ")} or ${values[values.length - 1]}`;
}
function addAttribute(value, key, shouldEscape = true) {
  if (value == null) {
    return "";
  }
  if (value === false) {
    if (htmlEnumAttributes.test(key) || svgEnumAttributes.test(key)) {
      return markHTMLString(` ${key}="false"`);
    }
    return "";
  }
  if (STATIC_DIRECTIVES.has(key)) {
    console.warn(`[astro] The "${key}" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.

Make sure to use the static attribute syntax (\`${key}={value}\`) instead of the dynamic spread syntax (\`{...{ "${key}": value }}\`).`);
    return "";
  }
  if (key === "class:list") {
    const listValue = toAttributeString(clsx(value), shouldEscape);
    if (listValue === "") {
      return "";
    }
    return markHTMLString(` ${key.slice(0, -5)}="${listValue}"`);
  }
  if (key === "style" && !(value instanceof HTMLString)) {
    if (Array.isArray(value) && value.length === 2) {
      return markHTMLString(
        ` ${key}="${toAttributeString(`${toStyleString(value[0])};${value[1]}`, shouldEscape)}"`
      );
    }
    if (typeof value === "object") {
      return markHTMLString(` ${key}="${toAttributeString(toStyleString(value), shouldEscape)}"`);
    }
  }
  if (key === "className") {
    return markHTMLString(` class="${toAttributeString(value, shouldEscape)}"`);
  }
  if (typeof value === "string" && value.includes("&") && isHttpUrl(value)) {
    return markHTMLString(` ${key}="${toAttributeString(value, false)}"`);
  }
  if (value === true && (key.startsWith("data-") || htmlBooleanAttributes.test(key))) {
    return markHTMLString(` ${key}`);
  } else {
    return markHTMLString(` ${key}="${toAttributeString(value, shouldEscape)}"`);
  }
}
function internalSpreadAttributes(values, shouldEscape = true) {
  let output = "";
  for (const [key, value] of Object.entries(values)) {
    output += addAttribute(value, key, shouldEscape);
  }
  return markHTMLString(output);
}
function renderElement$1(name, { props: _props, children = "" }, shouldEscape = true) {
  const { lang: _3, "data-astro-id": astroId, "define:vars": defineVars, ...props } = _props;
  if (defineVars) {
    if (name === "style") {
      delete props["is:global"];
      delete props["is:scoped"];
    }
    if (name === "script") {
      delete props.hoist;
      children = defineScriptVars(defineVars) + "\n" + children;
    }
  }
  if ((children == null || children == "") && voidElementNames.test(name)) {
    return `<${name}${internalSpreadAttributes(props, shouldEscape)}>`;
  }
  return `<${name}${internalSpreadAttributes(props, shouldEscape)}>${children}</${name}>`;
}
function renderToBufferDestination(bufferRenderFunction) {
  const renderer = new BufferedRenderer(bufferRenderFunction);
  return renderer;
}
function promiseWithResolvers() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return {
    promise,
    resolve,
    reject
  };
}
function isHttpUrl(url) {
  try {
    const parsedUrl = new URL(url);
    return VALID_PROTOCOLS.includes(parsedUrl.protocol);
  } catch {
    return false;
  }
}
function renderAllHeadContent(result) {
  result._metadata.hasRenderedHead = true;
  const styles = Array.from(result.styles).filter(uniqueElements).map(
    (style) => style.props.rel === "stylesheet" ? renderElement$1("link", style) : renderElement$1("style", style)
  );
  result.styles.clear();
  const scripts = Array.from(result.scripts).filter(uniqueElements).map((script) => {
    return renderElement$1("script", script, false);
  });
  const links = Array.from(result.links).filter(uniqueElements).map((link) => renderElement$1("link", link, false));
  let content = styles.join("\n") + links.join("\n") + scripts.join("\n");
  if (result._metadata.extraHead.length > 0) {
    for (const part of result._metadata.extraHead) {
      content += part;
    }
  }
  return markHTMLString(content);
}
function renderHead() {
  return createRenderInstruction({ type: "head" });
}
function maybeRenderHead() {
  return createRenderInstruction({ type: "maybe-head" });
}
function isSlotString(str) {
  return !!str[slotString];
}
function renderSlot(result, slotted, fallback) {
  if (!slotted && fallback) {
    return renderSlot(result, fallback);
  }
  return {
    async render(destination) {
      await renderChild(destination, typeof slotted === "function" ? slotted(result) : slotted);
    }
  };
}
async function renderSlotToString(result, slotted, fallback) {
  let content = "";
  let instructions = null;
  const temporaryDestination = {
    write(chunk) {
      if (chunk instanceof SlotString) {
        content += chunk;
        if (chunk.instructions) {
          instructions ??= [];
          instructions.push(...chunk.instructions);
        }
      } else if (chunk instanceof Response)
        return;
      else if (typeof chunk === "object" && "type" in chunk && typeof chunk.type === "string") {
        if (instructions === null) {
          instructions = [];
        }
        instructions.push(chunk);
      } else {
        content += chunkToString(result, chunk);
      }
    }
  };
  const renderInstance = renderSlot(result, slotted, fallback);
  await renderInstance.render(temporaryDestination);
  return markHTMLString(new SlotString(content, instructions));
}
async function renderSlots(result, slots = {}) {
  let slotInstructions = null;
  let children = {};
  if (slots) {
    await Promise.all(
      Object.entries(slots).map(
        ([key, value]) => renderSlotToString(result, value).then((output) => {
          if (output.instructions) {
            if (slotInstructions === null) {
              slotInstructions = [];
            }
            slotInstructions.push(...output.instructions);
          }
          children[key] = output;
        })
      )
    );
  }
  return { slotInstructions, children };
}
function stringifyChunk(result, chunk) {
  if (isRenderInstruction(chunk)) {
    const instruction = chunk;
    switch (instruction.type) {
      case "directive": {
        const { hydration } = instruction;
        let needsHydrationScript = hydration && determineIfNeedsHydrationScript(result);
        let needsDirectiveScript = hydration && determinesIfNeedsDirectiveScript(result, hydration.directive);
        let prescriptType = needsHydrationScript ? "both" : needsDirectiveScript ? "directive" : null;
        if (prescriptType) {
          let prescripts = getPrescripts(result, prescriptType, hydration.directive);
          return markHTMLString(prescripts);
        } else {
          return "";
        }
      }
      case "head": {
        if (result._metadata.hasRenderedHead || result.partial) {
          return "";
        }
        return renderAllHeadContent(result);
      }
      case "maybe-head": {
        if (result._metadata.hasRenderedHead || result._metadata.headInTree || result.partial) {
          return "";
        }
        return renderAllHeadContent(result);
      }
      case "renderer-hydration-script": {
        const { rendererSpecificHydrationScripts } = result._metadata;
        const { rendererName } = instruction;
        if (!rendererSpecificHydrationScripts.has(rendererName)) {
          rendererSpecificHydrationScripts.add(rendererName);
          return instruction.render();
        }
        return "";
      }
      default: {
        throw new Error(`Unknown chunk type: ${chunk.type}`);
      }
    }
  } else if (chunk instanceof Response) {
    return "";
  } else if (isSlotString(chunk)) {
    let out = "";
    const c2 = chunk;
    if (c2.instructions) {
      for (const instr of c2.instructions) {
        out += stringifyChunk(result, instr);
      }
    }
    out += chunk.toString();
    return out;
  }
  return chunk.toString();
}
function chunkToString(result, chunk) {
  if (ArrayBuffer.isView(chunk)) {
    return decoder.decode(chunk);
  } else {
    return stringifyChunk(result, chunk);
  }
}
function chunkToByteArray(result, chunk) {
  if (ArrayBuffer.isView(chunk)) {
    return chunk;
  } else {
    const stringified = stringifyChunk(result, chunk);
    return encoder.encode(stringified.toString());
  }
}
function isRenderInstance(obj) {
  return !!obj && typeof obj === "object" && "render" in obj && typeof obj.render === "function";
}
async function renderChild(destination, child) {
  if (isPromise(child)) {
    child = await child;
  }
  if (child instanceof SlotString) {
    destination.write(child);
  } else if (isHTMLString(child)) {
    destination.write(child);
  } else if (Array.isArray(child)) {
    const childRenders = child.map((c2) => {
      return renderToBufferDestination((bufferDestination) => {
        return renderChild(bufferDestination, c2);
      });
    });
    for (const childRender of childRenders) {
      if (!childRender)
        continue;
      await childRender.renderToFinalDestination(destination);
    }
  } else if (typeof child === "function") {
    await renderChild(destination, child());
  } else if (typeof child === "string") {
    destination.write(markHTMLString(escapeHTML(child)));
  } else if (!child && child !== 0)
    ;
  else if (isRenderInstance(child)) {
    await child.render(destination);
  } else if (isRenderTemplateResult(child)) {
    await child.render(destination);
  } else if (isAstroComponentInstance(child)) {
    await child.render(destination);
  } else if (ArrayBuffer.isView(child)) {
    destination.write(child);
  } else if (typeof child === "object" && (Symbol.asyncIterator in child || Symbol.iterator in child)) {
    for await (const value of child) {
      await renderChild(destination, value);
    }
  } else {
    destination.write(child);
  }
}
function validateComponentProps(props, displayName) {
  if (props != null) {
    for (const prop of Object.keys(props)) {
      if (prop.startsWith("client:")) {
        console.warn(
          `You are attempting to render <${displayName} ${prop} />, but ${displayName} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`
        );
      }
    }
  }
}
function createAstroComponentInstance(result, displayName, factory, props, slots = {}) {
  validateComponentProps(props, displayName);
  const instance = new AstroComponentInstance(result, props, slots, factory);
  if (isAPropagatingComponent(result, factory)) {
    result._metadata.propagators.add(instance);
  }
  return instance;
}
function isAstroComponentInstance(obj) {
  return typeof obj === "object" && !!obj[astroComponentInstanceSym];
}
function isRenderTemplateResult(obj) {
  return typeof obj === "object" && !!obj[renderTemplateResultSym];
}
function renderTemplate(htmlParts, ...expressions) {
  return new RenderTemplateResult(htmlParts, expressions);
}
async function renderToString(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response)
    return templateResult;
  let str = "";
  let renderedFirstPageChunk = false;
  const destination = {
    write(chunk) {
      if (isPage && !renderedFirstPageChunk) {
        renderedFirstPageChunk = true;
        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
          const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
          str += doctype;
        }
      }
      if (chunk instanceof Response)
        return;
      str += chunkToString(result, chunk);
    }
  };
  await templateResult.render(destination);
  return str;
}
async function renderToReadableStream(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response)
    return templateResult;
  let renderedFirstPageChunk = false;
  if (isPage) {
    await bufferHeadContent(result);
  }
  return new ReadableStream({
    start(controller) {
      const destination = {
        write(chunk) {
          if (isPage && !renderedFirstPageChunk) {
            renderedFirstPageChunk = true;
            if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
              const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
              controller.enqueue(encoder.encode(doctype));
            }
          }
          if (chunk instanceof Response) {
            throw new AstroError({
              ...ResponseSentError
            });
          }
          const bytes = chunkToByteArray(result, chunk);
          controller.enqueue(bytes);
        }
      };
      (async () => {
        try {
          await templateResult.render(destination);
          controller.close();
        } catch (e2) {
          if (AstroError.is(e2) && !e2.loc) {
            e2.setLocation({
              file: route?.component
            });
          }
          setTimeout(() => controller.error(e2), 0);
        }
      })();
    },
    cancel() {
      result.cancelled = true;
    }
  });
}
async function callComponentAsTemplateResultOrResponse(result, componentFactory, props, children, route) {
  const factoryResult = await componentFactory(result, props, children);
  if (factoryResult instanceof Response) {
    return factoryResult;
  } else if (!isRenderTemplateResult(factoryResult)) {
    throw new AstroError({
      ...OnlyResponseCanBeReturned,
      message: OnlyResponseCanBeReturned.message(route?.route, typeof factoryResult),
      location: {
        file: route?.component
      }
    });
  }
  return isHeadAndContent(factoryResult) ? factoryResult.content : factoryResult;
}
async function bufferHeadContent(result) {
  const iterator = result._metadata.propagators.values();
  while (true) {
    const { value, done } = iterator.next();
    if (done) {
      break;
    }
    const returnValue = await value.init(result);
    if (isHeadAndContent(returnValue)) {
      result._metadata.extraHead.push(returnValue.head);
    }
  }
}
async function renderToAsyncIterable(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response)
    return templateResult;
  let renderedFirstPageChunk = false;
  if (isPage) {
    await bufferHeadContent(result);
  }
  let error2 = null;
  let next = promiseWithResolvers();
  const buffer = [];
  const iterator = {
    async next() {
      if (result.cancelled)
        return { done: true, value: void 0 };
      await next.promise;
      if (error2) {
        throw error2;
      }
      let length = 0;
      for (let i2 = 0, len = buffer.length; i2 < len; i2++) {
        length += buffer[i2].length;
      }
      let mergedArray = new Uint8Array(length);
      let offset2 = 0;
      for (let i2 = 0, len = buffer.length; i2 < len; i2++) {
        const item = buffer[i2];
        mergedArray.set(item, offset2);
        offset2 += item.length;
      }
      buffer.length = 0;
      const returnValue = {
        // The iterator is done if there are no chunks to return.
        done: length === 0,
        value: mergedArray
      };
      return returnValue;
    },
    async return() {
      result.cancelled = true;
      return { done: true, value: void 0 };
    }
  };
  const destination = {
    write(chunk) {
      if (isPage && !renderedFirstPageChunk) {
        renderedFirstPageChunk = true;
        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
          const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
          buffer.push(encoder.encode(doctype));
        }
      }
      if (chunk instanceof Response) {
        throw new AstroError(ResponseSentError);
      }
      const bytes = chunkToByteArray(result, chunk);
      if (bytes.length > 0) {
        buffer.push(bytes);
        next.resolve();
        next = promiseWithResolvers();
      }
    }
  };
  const renderPromise = templateResult.render(destination);
  renderPromise.then(() => {
    next.resolve();
  }).catch((err) => {
    error2 = err;
    next.resolve();
  });
  return {
    [Symbol.asyncIterator]() {
      return iterator;
    }
  };
}
function componentIsHTMLElement(Component) {
  return typeof HTMLElement !== "undefined" && HTMLElement.isPrototypeOf(Component);
}
async function renderHTMLElement(result, constructor, props, slots) {
  const name = getHTMLElementName(constructor);
  let attrHTML = "";
  for (const attr in props) {
    attrHTML += ` ${attr}="${toAttributeString(await props[attr])}"`;
  }
  return markHTMLString(
    `<${name}${attrHTML}>${await renderSlotToString(result, slots?.default)}</${name}>`
  );
}
function getHTMLElementName(constructor) {
  const definedName = customElements.getName(constructor);
  if (definedName)
    return definedName;
  const assignedName = constructor.name.replace(/^HTML|Element$/g, "").replace(/[A-Z]/g, "-$&").toLowerCase().replace(/^-/, "html-");
  return assignedName;
}
function guessRenderers(componentUrl) {
  const extname2 = componentUrl?.split(".").pop();
  switch (extname2) {
    case "svelte":
      return ["@astrojs/svelte"];
    case "vue":
      return ["@astrojs/vue"];
    case "jsx":
    case "tsx":
      return ["@astrojs/react", "@astrojs/preact", "@astrojs/solid-js", "@astrojs/vue (jsx)"];
    default:
      return [
        "@astrojs/react",
        "@astrojs/preact",
        "@astrojs/solid-js",
        "@astrojs/vue",
        "@astrojs/svelte",
        "@astrojs/lit"
      ];
  }
}
function isFragmentComponent(Component) {
  return Component === Fragment;
}
function isHTMLComponent(Component) {
  return Component && Component["astro:html"] === true;
}
function removeStaticAstroSlot(html, supportsAstroStaticSlot = true) {
  const exp = supportsAstroStaticSlot ? ASTRO_STATIC_SLOT_EXP : ASTRO_SLOT_EXP;
  return html.replace(exp, "");
}
async function renderFrameworkComponent(result, displayName, Component, _props, slots = {}) {
  if (!Component && "client:only" in _props === false) {
    throw new Error(
      `Unable to render ${displayName} because it is ${Component}!
Did you forget to import the component or is it possible there is a typo?`
    );
  }
  const { renderers: renderers2, clientDirectives } = result;
  const metadata = {
    astroStaticSlot: true,
    displayName
  };
  const { hydration, isPage, props, propsWithoutTransitionAttributes } = extractDirectives(
    _props,
    clientDirectives
  );
  let html = "";
  let attrs = void 0;
  if (hydration) {
    metadata.hydrate = hydration.directive;
    metadata.hydrateArgs = hydration.value;
    metadata.componentExport = hydration.componentExport;
    metadata.componentUrl = hydration.componentUrl;
  }
  const probableRendererNames = guessRenderers(metadata.componentUrl);
  const validRenderers = renderers2.filter((r5) => r5.name !== "astro:jsx");
  const { children, slotInstructions } = await renderSlots(result, slots);
  let renderer;
  if (metadata.hydrate !== "only") {
    let isTagged = false;
    try {
      isTagged = Component && Component[Renderer];
    } catch {
    }
    if (isTagged) {
      const rendererName = Component[Renderer];
      renderer = renderers2.find(({ name }) => name === rendererName);
    }
    if (!renderer) {
      let error2;
      for (const r5 of renderers2) {
        try {
          if (await r5.ssr.check.call({ result }, Component, props, children)) {
            renderer = r5;
            break;
          }
        } catch (e2) {
          error2 ??= e2;
        }
      }
      if (!renderer && error2) {
        throw error2;
      }
    }
    if (!renderer && typeof HTMLElement === "function" && componentIsHTMLElement(Component)) {
      const output = await renderHTMLElement(
        result,
        Component,
        _props,
        slots
      );
      return {
        render(destination) {
          destination.write(output);
        }
      };
    }
  } else {
    if (metadata.hydrateArgs) {
      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;
      if (clientOnlyValues.has(rendererName)) {
        renderer = renderers2.find(
          ({ name }) => name === `@astrojs/${rendererName}` || name === rendererName
        );
      }
    }
    if (!renderer && validRenderers.length === 1) {
      renderer = validRenderers[0];
    }
    if (!renderer) {
      const extname2 = metadata.componentUrl?.split(".").pop();
      renderer = renderers2.filter(
        ({ name }) => name === `@astrojs/${extname2}` || name === extname2
      )[0];
    }
  }
  if (!renderer) {
    if (metadata.hydrate === "only") {
      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;
      if (clientOnlyValues.has(rendererName)) {
        const plural = validRenderers.length > 1;
        throw new AstroError({
          ...NoMatchingRenderer,
          message: NoMatchingRenderer.message(
            metadata.displayName,
            metadata?.componentUrl?.split(".").pop(),
            plural,
            validRenderers.length
          ),
          hint: NoMatchingRenderer.hint(
            formatList(probableRendererNames.map((r5) => "`" + r5 + "`"))
          )
        });
      } else {
        throw new AstroError({
          ...NoClientOnlyHint,
          message: NoClientOnlyHint.message(metadata.displayName),
          hint: NoClientOnlyHint.hint(
            probableRendererNames.map((r5) => r5.replace("@astrojs/", "")).join("|")
          )
        });
      }
    } else if (typeof Component !== "string") {
      const matchingRenderers = validRenderers.filter(
        (r5) => probableRendererNames.includes(r5.name)
      );
      const plural = validRenderers.length > 1;
      if (matchingRenderers.length === 0) {
        throw new AstroError({
          ...NoMatchingRenderer,
          message: NoMatchingRenderer.message(
            metadata.displayName,
            metadata?.componentUrl?.split(".").pop(),
            plural,
            validRenderers.length
          ),
          hint: NoMatchingRenderer.hint(
            formatList(probableRendererNames.map((r5) => "`" + r5 + "`"))
          )
        });
      } else if (matchingRenderers.length === 1) {
        renderer = matchingRenderers[0];
        ({ html, attrs } = await renderer.ssr.renderToStaticMarkup.call(
          { result },
          Component,
          propsWithoutTransitionAttributes,
          children,
          metadata
        ));
      } else {
        throw new Error(`Unable to render ${metadata.displayName}!

This component likely uses ${formatList(probableRendererNames)},
but Astro encountered an error during server-side rendering.

Please ensure that ${metadata.displayName}:
1. Does not unconditionally access browser-specific globals like \`window\` or \`document\`.
   If this is unavoidable, use the \`client:only\` hydration directive.
2. Does not conditionally return \`null\` or \`undefined\` when rendered on the server.

If you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);
      }
    }
  } else {
    if (metadata.hydrate === "only") {
      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;
      if (!clientOnlyValues.has(rendererName)) {
        console.warn(
          `The client:only directive for ${metadata.displayName} is not recognized. The renderer ${renderer.name} will be used. If you intended to use a different renderer, please provide a valid client:only directive.`
        );
      }
      html = await renderSlotToString(result, slots?.fallback);
    } else {
      performance.now();
      ({ html, attrs } = await renderer.ssr.renderToStaticMarkup.call(
        { result },
        Component,
        propsWithoutTransitionAttributes,
        children,
        metadata
      ));
    }
  }
  if (renderer && !renderer.clientEntrypoint && renderer.name !== "@astrojs/lit" && metadata.hydrate) {
    throw new AstroError({
      ...NoClientEntrypoint,
      message: NoClientEntrypoint.message(
        displayName,
        metadata.hydrate,
        renderer.name
      )
    });
  }
  if (!html && typeof Component === "string") {
    const Tag = sanitizeElementName(Component);
    const childSlots = Object.values(children).join("");
    const renderTemplateResult = renderTemplate`<${Tag}${internalSpreadAttributes(
      props
    )}${markHTMLString(
      childSlots === "" && voidElementNames.test(Tag) ? `/>` : `>${childSlots}</${Tag}>`
    )}`;
    html = "";
    const destination = {
      write(chunk) {
        if (chunk instanceof Response)
          return;
        html += chunkToString(result, chunk);
      }
    };
    await renderTemplateResult.render(destination);
  }
  if (!hydration) {
    return {
      render(destination) {
        if (slotInstructions) {
          for (const instruction of slotInstructions) {
            destination.write(instruction);
          }
        }
        if (isPage || renderer?.name === "astro:jsx") {
          destination.write(html);
        } else if (html && html.length > 0) {
          destination.write(
            markHTMLString(removeStaticAstroSlot(html, renderer?.ssr?.supportsAstroStaticSlot))
          );
        }
      }
    };
  }
  const astroId = shorthash(
    `<!--${metadata.componentExport.value}:${metadata.componentUrl}-->
${html}
${serializeProps(
      props,
      metadata
    )}`
  );
  const island = await generateHydrateScript(
    { renderer, result, astroId, props, attrs },
    metadata
  );
  let unrenderedSlots = [];
  if (html) {
    if (Object.keys(children).length > 0) {
      for (const key of Object.keys(children)) {
        let tagName = renderer?.ssr?.supportsAstroStaticSlot ? !!metadata.hydrate ? "astro-slot" : "astro-static-slot" : "astro-slot";
        let expectedHTML = key === "default" ? `<${tagName}>` : `<${tagName} name="${key}">`;
        if (!html.includes(expectedHTML)) {
          unrenderedSlots.push(key);
        }
      }
    }
  } else {
    unrenderedSlots = Object.keys(children);
  }
  const template = unrenderedSlots.length > 0 ? unrenderedSlots.map(
    (key) => `<template data-astro-template${key !== "default" ? `="${key}"` : ""}>${children[key]}</template>`
  ).join("") : "";
  island.children = `${html ?? ""}${template}`;
  if (island.children) {
    island.props["await-children"] = "";
    island.children += `<!--astro:end-->`;
  }
  return {
    render(destination) {
      if (slotInstructions) {
        for (const instruction of slotInstructions) {
          destination.write(instruction);
        }
      }
      destination.write(createRenderInstruction({ type: "directive", hydration }));
      if (hydration.directive !== "only" && renderer?.ssr.renderHydrationScript) {
        destination.write(
          createRenderInstruction({
            type: "renderer-hydration-script",
            rendererName: renderer.name,
            render: renderer.ssr.renderHydrationScript
          })
        );
      }
      const renderedElement = renderElement$1("astro-island", island, false);
      destination.write(markHTMLString(renderedElement));
    }
  };
}
function sanitizeElementName(tag) {
  const unsafe = /[&<>'"\s]+/;
  if (!unsafe.test(tag))
    return tag;
  return tag.trim().split(unsafe)[0].trim();
}
async function renderFragmentComponent(result, slots = {}) {
  const children = await renderSlotToString(result, slots?.default);
  return {
    render(destination) {
      if (children == null)
        return;
      destination.write(children);
    }
  };
}
async function renderHTMLComponent(result, Component, _props, slots = {}) {
  const { slotInstructions, children } = await renderSlots(result, slots);
  const html = Component({ slots: children });
  const hydrationHtml = slotInstructions ? slotInstructions.map((instr) => chunkToString(result, instr)).join("") : "";
  return {
    render(destination) {
      destination.write(markHTMLString(hydrationHtml + html));
    }
  };
}
function renderAstroComponent(result, displayName, Component, props, slots = {}) {
  const instance = createAstroComponentInstance(result, displayName, Component, props, slots);
  return {
    async render(destination) {
      await instance.render(destination);
    }
  };
}
async function renderComponent(result, displayName, Component, props, slots = {}) {
  if (isPromise(Component)) {
    Component = await Component.catch(handleCancellation);
  }
  if (isFragmentComponent(Component)) {
    return await renderFragmentComponent(result, slots).catch(handleCancellation);
  }
  props = normalizeProps(props);
  if (isHTMLComponent(Component)) {
    return await renderHTMLComponent(result, Component, props, slots).catch(handleCancellation);
  }
  if (isAstroComponentFactory(Component)) {
    return renderAstroComponent(result, displayName, Component, props, slots);
  }
  return await renderFrameworkComponent(result, displayName, Component, props, slots).catch(
    handleCancellation
  );
  function handleCancellation(e2) {
    if (result.cancelled)
      return { render() {
      } };
    throw e2;
  }
}
function normalizeProps(props) {
  if (props["class:list"] !== void 0) {
    const value = props["class:list"];
    delete props["class:list"];
    props["class"] = clsx(props["class"], value);
    if (props["class"] === "") {
      delete props["class"];
    }
  }
  return props;
}
async function renderComponentToString(result, displayName, Component, props, slots = {}, isPage = false, route) {
  let str = "";
  let renderedFirstPageChunk = false;
  let head = "";
  if (isPage && !result.partial && nonAstroPageNeedsHeadInjection(Component)) {
    head += chunkToString(result, maybeRenderHead());
  }
  try {
    const destination = {
      write(chunk) {
        if (isPage && !result.partial && !renderedFirstPageChunk) {
          renderedFirstPageChunk = true;
          if (!/<!doctype html/i.test(String(chunk))) {
            const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
            str += doctype + head;
          }
        }
        if (chunk instanceof Response)
          return;
        str += chunkToString(result, chunk);
      }
    };
    const renderInstance = await renderComponent(result, displayName, Component, props, slots);
    await renderInstance.render(destination);
  } catch (e2) {
    if (AstroError.is(e2) && !e2.loc) {
      e2.setLocation({
        file: route?.component
      });
    }
    throw e2;
  }
  return str;
}
function nonAstroPageNeedsHeadInjection(pageComponent) {
  return !!pageComponent?.[needsHeadRenderingSymbol];
}
async function renderJSX(result, vnode) {
  switch (true) {
    case vnode instanceof HTMLString:
      if (vnode.toString().trim() === "") {
        return "";
      }
      return vnode;
    case typeof vnode === "string":
      return markHTMLString(escapeHTML(vnode));
    case typeof vnode === "function":
      return vnode;
    case (!vnode && vnode !== 0):
      return "";
    case Array.isArray(vnode):
      return markHTMLString(
        (await Promise.all(vnode.map((v4) => renderJSX(result, v4)))).join("")
      );
  }
  return renderJSXVNode(result, vnode);
}
async function renderJSXVNode(result, vnode) {
  if (isVNode(vnode)) {
    switch (true) {
      case !vnode.type: {
        throw new Error(`Unable to render ${result.pathname} because it contains an undefined Component!
Did you forget to import the component or is it possible there is a typo?`);
      }
      case vnode.type === Symbol.for("astro:fragment"):
        return renderJSX(result, vnode.props.children);
      case vnode.type.isAstroComponentFactory: {
        let props = {};
        let slots = {};
        for (const [key, value] of Object.entries(vnode.props ?? {})) {
          if (key === "children" || value && typeof value === "object" && value["$$slot"]) {
            slots[key === "children" ? "default" : key] = () => renderJSX(result, value);
          } else {
            props[key] = value;
          }
        }
        const str = await renderToString(result, vnode.type, props, slots);
        if (str instanceof Response) {
          throw str;
        }
        const html = markHTMLString(str);
        return html;
      }
      case (!vnode.type && vnode.type !== 0):
        return "";
      case (typeof vnode.type === "string" && vnode.type !== ClientOnlyPlaceholder):
        return markHTMLString(await renderElement(result, vnode.type, vnode.props ?? {}));
    }
    if (vnode.type) {
      let extractSlots2 = function(child) {
        if (Array.isArray(child)) {
          return child.map((c2) => extractSlots2(c2));
        }
        if (!isVNode(child)) {
          _slots.default.push(child);
          return;
        }
        if ("slot" in child.props) {
          _slots[child.props.slot] = [..._slots[child.props.slot] ?? [], child];
          delete child.props.slot;
          return;
        }
        _slots.default.push(child);
      };
      if (typeof vnode.type === "function" && vnode.props["server:root"]) {
        const output2 = await vnode.type(vnode.props ?? {});
        return await renderJSX(result, output2);
      }
      if (typeof vnode.type === "function") {
        if (vnode.props[hasTriedRenderComponentSymbol]) {
          const output2 = await vnode.type(vnode.props ?? {});
          if (output2?.[AstroJSX] || !output2) {
            return await renderJSXVNode(result, output2);
          } else {
            return;
          }
        } else {
          vnode.props[hasTriedRenderComponentSymbol] = true;
        }
      }
      const { children = null, ...props } = vnode.props ?? {};
      const _slots = {
        default: []
      };
      extractSlots2(children);
      for (const [key, value] of Object.entries(props)) {
        if (value?.["$$slot"]) {
          _slots[key] = value;
          delete props[key];
        }
      }
      const slotPromises = [];
      const slots = {};
      for (const [key, value] of Object.entries(_slots)) {
        slotPromises.push(
          renderJSX(result, value).then((output2) => {
            if (output2.toString().trim().length === 0)
              return;
            slots[key] = () => output2;
          })
        );
      }
      await Promise.all(slotPromises);
      let output;
      if (vnode.type === ClientOnlyPlaceholder && vnode.props["client:only"]) {
        output = await renderComponentToString(
          result,
          vnode.props["client:display-name"] ?? "",
          null,
          props,
          slots
        );
      } else {
        output = await renderComponentToString(
          result,
          typeof vnode.type === "function" ? vnode.type.name : vnode.type,
          vnode.type,
          props,
          slots
        );
      }
      return markHTMLString(output);
    }
  }
  return markHTMLString(`${vnode}`);
}
async function renderElement(result, tag, { children, ...props }) {
  return markHTMLString(
    `<${tag}${spreadAttributes(props)}${markHTMLString(
      (children == null || children == "") && voidElementNames.test(tag) ? `/>` : `>${children == null ? "" : await renderJSX(result, prerenderElementChildren(tag, children))}</${tag}>`
    )}`
  );
}
function prerenderElementChildren(tag, children) {
  if (typeof children === "string" && (tag === "style" || tag === "script")) {
    return markHTMLString(children);
  } else {
    return children;
  }
}
async function renderPage(result, componentFactory, props, children, streaming, route) {
  if (!isAstroComponentFactory(componentFactory)) {
    result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;
    const pageProps = { ...props ?? {}, "server:root": true };
    const str = await renderComponentToString(
      result,
      componentFactory.name,
      componentFactory,
      pageProps,
      {},
      true,
      route
    );
    const bytes = encoder.encode(str);
    return new Response(bytes, {
      headers: new Headers([
        ["Content-Type", "text/html; charset=utf-8"],
        ["Content-Length", bytes.byteLength.toString()]
      ])
    });
  }
  result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;
  let body;
  if (streaming) {
    if (isNode && !isDeno) {
      const nodeBody = await renderToAsyncIterable(
        result,
        componentFactory,
        props,
        children,
        true,
        route
      );
      body = nodeBody;
    } else {
      body = await renderToReadableStream(result, componentFactory, props, children, true, route);
    }
  } else {
    body = await renderToString(result, componentFactory, props, children, true, route);
  }
  if (body instanceof Response)
    return body;
  const init2 = result.response;
  const headers = new Headers(init2.headers);
  if (!streaming && typeof body === "string") {
    body = encoder.encode(body);
    headers.set("Content-Length", body.byteLength.toString());
  }
  if (route?.component.endsWith(".md")) {
    headers.set("Content-Type", "text/html; charset=utf-8");
  }
  const response = new Response(body, { ...init2, headers });
  return response;
}
function spreadAttributes(values = {}, _name, { class: scopedClassName } = {}) {
  let output = "";
  if (scopedClassName) {
    if (typeof values.class !== "undefined") {
      values.class += ` ${scopedClassName}`;
    } else if (typeof values["class:list"] !== "undefined") {
      values["class:list"] = [values["class:list"], scopedClassName];
    } else {
      values.class = scopedClassName;
    }
  }
  for (const [key, value] of Object.entries(values)) {
    output += addAttribute(value, key, true);
  }
  return markHTMLString(output);
}
var ASTRO_VERSION, REROUTE_DIRECTIVE_HEADER, ROUTE_TYPE_HEADER, DEFAULT_404_COMPONENT, REROUTABLE_STATUS_CODES, clientAddressSymbol, clientLocalsSymbol, responseSentSymbol, ClientAddressNotAvailable, StaticClientAddressNotAvailable, NoMatchingStaticPathFound, OnlyResponseCanBeReturned, MissingMediaQueryDirective, NoMatchingRenderer, NoClientEntrypoint, NoClientOnlyHint, InvalidGetStaticPathsEntry, InvalidGetStaticPathsReturn, GetStaticPathsExpectedParams, GetStaticPathsInvalidRouteParam, GetStaticPathsRequired, ReservedSlotName, NoMatchingImport, InvalidComponentArgs, PageNumberParamNotFound, ImageMissingAlt, InvalidImageService, MissingImageDimension, FailedToFetchRemoteImageDimensions, UnsupportedImageFormat, UnsupportedImageConversion, PrerenderDynamicEndpointPathCollide, ExpectedImage, ExpectedImageOptions, IncompatibleDescriptorOptions, ResponseSentError, MiddlewareNoDataOrNextCalled, MiddlewareNotAResponse, EndpointDidNotReturnAResponse, LocalsNotAnObject, AstroResponseHeadersReassigned, LocalImageUsedWrongly, AstroGlobUsedOutside, AstroGlobNoMatch, AstroError, FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY, $, bold, dim, red, yellow, blue, cyan, replace, ca, esca, pe, escape, escapeHTML, HTMLString, markHTMLString, AstroJSX, RenderInstructionSymbol, PROP_TYPE, transitionDirectivesToCopyOnIsland, dictionary, binary, headAndContentSym, astro_island_prebuilt_default, ISLAND_STYLES, voidElementNames, htmlBooleanAttributes, htmlEnumAttributes, svgEnumAttributes, STATIC_DIRECTIVES, toIdent, toAttributeString, kebab, toStyleString, noop, BufferedRenderer, isNode, isDeno, VALID_PROTOCOLS, uniqueElements, slotString, SlotString, Fragment, Renderer, encoder, decoder, astroComponentInstanceSym, AstroComponentInstance, renderTemplateResultSym, RenderTemplateResult, DOCTYPE_EXP, needsHeadRenderingSymbol, rendererAliases, clientOnlyValues, ASTRO_SLOT_EXP, ASTRO_STATIC_SLOT_EXP, ClientOnlyPlaceholder, hasTriedRenderComponentSymbol, object, hasOwnProperty, merge, regexAnySingleEscape, regexSingleEscape, regexExcessiveSpaces, cssesc;
var init_astro_BO0wYrHs = __esm({
  ".wrangler/tmp/pages-KkpaTB/chunks/astro_BO0wYrHs.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    ASTRO_VERSION = "4.6.0";
    REROUTE_DIRECTIVE_HEADER = "X-Astro-Reroute";
    ROUTE_TYPE_HEADER = "X-Astro-Route-Type";
    DEFAULT_404_COMPONENT = "astro-default-404";
    REROUTABLE_STATUS_CODES = [404, 500];
    clientAddressSymbol = Symbol.for("astro.clientAddress");
    clientLocalsSymbol = Symbol.for("astro.locals");
    responseSentSymbol = Symbol.for("astro.responseSent");
    ClientAddressNotAvailable = {
      name: "ClientAddressNotAvailable",
      title: "`Astro.clientAddress` is not available in current adapter.",
      message: (adapterName) => `\`Astro.clientAddress\` is not available in the \`${adapterName}\` adapter. File an issue with the adapter to add support.`
    };
    StaticClientAddressNotAvailable = {
      name: "StaticClientAddressNotAvailable",
      title: "`Astro.clientAddress` is not available in static mode.",
      message: "`Astro.clientAddress` is only available when using `output: 'server'` or `output: 'hybrid'`. Update your Astro config if you need SSR features.",
      hint: "See https://docs.astro.build/en/guides/server-side-rendering/ for more information on how to enable SSR."
    };
    NoMatchingStaticPathFound = {
      name: "NoMatchingStaticPathFound",
      title: "No static path found for requested path.",
      message: (pathName) => `A \`getStaticPaths()\` route pattern was matched, but no matching static path was found for requested path \`${pathName}\`.`,
      hint: (possibleRoutes) => `Possible dynamic routes being matched: ${possibleRoutes.join(", ")}.`
    };
    OnlyResponseCanBeReturned = {
      name: "OnlyResponseCanBeReturned",
      title: "Invalid type returned by Astro page.",
      message: (route, returnedValue) => `Route \`${route ? route : ""}\` returned a \`${returnedValue}\`. Only a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be returned from Astro files.`,
      hint: "See https://docs.astro.build/en/guides/server-side-rendering/#response for more information."
    };
    MissingMediaQueryDirective = {
      name: "MissingMediaQueryDirective",
      title: "Missing value for `client:media` directive.",
      message: 'Media query not provided for `client:media` directive. A media query similar to `client:media="(max-width: 600px)"` must be provided'
    };
    NoMatchingRenderer = {
      name: "NoMatchingRenderer",
      title: "No matching renderer found.",
      message: (componentName, componentExtension, plural, validRenderersCount) => `Unable to render \`${componentName}\`.

${validRenderersCount > 0 ? `There ${plural ? "are" : "is"} ${validRenderersCount} renderer${plural ? "s" : ""} configured in your \`astro.config.mjs\` file,
but ${plural ? "none were" : "it was not"} able to server-side render \`${componentName}\`.` : `No valid renderer was found ${componentExtension ? `for the \`.${componentExtension}\` file extension.` : `for this file extension.`}`}`,
      hint: (probableRenderers) => `Did you mean to enable the ${probableRenderers} integration?

See https://docs.astro.build/en/guides/framework-components/ for more information on how to install and configure integrations.`
    };
    NoClientEntrypoint = {
      name: "NoClientEntrypoint",
      title: "No client entrypoint specified in renderer.",
      message: (componentName, clientDirective, rendererName) => `\`${componentName}\` component has a \`client:${clientDirective}\` directive, but no client entrypoint was provided by \`${rendererName}\`.`,
      hint: "See https://docs.astro.build/en/reference/integrations-reference/#addrenderer-option for more information on how to configure your renderer."
    };
    NoClientOnlyHint = {
      name: "NoClientOnlyHint",
      title: "Missing hint on client:only directive.",
      message: (componentName) => `Unable to render \`${componentName}\`. When using the \`client:only\` hydration strategy, Astro needs a hint to use the correct renderer.`,
      hint: (probableRenderers) => `Did you mean to pass \`client:only="${probableRenderers}"\`? See https://docs.astro.build/en/reference/directives-reference/#clientonly for more information on client:only`
    };
    InvalidGetStaticPathsEntry = {
      name: "InvalidGetStaticPathsEntry",
      title: "Invalid entry inside getStaticPath's return value",
      message: (entryType) => `Invalid entry returned by getStaticPaths. Expected an object, got \`${entryType}\``,
      hint: "If you're using a `.map` call, you might be looking for `.flatMap()` instead. See https://docs.astro.build/en/reference/api-reference/#getstaticpaths for more information on getStaticPaths."
    };
    InvalidGetStaticPathsReturn = {
      name: "InvalidGetStaticPathsReturn",
      title: "Invalid value returned by getStaticPaths.",
      message: (returnType) => `Invalid type returned by \`getStaticPaths\`. Expected an \`array\`, got \`${returnType}\``,
      hint: "See https://docs.astro.build/en/reference/api-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsExpectedParams = {
      name: "GetStaticPathsExpectedParams",
      title: "Missing params property on `getStaticPaths` route.",
      message: "Missing or empty required `params` property on `getStaticPaths` route.",
      hint: "See https://docs.astro.build/en/reference/api-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsInvalidRouteParam = {
      name: "GetStaticPathsInvalidRouteParam",
      title: "Invalid value for `getStaticPaths` route parameter.",
      message: (key, value, valueType) => `Invalid getStaticPaths route parameter for \`${key}\`. Expected undefined, a string or a number, received \`${valueType}\` (\`${value}\`)`,
      hint: "See https://docs.astro.build/en/reference/api-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsRequired = {
      name: "GetStaticPathsRequired",
      title: "`getStaticPaths()` function required for dynamic routes.",
      message: "`getStaticPaths()` function is required for dynamic routes. Make sure that you `export` a `getStaticPaths` function from your dynamic route.",
      hint: `See https://docs.astro.build/en/guides/routing/#dynamic-routes for more information on dynamic routes.

Alternatively, set \`output: "server"\` or \`output: "hybrid"\` in your Astro config file to switch to a non-static server build. This error can also occur if using \`export const prerender = true;\`.
See https://docs.astro.build/en/guides/server-side-rendering/ for more information on non-static rendering.`
    };
    ReservedSlotName = {
      name: "ReservedSlotName",
      title: "Invalid slot name.",
      message: (slotName2) => `Unable to create a slot named \`${slotName2}\`. \`${slotName2}\` is a reserved slot name. Please update the name of this slot.`
    };
    NoMatchingImport = {
      name: "NoMatchingImport",
      title: "No import found for component.",
      message: (componentName) => `Could not render \`${componentName}\`. No matching import has been found for \`${componentName}\`.`,
      hint: "Please make sure the component is properly imported."
    };
    InvalidComponentArgs = {
      name: "InvalidComponentArgs",
      title: "Invalid component arguments.",
      message: (name) => `Invalid arguments passed to${name ? ` <${name}>` : ""} component.`,
      hint: "Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."
    };
    PageNumberParamNotFound = {
      name: "PageNumberParamNotFound",
      title: "Page number param not found.",
      message: (paramName) => `[paginate()] page number param \`${paramName}\` not found in your filepath.`,
      hint: "Rename your file to `[page].astro` or `[...page].astro`."
    };
    ImageMissingAlt = {
      name: "ImageMissingAlt",
      title: 'Image missing required "alt" property.',
      message: 'Image missing "alt" property. "alt" text is required to describe important images on the page.',
      hint: 'Use an empty string ("") for decorative images.'
    };
    InvalidImageService = {
      name: "InvalidImageService",
      title: "Error while loading image service.",
      message: "There was an error loading the configured image service. Please see the stack trace for more information."
    };
    MissingImageDimension = {
      name: "MissingImageDimension",
      title: "Missing image dimensions",
      message: (missingDimension, imageURL) => `Missing ${missingDimension === "both" ? "width and height attributes" : `${missingDimension} attribute`} for ${imageURL}. When using remote images, both dimensions are required unless in order to avoid CLS.`,
      hint: "If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets). You can also use `inferSize={true}` for remote images to get the original dimensions."
    };
    FailedToFetchRemoteImageDimensions = {
      name: "FailedToFetchRemoteImageDimensions",
      title: "Failed to retrieve remote image dimensions",
      message: (imageURL) => `Failed to get the dimensions for ${imageURL}.`,
      hint: "Verify your remote image URL is accurate, and that you are not using `inferSize` with a file located in your `public/` folder."
    };
    UnsupportedImageFormat = {
      name: "UnsupportedImageFormat",
      title: "Unsupported image format",
      message: (format2, imagePath, supportedFormats) => `Received unsupported format \`${format2}\` from \`${imagePath}\`. Currently only ${supportedFormats.join(
        ", "
      )} are supported by our image services.`,
      hint: "Using an `img` tag directly instead of the `Image` component might be what you're looking for."
    };
    UnsupportedImageConversion = {
      name: "UnsupportedImageConversion",
      title: "Unsupported image conversion",
      message: "Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."
    };
    PrerenderDynamicEndpointPathCollide = {
      name: "PrerenderDynamicEndpointPathCollide",
      title: "Prerendered dynamic endpoint has path collision.",
      message: (pathname) => `Could not render \`${pathname}\` with an \`undefined\` param as the generated path will collide during prerendering. Prevent passing \`undefined\` as \`params\` for the endpoint's \`getStaticPaths()\` function, or add an additional extension to the endpoint's filename.`,
      hint: (filename) => `Rename \`${filename}\` to \`${filename.replace(/\.(?:js|ts)/, (m2) => `.json` + m2)}\``
    };
    ExpectedImage = {
      name: "ExpectedImage",
      title: "Expected src to be an image.",
      message: (src, typeofOptions, fullOptions) => `Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${src}\` (type: \`${typeofOptions}\`).

Full serialized options received: \`${fullOptions}\`.`,
      hint: "This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."
    };
    ExpectedImageOptions = {
      name: "ExpectedImageOptions",
      title: "Expected image options.",
      message: (options) => `Expected getImage() parameter to be an object. Received \`${options}\`.`
    };
    IncompatibleDescriptorOptions = {
      name: "IncompatibleDescriptorOptions",
      title: "Cannot set both `densities` and `widths`",
      message: "Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",
      hint: "Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."
    };
    ResponseSentError = {
      name: "ResponseSentError",
      title: "Unable to set response.",
      message: "The response has already been sent to the browser and cannot be altered."
    };
    MiddlewareNoDataOrNextCalled = {
      name: "MiddlewareNoDataOrNextCalled",
      title: "The middleware didn't return a `Response`.",
      message: "Make sure your middleware returns a `Response` object, either directly or by returning the `Response` from calling the `next` function."
    };
    MiddlewareNotAResponse = {
      name: "MiddlewareNotAResponse",
      title: "The middleware returned something that is not a `Response` object.",
      message: "Any data returned from middleware must be a valid `Response` object."
    };
    EndpointDidNotReturnAResponse = {
      name: "EndpointDidNotReturnAResponse",
      title: "The endpoint did not return a `Response`.",
      message: "An endpoint must return either a `Response`, or a `Promise` that resolves with a `Response`."
    };
    LocalsNotAnObject = {
      name: "LocalsNotAnObject",
      title: "Value assigned to `locals` is not accepted.",
      message: "`locals` can only be assigned to an object. Other values like numbers, strings, etc. are not accepted.",
      hint: "If you tried to remove some information from the `locals` object, try to use `delete` or set the property to `undefined`."
    };
    AstroResponseHeadersReassigned = {
      name: "AstroResponseHeadersReassigned",
      title: "`Astro.response.headers` must not be reassigned.",
      message: "Individual headers can be added to and removed from `Astro.response.headers`, but it must not be replaced with another instance of `Headers` altogether.",
      hint: "Consider using `Astro.response.headers.add()`, and `Astro.response.headers.delete()`."
    };
    LocalImageUsedWrongly = {
      name: "LocalImageUsedWrongly",
      title: "Local images must be imported.",
      message: (imageFilePath) => `\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${imageFilePath}\`.`,
      hint: "If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections). See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."
    };
    AstroGlobUsedOutside = {
      name: "AstroGlobUsedOutside",
      title: "Astro.glob() used outside of an Astro file.",
      message: (globStr) => `\`Astro.glob(${globStr})\` can only be used in \`.astro\` files. \`import.meta.glob(${globStr})\` can be used instead to achieve a similar result.`,
      hint: "See Vite's documentation on `import.meta.glob` for more information: https://vitejs.dev/guide/features.html#glob-import"
    };
    AstroGlobNoMatch = {
      name: "AstroGlobNoMatch",
      title: "Astro.glob() did not match any files.",
      message: (globStr) => `\`Astro.glob(${globStr})\` did not return any matching files.`,
      hint: "Check the pattern for typos."
    };
    AstroError = class extends Error {
      loc;
      title;
      hint;
      frame;
      type = "AstroError";
      constructor(props, options) {
        const { name, title, message: message2, stack, location, hint, frame } = props;
        super(message2, options);
        this.title = title;
        this.name = name;
        if (message2)
          this.message = message2;
        this.stack = stack ? stack : this.stack;
        this.loc = location;
        this.hint = hint;
        this.frame = frame;
      }
      setLocation(location) {
        this.loc = location;
      }
      setName(name) {
        this.name = name;
      }
      setMessage(message2) {
        this.message = message2;
      }
      setHint(hint) {
        this.hint = hint;
      }
      setFrame(source, location) {
        this.frame = codeFrame(source, location);
      }
      static is(err) {
        return err.type === "AstroError";
      }
    };
    isTTY = true;
    if (typeof process !== "undefined") {
      ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
      isTTY = process.stdout && process.stdout.isTTY;
    }
    $ = {
      enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
    };
    bold = init(1, 22);
    dim = init(2, 22);
    red = init(31, 39);
    yellow = init(33, 39);
    blue = init(34, 39);
    cyan = init(36, 39);
    ({ replace } = "");
    ca = /[&<>'"]/g;
    esca = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "'": "&#39;",
      '"': "&quot;"
    };
    pe = (m2) => esca[m2];
    escape = (es2) => replace.call(es2, ca, pe);
    escapeHTML = escape;
    HTMLString = class extends String {
      get [Symbol.toStringTag]() {
        return "HTMLString";
      }
    };
    markHTMLString = (value) => {
      if (value instanceof HTMLString) {
        return value;
      }
      if (typeof value === "string") {
        return new HTMLString(value);
      }
      return value;
    };
    AstroJSX = "astro:jsx";
    RenderInstructionSymbol = Symbol.for("astro:render");
    PROP_TYPE = {
      Value: 0,
      JSON: 1,
      // Actually means Array
      RegExp: 2,
      Date: 3,
      Map: 4,
      Set: 5,
      BigInt: 6,
      URL: 7,
      Uint8Array: 8,
      Uint16Array: 9,
      Uint32Array: 10
    };
    transitionDirectivesToCopyOnIsland = Object.freeze([
      "data-astro-transition-scope",
      "data-astro-transition-persist",
      "data-astro-transition-persist-props"
    ]);
    dictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY";
    binary = dictionary.length;
    headAndContentSym = Symbol.for("astro.headAndContent");
    astro_island_prebuilt_default = `(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=\` (export \${b})\`),console.error(\`[hydrate] Error parsing props for component \${i}\`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(\`astro:\${n}\`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(\`[astro-island] Error hydrating \${this.getAttribute("component-url")}\`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();`;
    ISLAND_STYLES = `<style>astro-island,astro-slot,astro-static-slot{display:contents}</style>`;
    voidElementNames = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
    htmlBooleanAttributes = /^(?:allowfullscreen|async|autofocus|autoplay|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|itemscope)$/i;
    htmlEnumAttributes = /^(?:contenteditable|draggable|spellcheck|value)$/i;
    svgEnumAttributes = /^(?:autoReverse|externalResourcesRequired|focusable|preserveAlpha)$/i;
    STATIC_DIRECTIVES = /* @__PURE__ */ new Set(["set:html", "set:text"]);
    toIdent = (k4) => k4.trim().replace(/(?!^)\b\w|\s+|\W+/g, (match2, index3) => {
      if (/\W/.test(match2))
        return "";
      return index3 === 0 ? match2 : match2.toUpperCase();
    });
    toAttributeString = (value, shouldEscape = true) => shouldEscape ? String(value).replace(/&/g, "&#38;").replace(/"/g, "&#34;") : value;
    kebab = (k4) => k4.toLowerCase() === k4 ? k4 : k4.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
    toStyleString = (obj) => Object.entries(obj).filter(([_3, v4]) => typeof v4 === "string" && v4.trim() || typeof v4 === "number").map(([k4, v4]) => {
      if (k4[0] !== "-" && k4[1] !== "-")
        return `${kebab(k4)}:${v4}`;
      return `${k4}:${v4}`;
    }).join(";");
    noop = () => {
    };
    BufferedRenderer = class {
      chunks = [];
      renderPromise;
      destination;
      constructor(bufferRenderFunction) {
        this.renderPromise = bufferRenderFunction(this);
        Promise.resolve(this.renderPromise).catch(noop);
      }
      write(chunk) {
        if (this.destination) {
          this.destination.write(chunk);
        } else {
          this.chunks.push(chunk);
        }
      }
      async renderToFinalDestination(destination) {
        for (const chunk of this.chunks) {
          destination.write(chunk);
        }
        this.destination = destination;
        await this.renderPromise;
      }
    };
    isNode = typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]";
    isDeno = typeof Deno !== "undefined";
    VALID_PROTOCOLS = ["http:", "https:"];
    uniqueElements = (item, index3, all) => {
      const props = JSON.stringify(item.props);
      const children = item.children;
      return index3 === all.findIndex((i2) => JSON.stringify(i2.props) === props && i2.children == children);
    };
    slotString = Symbol.for("astro:slot-string");
    SlotString = class extends HTMLString {
      instructions;
      [slotString];
      constructor(content, instructions) {
        super(content);
        this.instructions = instructions;
        this[slotString] = true;
      }
    };
    Fragment = Symbol.for("astro:fragment");
    Renderer = Symbol.for("astro:renderer");
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    astroComponentInstanceSym = Symbol.for("astro.componentInstance");
    AstroComponentInstance = class {
      [astroComponentInstanceSym] = true;
      result;
      props;
      slotValues;
      factory;
      returnValue;
      constructor(result, props, slots, factory) {
        this.result = result;
        this.props = props;
        this.factory = factory;
        this.slotValues = {};
        for (const name in slots) {
          let didRender = false;
          let value = slots[name](result);
          this.slotValues[name] = () => {
            if (!didRender) {
              didRender = true;
              return value;
            }
            return slots[name](result);
          };
        }
      }
      async init(result) {
        if (this.returnValue !== void 0)
          return this.returnValue;
        this.returnValue = this.factory(result, this.props, this.slotValues);
        return this.returnValue;
      }
      async render(destination) {
        if (this.returnValue === void 0) {
          await this.init(this.result);
        }
        let value = this.returnValue;
        if (isPromise(value)) {
          value = await value;
        }
        if (isHeadAndContent(value)) {
          await value.content.render(destination);
        } else {
          await renderChild(destination, value);
        }
      }
    };
    renderTemplateResultSym = Symbol.for("astro.renderTemplateResult");
    RenderTemplateResult = class {
      [renderTemplateResultSym] = true;
      htmlParts;
      expressions;
      error;
      constructor(htmlParts, expressions) {
        this.htmlParts = htmlParts;
        this.error = void 0;
        this.expressions = expressions.map((expression) => {
          if (isPromise(expression)) {
            return Promise.resolve(expression).catch((err) => {
              if (!this.error) {
                this.error = err;
                throw err;
              }
            });
          }
          return expression;
        });
      }
      async render(destination) {
        const expRenders = this.expressions.map((exp) => {
          return renderToBufferDestination((bufferDestination) => {
            if (exp || exp === 0) {
              return renderChild(bufferDestination, exp);
            }
          });
        });
        for (let i2 = 0; i2 < this.htmlParts.length; i2++) {
          const html = this.htmlParts[i2];
          const expRender = expRenders[i2];
          destination.write(markHTMLString(html));
          if (expRender) {
            await expRender.renderToFinalDestination(destination);
          }
        }
      }
    };
    DOCTYPE_EXP = /<!doctype html/i;
    needsHeadRenderingSymbol = Symbol.for("astro.needsHeadRendering");
    rendererAliases = /* @__PURE__ */ new Map([["solid", "solid-js"]]);
    clientOnlyValues = /* @__PURE__ */ new Set(["solid-js", "react", "preact", "vue", "svelte", "lit"]);
    ASTRO_SLOT_EXP = /<\/?astro-slot\b[^>]*>/g;
    ASTRO_STATIC_SLOT_EXP = /<\/?astro-static-slot\b[^>]*>/g;
    ClientOnlyPlaceholder = "astro-client-only";
    hasTriedRenderComponentSymbol = Symbol("hasTriedRenderComponent");
    object = {};
    hasOwnProperty = object.hasOwnProperty;
    merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_".split("").reduce((v4, c2) => (v4[c2.charCodeAt(0)] = c2, v4), []);
    "-0123456789_".split("").reduce((v4, c2) => (v4[c2.charCodeAt(0)] = c2, v4), []);
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/pages/_trpc__GIzfMcGy.mjs
var trpc_GIzfMcGy_exports = {};
__export(trpc_GIzfMcGy_exports, {
  I: () => INTERNAL_DO_NOT_USE__fatalClientError,
  U: () => UploadThingError,
  _: () => _trpc_,
  a: () => createRecursiveProxy,
  b: () => contentDisposition,
  c: () => createFlatProxy,
  d: () => semverLite,
  e: () => generatePermittedFileTypes,
  f: () => styleFieldToClassName,
  g: () => getCauseFromUnknown,
  h: () => styleFieldToCssObject,
  i: () => contentFieldToContent,
  j: () => generateMimeTypes,
  k: () => allowedContentTextLabelGenerator,
  l: () => generateClientDropzoneAccept,
  m: () => generateId,
  n: () => nameSchema,
  o: () => emailSchema,
  p: () => placeSchema,
  q: () => positionSchema,
  r: () => resolveMaybeUrlArg,
  s: () => safeParseJSON,
  t: () => createUploadthing,
  u: () => createRouteHandler,
  w: () => withExponentialBackoff,
  z: () => z
});
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v4 = obj[key];
    newObj[v4] = key;
  }
  return newObj;
}
function getStatusCodeFromKey(code) {
  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
}
function getHTTPStatusCode(json) {
  const arr = Array.isArray(json) ? json : [
    json
  ];
  const httpStatuses = new Set(arr.map((res) => {
    if ("error" in res) {
      const data = res.error.data;
      if (typeof data.httpStatus === "number") {
        return data.httpStatus;
      }
      const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];
      return getStatusCodeFromKey(code);
    }
    return 200;
  }));
  if (httpStatuses.size !== 1) {
    return 207;
  }
  const httpStatus = httpStatuses.values().next().value;
  return httpStatus;
}
function getHTTPStatusCodeFromError(error2) {
  return getStatusCodeFromKey(error2.code);
}
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop2, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _22, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
function isObject$2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject$2(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
function getTRPCErrorFromUnknown(cause) {
  if (cause instanceof TRPCError) {
    return cause;
  }
  if (cause instanceof Error && cause.name === "TRPCError") {
    return cause;
  }
  const trpcError = new TRPCError({
    code: "INTERNAL_SERVER_ERROR",
    cause
  });
  if (cause instanceof Error && cause.stack) {
    trpcError.stack = cause.stack;
  }
  return trpcError;
}
function getDataTransformer(transformer) {
  if ("input" in transformer) {
    return transformer;
  }
  return {
    input: transformer,
    output: transformer
  };
}
function omitPrototype(obj) {
  return Object.assign(/* @__PURE__ */ Object.create(null), obj);
}
function isRouter(procedureOrRouter) {
  return "router" in procedureOrRouter._def;
}
function createRouterFactory(config) {
  return function createRouterInner(procedures) {
    const reservedWordsUsed = new Set(Object.keys(procedures).filter((v4) => reservedWords.includes(v4)));
    if (reservedWordsUsed.size > 0) {
      throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
    }
    const routerProcedures = omitPrototype({});
    function recursiveGetPaths(procedures2, path = "") {
      for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
        const newPath = `${path}${key}`;
        if (isRouter(procedureOrRouter)) {
          recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
          continue;
        }
        if (routerProcedures[newPath]) {
          throw new Error(`Duplicate key: ${newPath}`);
        }
        routerProcedures[newPath] = procedureOrRouter;
      }
    }
    recursiveGetPaths(procedures);
    const _def = {
      _config: config,
      router: true,
      procedures: routerProcedures,
      ...emptyRouter,
      record: procedures,
      queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {})
    };
    const router = {
      ...procedures,
      _def,
      createCaller(ctx) {
        return createCallerFactory()(router)(ctx);
      },
      getErrorShape(opts2) {
        const { path, error: error2 } = opts2;
        const { code } = opts2.error;
        const shape = {
          message: error2.message,
          code: TRPC_ERROR_CODES_BY_KEY[code],
          data: {
            code,
            httpStatus: getHTTPStatusCodeFromError(error2)
          }
        };
        if (config.isDev && typeof opts2.error.stack === "string") {
          shape.data.stack = opts2.error.stack;
        }
        if (typeof path === "string") {
          shape.data.path = path;
        }
        return this._def._config.errorFormatter({
          ...opts2,
          shape
        });
      }
    };
    return router;
  };
}
function callProcedure(opts2) {
  const { type, path } = opts2;
  if (!(path in opts2.procedures) || !opts2.procedures[path]?._def[type]) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: `No "${type}"-procedure on path "${path}"`
    });
  }
  const procedure = opts2.procedures[path];
  return procedure(opts2);
}
function createCallerFactory() {
  return function createCallerInner(router) {
    const def = router._def;
    return function createCaller(ctx) {
      const proxy = createRecursiveProxy(({ path, args }) => {
        if (path.length === 1 && procedureTypes.includes(path[0])) {
          return callProcedure({
            procedures: def.procedures,
            path: args[0],
            rawInput: args[1],
            ctx,
            type: path[0]
          });
        }
        const fullPath = path.join(".");
        const procedure = def.procedures[fullPath];
        let type = "query";
        if (procedure._def.mutation) {
          type = "mutation";
        } else if (procedure._def.subscription) {
          type = "subscription";
        }
        return procedure({
          path: fullPath,
          rawInput: args[0],
          ctx,
          type
        });
      });
      return proxy;
    };
  };
}
function getErrorShape(opts2) {
  const { path, error: error2, config } = opts2;
  const { code } = opts2.error;
  const shape = {
    message: error2.message,
    code: TRPC_ERROR_CODES_BY_KEY[code],
    data: {
      code,
      httpStatus: getHTTPStatusCodeFromError(error2)
    }
  };
  if (config.isDev && typeof opts2.error.stack === "string") {
    shape.data.stack = opts2.error.stack;
  }
  if (typeof path === "string") {
    shape.data.path = path;
  }
  return config.errorFormatter({
    ...opts2,
    shape
  });
}
function transformTRPCResponseItem(config, item) {
  if ("error" in item) {
    return {
      ...item,
      error: config.transformer.output.serialize(item.error)
    };
  }
  if ("data" in item.result) {
    return {
      ...item,
      result: {
        ...item.result,
        data: config.transformer.output.serialize(item.result.data)
      }
    };
  }
  return item;
}
function transformTRPCResponse(config, itemOrItems) {
  return Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);
}
function getRawProcedureInputOrThrow(opts2) {
  const { req } = opts2;
  try {
    if (req.method === "GET") {
      if (!req.query.has("input")) {
        return void 0;
      }
      const raw = req.query.get("input");
      return JSON.parse(raw);
    }
    if (!opts2.preprocessedBody && typeof req.body === "string") {
      return req.body.length === 0 ? void 0 : JSON.parse(req.body);
    }
    return req.body;
  } catch (cause) {
    throw new TRPCError({
      code: "PARSE_ERROR",
      cause
    });
  }
}
function initResponse(initOpts) {
  const { ctx, paths, type, responseMeta, untransformedJSON, errors = [] } = initOpts;
  let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;
  const headers = {
    "Content-Type": "application/json"
  };
  const eagerGeneration = !untransformedJSON;
  const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [
    untransformedJSON
  ];
  const meta = responseMeta?.({
    ctx,
    paths,
    type,
    data,
    errors,
    eagerGeneration
  }) ?? {};
  for (const [key, value] of Object.entries(meta.headers ?? {})) {
    headers[key] = value;
  }
  if (meta.status) {
    status = meta.status;
  }
  return {
    status,
    headers
  };
}
async function inputToProcedureCall(procedureOpts) {
  const { opts: opts2, ctx, type, input, path } = procedureOpts;
  try {
    const data = await callProcedure({
      procedures: opts2.router._def.procedures,
      path,
      rawInput: input,
      ctx,
      type
    });
    return {
      result: {
        data
      }
    };
  } catch (cause) {
    const error2 = getTRPCErrorFromUnknown(cause);
    opts2.onError?.({
      error: error2,
      path,
      input,
      ctx,
      type,
      req: opts2.req
    });
    return {
      error: getErrorShape({
        config: opts2.router._def._config,
        error: error2,
        type,
        path,
        input,
        ctx
      })
    };
  }
}
function caughtErrorToData(cause, errorOpts) {
  const { router, req, onError } = errorOpts.opts;
  const error2 = getTRPCErrorFromUnknown(cause);
  onError?.({
    error: error2,
    path: errorOpts.path,
    input: errorOpts.input,
    ctx: errorOpts.ctx,
    type: errorOpts.type,
    req
  });
  const untransformedJSON = {
    error: getErrorShape({
      config: router._def._config,
      error: error2,
      type: errorOpts.type,
      path: errorOpts.path,
      input: errorOpts.input,
      ctx: errorOpts.ctx
    })
  };
  const transformedJSON = transformTRPCResponse(router._def._config, untransformedJSON);
  const body = JSON.stringify(transformedJSON);
  return {
    error: error2,
    untransformedJSON,
    body
  };
}
async function resolveHTTPResponse(opts2) {
  const { router, req, unstable_onHead, unstable_onChunk } = opts2;
  if (req.method === "HEAD") {
    const headResponse = {
      status: 204
    };
    unstable_onHead?.(headResponse, false);
    unstable_onChunk?.([
      -1,
      ""
    ]);
    return headResponse;
  }
  const contentTypeHandler = opts2.contentTypeHandler ?? fallbackContentTypeHandler;
  const batchingEnabled = opts2.batching?.enabled ?? true;
  const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? "unknown";
  let ctx = void 0;
  let paths;
  const isBatchCall = !!req.query.get("batch");
  const isStreamCall = isBatchCall && unstable_onHead && unstable_onChunk && req.headers["trpc-batch-mode"] === "stream";
  try {
    ctx = await opts2.createContext();
    if (opts2.error) {
      throw opts2.error;
    }
    if (isBatchCall && !batchingEnabled) {
      throw new Error(`Batching is not enabled on the server`);
    }
    if (type === "subscription") {
      throw new TRPCError({
        message: "Subscriptions should use wsLink",
        code: "METHOD_NOT_SUPPORTED"
      });
    }
    if (type === "unknown") {
      throw new TRPCError({
        message: `Unexpected request method ${req.method}`,
        code: "METHOD_NOT_SUPPORTED"
      });
    }
    const inputs = await contentTypeHandler.getInputs({
      isBatchCall,
      req,
      router,
      preprocessedBody: opts2.preprocessedBody ?? false
    });
    paths = isBatchCall ? decodeURIComponent(opts2.path).split(",") : [
      opts2.path
    ];
    const promises = paths.map((path, index3) => inputToProcedureCall({
      opts: opts2,
      ctx,
      type,
      input: inputs[index3],
      path
    }));
    if (!isStreamCall) {
      const untransformedJSON = await Promise.all(promises);
      const errors = untransformedJSON.flatMap((response) => "error" in response ? [
        response.error
      ] : []);
      const headResponse1 = initResponse({
        ctx,
        paths,
        type,
        responseMeta: opts2.responseMeta,
        untransformedJSON,
        errors
      });
      unstable_onHead?.(headResponse1, false);
      const result = isBatchCall ? untransformedJSON : untransformedJSON[0];
      const transformedJSON = transformTRPCResponse(router._def._config, result);
      const body = JSON.stringify(transformedJSON);
      unstable_onChunk?.([
        -1,
        body
      ]);
      return {
        status: headResponse1.status,
        headers: headResponse1.headers,
        body
      };
    }
    const headResponse2 = initResponse({
      ctx,
      paths,
      type,
      responseMeta: opts2.responseMeta
    });
    unstable_onHead(headResponse2, true);
    const indexedPromises = new Map(promises.map((promise, index3) => [
      index3,
      promise.then((r5) => [
        index3,
        r5
      ])
    ]));
    for (const _3 of paths) {
      const [index3, untransformedJSON1] = await Promise.race(indexedPromises.values());
      indexedPromises.delete(index3);
      try {
        const transformedJSON1 = transformTRPCResponse(router._def._config, untransformedJSON1);
        const body1 = JSON.stringify(transformedJSON1);
        unstable_onChunk([
          index3,
          body1
        ]);
      } catch (cause) {
        const path = paths[index3];
        const input = inputs[index3];
        const { body: body2 } = caughtErrorToData(cause, {
          opts: opts2,
          ctx,
          type,
          path,
          input
        });
        unstable_onChunk([
          index3,
          body2
        ]);
      }
    }
    return;
  } catch (cause1) {
    const { error: error2, untransformedJSON: untransformedJSON2, body: body3 } = caughtErrorToData(cause1, {
      opts: opts2,
      ctx,
      type
    });
    const headResponse3 = initResponse({
      ctx,
      paths,
      type,
      responseMeta: opts2.responseMeta,
      untransformedJSON: untransformedJSON2,
      errors: [
        error2
      ]
    });
    unstable_onHead?.(headResponse3, false);
    unstable_onChunk?.([
      -1,
      body3
    ]);
    return {
      status: headResponse3.status,
      headers: headResponse3.headers,
      body: body3
    };
  }
}
function getBatchStreamFormatter() {
  let first = true;
  function format2(index3, string) {
    const prefix = first ? "{" : ",";
    first = false;
    return `${prefix}"${index3}":${string}
`;
  }
  format2.end = () => "}";
  return format2;
}
function toURL(urlOrPathname) {
  const url = urlOrPathname.startsWith("/") ? `http://127.0.0.1${urlOrPathname}` : urlOrPathname;
  return new URL(url);
}
async function fetchRequestHandler(opts2) {
  const resHeaders = new Headers();
  const createContext2 = async () => {
    return opts2.createContext?.({
      req: opts2.req,
      resHeaders
    });
  };
  const url = toURL(opts2.req.url);
  const pathname = trimSlashes(url.pathname);
  const endpoint = trimSlashes(opts2.endpoint);
  const path = trimSlashes(pathname.slice(endpoint.length));
  const req = {
    query: url.searchParams,
    method: opts2.req.method,
    headers: Object.fromEntries(opts2.req.headers),
    body: opts2.req.headers.get("content-type")?.startsWith("application/json") ? await opts2.req.text() : ""
  };
  let resolve;
  const promise = new Promise((r5) => resolve = r5);
  let status = 200;
  let isStream = false;
  let controller;
  let encoder2;
  let formatter;
  const unstable_onHead = (head, isStreaming) => {
    for (const [key, value] of Object.entries(head.headers ?? {})) {
      if (typeof value === "undefined") {
        continue;
      }
      if (typeof value === "string") {
        resHeaders.set(key, value);
        continue;
      }
      for (const v4 of value) {
        resHeaders.append(key, v4);
      }
    }
    status = head.status;
    if (isStreaming) {
      resHeaders.set("Transfer-Encoding", "chunked");
      resHeaders.append("Vary", "trpc-batch-mode");
      const stream = new ReadableStream({
        start(c2) {
          controller = c2;
        }
      });
      const response = new Response(stream, {
        status,
        headers: resHeaders
      });
      resolve(response);
      encoder2 = new TextEncoder();
      formatter = getBatchStreamFormatter();
      isStream = true;
    }
  };
  const unstable_onChunk = ([index3, string]) => {
    if (index3 === -1) {
      const response = new Response(string || null, {
        status,
        headers: resHeaders
      });
      resolve(response);
    } else {
      controller.enqueue(encoder2.encode(formatter(index3, string)));
    }
  };
  resolveHTTPResponse({
    req,
    createContext: createContext2,
    path,
    router: opts2.router,
    batching: opts2.batching,
    responseMeta: opts2.responseMeta,
    onError(o3) {
      opts2?.onError?.({
        ...o3,
        req: opts2.req
      });
    },
    unstable_onHead,
    unstable_onChunk
  }).then(() => {
    if (isStream) {
      controller.enqueue(encoder2.encode(formatter.end()));
      controller.close();
    }
  }).catch(() => {
    if (isStream) {
      controller.close();
    }
  });
  return promise;
}
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p4) => {
    if (is(p4, Placeholder)) {
      if (!(p4.name in values)) {
        throw new Error(`No value for placeholder "${p4.name}" was provided`);
      }
      return values[p4.name];
    }
    return p4;
  });
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
}
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v4) => bindIfParam(v4, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min2, max2) {
  return sql`${column} between ${bindIfParam(min2, column)} and ${bindIfParam(
    max2,
    column
  )}`;
}
function notBetween(column, min2, max2) {
  return sql`${column} not between ${bindIfParam(
    min2,
    column
  )} and ${bindIfParam(max2, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(
      sourceTable,
      table,
      config,
      config?.fields.reduce((res, f3) => res && f3.notNull, true) ?? false
    );
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder3;
      if (is(field, Column)) {
        decoder3 = field;
      } else if (is(field, SQL)) {
        decoder3 = field.decoder;
      } else {
        decoder3 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder3.mapFromDriverValue(value);
    }
  }
  return result;
}
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}
function sum(expression) {
  return sql`sum(${expression})`.mapWith(String);
}
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder3;
      if (is(field, Column)) {
        decoder3 = field;
      } else if (is(field, SQL)) {
        decoder3 = field.decoder;
      } else {
        decoder3 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder3.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index3, key] of leftKeys.entries()) {
    if (key !== rightKeys[index3]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
function uniqueKeyName(table, columns) {
  return `${table[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
function customType(customTypeParams) {
  return (dbName, fieldConfig) => {
    return new SQLiteCustomColumnBuilder(
      dbName,
      fieldConfig,
      customTypeParams
    );
  };
}
function integer(name, config) {
  if (config?.mode === "timestamp" || config?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config.mode);
  }
  if (config?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config.mode);
  }
  return new SQLiteIntegerBuilder(name);
}
function text(name, config = {}) {
  return config.mode === "json" ? new SQLiteTextJsonBuilder(name) : new SQLiteTextBuilder(name, config);
}
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
function index(name) {
  return new IndexBuilderOn(name, false);
}
function isSerializedSQL(value) {
  return typeof value === "object" && value !== null && SERIALIZED_SQL_KEY in value;
}
function drizzle(callback, batchCallback, config) {
  const dialect = new SQLiteAsyncDialect();
  let logger2;
  let _batchCallback;
  let _config = {};
  if (batchCallback) {
    if (typeof batchCallback === "function") {
      _batchCallback = batchCallback;
      _config = config ?? {};
    } else {
      _batchCallback = void 0;
      _config = batchCallback;
    }
    if (_config.logger === true) {
      logger2 = new DefaultLogger();
    } else if (_config.logger !== false) {
      logger2 = _config.logger;
    }
  }
  let schema;
  if (_config.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      _config.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: _config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteRemoteSession(callback, dialect, schema, _batchCallback, { logger: logger2 });
  return new SqliteRemoteDatabase("async", dialect, session, schema);
}
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x4) => !!x4)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index3 = 0; index3 < a2.length; index3++) {
      const itemA = a2[index3];
      const itemB = b2[index3];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
async function safeFetch(url, options = {}, onNotOK = () => {
  throw new Error(`Request to ${url} returned a non-OK status code.`);
}) {
  const response = await fetch(url, options);
  if (!response.ok) {
    await onNotOK(response);
  }
  return response;
}
function createRemoteDatabaseClient(appToken, remoteDbURL) {
  const url = new URL("/db/query", remoteDbURL);
  const db4 = drizzle(
    async (sql2, parameters, method) => {
      const requestBody = { sql: sql2, args: parameters };
      const res = await safeFetch(
        url,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${appToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody)
        },
        (response) => {
          throw new Error(
            `Failed to execute query.
Query: ${sql2}
Full error: ${response.status} ${response.statusText}`
          );
        }
      );
      let remoteResult;
      try {
        const json = await res.json();
        remoteResult = remoteResultSchema.parse(json);
      } catch (e2) {
        throw new Error(
          `Failed to execute query.
Query: ${sql2}
Full error: Unexpected JSON response. ${e2 instanceof Error ? e2.message : String(e2)}`
        );
      }
      if (method === "run")
        return remoteResult;
      const rowValues = [];
      for (const row of remoteResult.rows) {
        if (row != null && typeof row === "object") {
          rowValues.push(Object.values(row));
        }
      }
      if (method === "get") {
        return { rows: rowValues[0] };
      }
      return { rows: rowValues };
    },
    async (queries) => {
      const stmts = queries.map(({ sql: sql2, params }) => ({ sql: sql2, args: params }));
      const res = await safeFetch(
        url,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${appToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(stmts)
        },
        (response) => {
          throw new Error(
            `Failed to execute batch queries.
Full error: ${response.status} ${response.statusText}}`
          );
        }
      );
      let remoteResults;
      try {
        const json = await res.json();
        remoteResults = z.array(remoteResultSchema).parse(json);
      } catch (e2) {
        throw new Error(
          `Failed to execute batch queries.
Full error: Unexpected JSON response. ${e2 instanceof Error ? e2.message : String(e2)}`
        );
      }
      let results = [];
      for (const [idx, rawResult] of remoteResults.entries()) {
        if (queries[idx]?.method === "run") {
          results.push(rawResult);
          continue;
        }
        const rowValues = [];
        for (const row of rawResult.rows) {
          if (row != null && typeof row === "object") {
            rowValues.push(Object.values(row));
          }
        }
        if (queries[idx]?.method === "get") {
          results.push({ rows: rowValues[0] });
        }
        results.push({ rows: rowValues });
      }
      return results;
    }
  );
  return db4;
}
function hasPrimaryKey(column) {
  return "primaryKey" in column.schema && !!column.schema.primaryKey;
}
function asDrizzleTable(name, table) {
  const columns = {};
  if (!Object.entries(table.columns).some(([, column]) => hasPrimaryKey(column))) {
    columns["_id"] = integer("_id").primaryKey();
  }
  for (const [columnName, column] of Object.entries(table.columns)) {
    columns[columnName] = columnMapper(columnName, column);
  }
  const drizzleTable = sqliteTable(name, columns, (ormTable) => {
    const indexes = {};
    for (const [indexName, indexProps] of Object.entries(table.indexes ?? {})) {
      const onColNames = Array.isArray(indexProps.on) ? indexProps.on : [indexProps.on];
      const onCols = onColNames.map((colName) => ormTable[colName]);
      if (!atLeastOne(onCols))
        continue;
      indexes[indexName] = index(indexName).on(...onCols);
    }
    return indexes;
  });
  return drizzleTable;
}
function atLeastOne(arr) {
  return arr.length > 0;
}
function columnMapper(columnName, column) {
  let c2;
  switch (column.type) {
    case "text": {
      c2 = text(columnName);
      if (column.schema.default !== void 0)
        c2 = c2.default(handleSerializedSQL(column.schema.default));
      if (column.schema.primaryKey === true)
        c2 = c2.primaryKey();
      break;
    }
    case "number": {
      c2 = integer(columnName);
      if (column.schema.default !== void 0)
        c2 = c2.default(handleSerializedSQL(column.schema.default));
      if (column.schema.primaryKey === true)
        c2 = c2.primaryKey();
      break;
    }
    case "boolean": {
      c2 = integer(columnName, { mode: "boolean" });
      if (column.schema.default !== void 0)
        c2 = c2.default(handleSerializedSQL(column.schema.default));
      break;
    }
    case "json":
      c2 = jsonType(columnName);
      if (column.schema.default !== void 0)
        c2 = c2.default(column.schema.default);
      break;
    case "date": {
      c2 = dateType(columnName);
      if (column.schema.default !== void 0) {
        const def = handleSerializedSQL(column.schema.default);
        c2 = c2.default(typeof def === "string" ? new Date(def) : def);
      }
      break;
    }
  }
  if (!column.schema.optional)
    c2 = c2.notNull();
  if (column.schema.unique)
    c2 = c2.unique();
  return c2;
}
function handleSerializedSQL(def) {
  if (isSerializedSQL(def)) {
    return sql.raw(def.sql);
  }
  return def;
}
async function createContextInner(opts2) {
  return {
    session: opts2?.session,
    db,
    CVS,
    ATTACHMENTS
  };
}
async function createContext(opts2) {
  const contextInner = await createContextInner();
  return {
    ...contextInner
  };
}
function getParseFn$1(procedureParser) {
  const parser = procedureParser;
  if (typeof parser === "function") {
    return parser;
  }
  if (typeof parser.parseAsync === "function") {
    return parser.parseAsync.bind(parser);
  }
  if (typeof parser.parse === "function") {
    return parser.parse.bind(parser);
  }
  if (typeof parser.validateSync === "function") {
    return parser.validateSync.bind(parser);
  }
  if (typeof parser.create === "function") {
    return parser.create.bind(parser);
  }
  if (typeof parser.assert === "function") {
    return (value) => {
      parser.assert(value);
      return value;
    };
  }
  throw new Error("Could not find a validator fn");
}
function mergeWithoutOverrides(obj1, ...objs) {
  const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
  for (const overrides of objs) {
    for (const key in overrides) {
      if (key in newObj && newObj[key] !== overrides[key]) {
        throw new Error(`Duplicate key ${key}`);
      }
      newObj[key] = overrides[key];
    }
  }
  return newObj;
}
function createMiddlewareFactory() {
  function createMiddlewareInner(middlewares) {
    return {
      _middlewares: middlewares,
      unstable_pipe(middlewareBuilderOrFn) {
        const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createMiddlewareInner([
          ...middlewares,
          ...pipedMiddleware
        ]);
      }
    };
  }
  function createMiddleware(fn2) {
    return createMiddlewareInner([
      fn2
    ]);
  }
  return createMiddleware;
}
function isPlainObject$1(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
}
function createInputMiddleware(parse4) {
  const inputMiddleware = async ({ next, rawInput, input }) => {
    let parsedInput;
    try {
      parsedInput = await parse4(rawInput);
    } catch (cause) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        cause
      });
    }
    const combinedInput = isPlainObject$1(input) && isPlainObject$1(parsedInput) ? {
      ...input,
      ...parsedInput
    } : parsedInput;
    return next({
      input: combinedInput
    });
  };
  inputMiddleware._type = "input";
  return inputMiddleware;
}
function createOutputMiddleware(parse4) {
  const outputMiddleware = async ({ next }) => {
    const result = await next();
    if (!result.ok) {
      return result;
    }
    try {
      const data = await parse4(result.data);
      return {
        ...result,
        data
      };
    } catch (cause) {
      throw new TRPCError({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause
      });
    }
  };
  outputMiddleware._type = "output";
  return outputMiddleware;
}
function createNewBuilder(def1, def2) {
  const { middlewares = [], inputs, meta, ...rest } = def2;
  return createBuilder$1({
    ...mergeWithoutOverrides(def1, rest),
    inputs: [
      ...def1.inputs,
      ...inputs ?? []
    ],
    middlewares: [
      ...def1.middlewares,
      ...middlewares
    ],
    meta: def1.meta && meta ? {
      ...def1.meta,
      ...meta
    } : meta ?? def1.meta
  });
}
function createBuilder$1(initDef = {}) {
  const _def = {
    inputs: [],
    middlewares: [],
    ...initDef
  };
  return {
    _def,
    input(input) {
      const parser = getParseFn$1(input);
      return createNewBuilder(_def, {
        inputs: [
          input
        ],
        middlewares: [
          createInputMiddleware(parser)
        ]
      });
    },
    output(output) {
      const parseOutput = getParseFn$1(output);
      return createNewBuilder(_def, {
        output,
        middlewares: [
          createOutputMiddleware(parseOutput)
        ]
      });
    },
    meta(meta) {
      return createNewBuilder(_def, {
        meta
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(builder) {
      return createNewBuilder(_def, builder._def);
    },
    use(middlewareBuilderOrFn) {
      const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
        middlewareBuilderOrFn
      ];
      return createNewBuilder(_def, {
        middlewares
      });
    },
    query(resolver) {
      return createResolver({
        ..._def,
        query: true
      }, resolver);
    },
    mutation(resolver) {
      return createResolver({
        ..._def,
        mutation: true
      }, resolver);
    },
    subscription(resolver) {
      return createResolver({
        ..._def,
        subscription: true
      }, resolver);
    }
  };
}
function createResolver(_def, resolver) {
  const finalBuilder = createNewBuilder(_def, {
    resolver,
    middlewares: [
      async function resolveMiddleware(opts2) {
        const data = await resolver(opts2);
        return {
          marker: middlewareMarker,
          ok: true,
          data,
          ctx: opts2.ctx
        };
      }
    ]
  });
  return createProcedureCaller(finalBuilder._def);
}
function createProcedureCaller(_def) {
  const procedure = async function resolve(opts2) {
    if (!opts2 || !("rawInput" in opts2)) {
      throw new Error(codeblock);
    }
    const callRecursive = async (callOpts = {
      index: 0,
      ctx: opts2.ctx
    }) => {
      try {
        const middleware = _def.middlewares[callOpts.index];
        const result2 = await middleware({
          ctx: callOpts.ctx,
          type: opts2.type,
          path: opts2.path,
          rawInput: callOpts.rawInput ?? opts2.rawInput,
          meta: _def.meta,
          input: callOpts.input,
          next(_nextOpts) {
            const nextOpts = _nextOpts;
            return callRecursive({
              index: callOpts.index + 1,
              ctx: nextOpts && "ctx" in nextOpts ? {
                ...callOpts.ctx,
                ...nextOpts.ctx
              } : callOpts.ctx,
              input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
              rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
            });
          }
        });
        return result2;
      } catch (cause) {
        return {
          ok: false,
          error: getTRPCErrorFromUnknown(cause),
          marker: middlewareMarker
        };
      }
    };
    const result = await callRecursive();
    if (!result) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    }
    if (!result.ok) {
      throw result.error;
    }
    return result.data;
  };
  procedure._def = _def;
  procedure.meta = _def.meta;
  return procedure;
}
function mergeRouters(...routerList) {
  const record = mergeWithoutOverrides({}, ...routerList.map((r5) => r5._def.record));
  const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
    if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
      if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
        throw new Error("You seem to have several error formatters");
      }
      return nextRouter._def._config.errorFormatter;
    }
    return currentErrorFormatter;
  }, defaultFormatter);
  const transformer = routerList.reduce((prev, current) => {
    if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
      if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
        throw new Error("You seem to have several transformers");
      }
      return current._def._config.transformer;
    }
    return prev;
  }, defaultTransformer);
  const router2 = createRouterFactory({
    errorFormatter,
    transformer,
    isDev: routerList.some((r5) => r5._def._config.isDev),
    allowOutsideOfServer: routerList.some((r5) => r5._def._config.allowOutsideOfServer),
    isServer: routerList.some((r5) => r5._def._config.isServer),
    $types: routerList[0]?._def._config.$types
  })(record);
  return router2;
}
function createTRPCInner() {
  return function initTRPCInner(runtime) {
    const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;
    const transformer = getDataTransformer(runtime?.transformer ?? defaultTransformer);
    const config = {
      transformer,
      isDev: runtime?.isDev ?? false,
      allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,
      errorFormatter,
      isServer: runtime?.isServer ?? isServerDefault,
      /**
      * @internal
      */
      $types: createFlatProxy((key) => {
        throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
      })
    };
    {
      const isServer2 = runtime?.isServer ?? isServerDefault;
      if (!isServer2 && runtime?.allowOutsideOfServer !== true) {
        throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
      }
    }
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: config,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: createBuilder$1({
        meta: runtime?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: createMiddlewareFactory(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: createRouterFactory(config),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: createCallerFactory()
    };
  };
}
function B() {
  if (define_globalThis_process_env_default)
    for (const e2 of p) {
      const o3 = e2[1] || e2[0];
      if (define_globalThis_process_env_default[o3])
        return { name: e2[0].toLowerCase(), ...e2[2] };
    }
  return define_globalThis_process_env_default?.SHELL === "/bin/jsh" && globalThis.process?.versions?.webcontainer ? { name: "stackblitz", ci: false } : { name: "", ci: false };
}
function n(e2) {
  return e2 ? e2 !== "false" : false;
}
function G() {
  const e2 = F.find((o3) => o3[0]);
  if (e2)
    return { name: e2[1] };
}
function extname(path) {
  const index3 = path.lastIndexOf(".");
  return index3 < 0 ? "" : path.substring(index3);
}
function lookup(path) {
  if (!path || typeof path !== "string") {
    return false;
  }
  const extension = extname("x." + path).toLowerCase().substring(1);
  if (!extension) {
    return false;
  }
  return types[extension] || false;
}
function populateMaps(extensions2, types3) {
  const preference = [
    "nginx",
    "apache",
    void 0,
    "iana"
  ];
  Object.keys(mimeTypes).forEach((type) => {
    const mime2 = mimeTypes[type];
    const exts = mime2.extensions;
    if (!exts?.length) {
      return;
    }
    extensions2[type] = exts;
    for (const extension of exts) {
      if (types3[extension]) {
        const from = preference.indexOf(mimeTypes[types3[extension]].source);
        const to = preference.indexOf(mime2.source);
        if (types3[extension] !== "application/octet-stream" && (from > to || from === to && types3[extension].startsWith("application/"))) {
          continue;
        }
      }
      types3[extension] = type;
    }
  });
}
function isRouteArray(routeConfig) {
  return Array.isArray(routeConfig);
}
function getDefaultSizeForType(fileType) {
  if (fileType === "image")
    return "4MB";
  if (fileType === "video")
    return "16MB";
  if (fileType === "audio")
    return "8MB";
  if (fileType === "blob")
    return "8MB";
  if (fileType === "pdf")
    return "4MB";
  if (fileType === "text")
    return "64KB";
  return "4MB";
}
function fillInputRouteConfig(routeConfig) {
  if (isRouteArray(routeConfig)) {
    return routeConfig.reduce((acc, fileType) => {
      acc[fileType] = {
        // Apply defaults
        maxFileSize: getDefaultSizeForType(fileType),
        maxFileCount: 1,
        minFileCount: 1,
        contentDisposition: "inline"
      };
      return acc;
    }, {});
  }
  const newConfig = {};
  const inputKeys = objectKeys(routeConfig);
  inputKeys.forEach((key) => {
    const value = routeConfig[key];
    if (!value)
      throw new Error("Invalid config during fill");
    const defaultValues = {
      maxFileSize: getDefaultSizeForType(key),
      maxFileCount: 1,
      minFileCount: 1,
      contentDisposition: "inline"
    };
    newConfig[key] = {
      ...defaultValues,
      ...value
    };
  }, {});
  return newConfig;
}
function getTypeFromFileName(fileName, allowedTypes) {
  const mimeType = lookup(fileName);
  if (!mimeType) {
    if (allowedTypes.includes("blob"))
      return "blob";
    throw new Error(`Could not determine type for ${fileName}, presigned URL generation failed`);
  }
  if (allowedTypes.some((type2) => type2.includes("/"))) {
    if (allowedTypes.includes(mimeType)) {
      return mimeType;
    }
  }
  const type = mimeType.toLowerCase() === "application/pdf" ? "pdf" : mimeType.split("/")[0];
  if (!allowedTypes.includes(type)) {
    if (allowedTypes.includes("blob")) {
      return "blob";
    } else {
      throw new Error(`File type ${type} not allowed for ${fileName}`);
    }
  }
  return type;
}
function generateUploadThingURL(path) {
  let host = "https://uploadthing.com";
  if (w.env.CUSTOM_INFRA_URL) {
    host = w.env.CUSTOM_INFRA_URL;
  }
  return `${host}${path}`;
}
async function pollForFileData(opts2, callback) {
  return withExponentialBackoff(async () => {
    const res = await opts2.fetch(opts2.url, {
      headers: {
        ...opts2.apiKey && {
          "x-uploadthing-api-key": opts2.apiKey
        },
        "x-uploadthing-version": opts2.sdkVersion
      }
    });
    const maybeJson = await safeParseJSON(res);
    if (maybeJson instanceof Error) {
      console.error(`[UT] Error polling for file data for ${opts2.url}: ${maybeJson.message}`);
      return null;
    }
    if (maybeJson.status !== "done")
      return void 0;
    await callback?.(maybeJson);
    return Symbol("backoff done without response");
  });
}
async function safeParseJSON(input) {
  if (typeof input === "string") {
    try {
      return JSON.parse(input);
    } catch (err) {
      console.error(`Error parsing JSON, got '${input}'`);
      return new Error(`Error parsing JSON, got '${input}'`);
    }
  }
  const text3 = await input.text();
  try {
    return JSON.parse(text3 ?? "null");
  } catch (err) {
    console.error(`Error parsing JSON, got '${text3}'`);
    return new Error(`Error parsing JSON, got '${text3}'`);
  }
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function isObject$1(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function asArray(val) {
  return Array.isArray(val) ? val : [
    val
  ];
}
function contentDisposition(contentDisposition2, fileName) {
  return [
    contentDisposition2,
    `filename="${encodeURI(fileName)}"`,
    `filename*=UTF-8''${encodeURI(fileName)}`
  ].join("; ");
}
function semverLite(required, toCheck) {
  const semverRegex = /(\d+)\.?(\d+)?\.?(\d+)?/;
  const requiredMatch = required.match(semverRegex);
  if (!requiredMatch?.[0]) {
    throw new Error(`Invalid semver requirement: ${required}`);
  }
  const toCheckMatch = toCheck.match(semverRegex);
  if (!toCheckMatch?.[0]) {
    throw new Error(`Invalid semver to check: ${toCheck}`);
  }
  const [_1, rMajor, rMinor, rPatch] = requiredMatch;
  const [_22, cMajor, cMinor, cPatch] = toCheckMatch;
  if (required.startsWith("^")) {
    if (rMajor !== cMajor)
      return false;
    if (rMinor > cMinor)
      return false;
    return true;
  }
  if (required.startsWith("~")) {
    if (rMajor !== cMajor)
      return false;
    if (rMinor !== cMinor)
      return false;
    return true;
  }
  return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;
}
function getFullApiUrl(maybeUrl) {
  const base = (() => {
    if (typeof window !== "undefined")
      return window.location.origin;
    if (w.env?.VERCEL_URL)
      return `https://${w.env.VERCEL_URL}`;
    return "http://localhost:3000";
  })();
  try {
    const url = new URL(maybeUrl ?? "/api/uploadthing", base);
    if (url.pathname === "/") {
      url.pathname = "/api/uploadthing";
    }
    return url;
  } catch (err) {
    throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);
  }
}
function resolveMaybeUrlArg(maybeUrl) {
  return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);
}
function messageFromUnknown(cause, fallback) {
  if (typeof cause === "string") {
    return cause;
  }
  if (cause instanceof Error) {
    return cause.message;
  }
  if (cause && typeof cause === "object" && "message" in cause && typeof cause.message === "string") {
    return cause.message;
  }
  return fallback ?? "An unknown error occurred";
}
function getStatusCodeFromError(error2) {
  return ERROR_CODES[error2.code] ?? 500;
}
function getErrorTypeFromStatusCode(statusCode) {
  for (const [code, status] of Object.entries(ERROR_CODES)) {
    if (status === statusCode) {
      return code;
    }
  }
  return "INTERNAL_SERVER_ERROR";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object2 = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object2, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object2[key])) {
      object2[key] = [...value, ...object2[key]];
    } else if (isObject(value) && isObject(object2[key])) {
      object2[key] = _defu(
        value,
        object2[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object2[key] = value;
    }
  }
  return object2;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p4, c2) => _defu(p4, c2, "", merger), {})
  );
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}
function _normalizeLogLevel(input, types3 = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types3[input] && types3[input].level !== void 0) {
    return types3[input].level;
  }
  return defaultLevel;
}
function createConsola(options = {}) {
  return new Consola(options);
}
function defaultErrorFormatter(error2) {
  return {
    message: error2.message
  };
}
function formatError(error2, router) {
  const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
  return errorFormatter(error2);
}
function formatStack(stack) {
  const cwd = "cwd" in w && typeof w.cwd === "function" ? w.cwd() : "__UnknownCWD__";
  return "  " + stack.split("\n").splice(1).map((l4) => l4.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
  const fmtArgs = args.map((arg) => {
    if (isObject$1(arg) && typeof arg.stack === "string") {
      return arg.message + "\n" + formatStack(arg.stack);
    }
    return arg;
  });
  return fmtArgs.map((arg) => {
    if (typeof arg === "string") {
      return arg;
    }
    return JSON.stringify(arg, null, 4);
  });
}
function getParseFn(parser) {
  if (typeof parser.parse === "function") {
    return parser.parse;
  }
  throw new Error("Invalid parser");
}
function resolveCallbackUrl(opts2) {
  let callbackUrl = opts2.url;
  if (opts2.config?.callbackUrl) {
    callbackUrl = resolveMaybeUrlArg(opts2.config.callbackUrl);
  } else if (w.env.UPLOADTHING_URL) {
    callbackUrl = resolveMaybeUrlArg(w.env.UPLOADTHING_URL);
  }
  if (opts2.isDev || !callbackUrl.host.includes("localhost")) {
    return callbackUrl;
  }
  const headers = opts2.req.headers;
  let parsedFromHeaders = headers.get("origin") ?? headers.get("referer") ?? headers.get("host") ?? headers.get("x-forwarded-host");
  if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
    parsedFromHeaders = (headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
  }
  if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
    logger.warn("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
    return callbackUrl;
  }
  return resolveMaybeUrlArg(parsedFromHeaders);
}
function incompatibleNodeGuard() {
  if (typeof w === "undefined")
    return;
  let major;
  let minor;
  const maybeNodeVersion = w.versions?.node?.split(".");
  if (maybeNodeVersion) {
    [major, minor] = maybeNodeVersion.map((v4) => parseInt(v4, 10));
  }
  const maybeNodePath = w.env?.NODE;
  if (!major && maybeNodePath) {
    const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
    if (nodeVersion) {
      [major, minor] = nodeVersion.substring(1).split(".").map((v4) => parseInt(v4, 10));
    }
  }
  if (!major || !minor)
    return;
  if (major > 18)
    return;
  if (major === 18 && minor >= 13)
    return;
  logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);
  w.exit?.(1);
}
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    inputParser: {
      parse: () => void 0,
      _input: void 0,
      _output: void 0
    },
    middleware: () => ({}),
    onUploadError: () => ({}),
    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
    // Overload with properties passed in
    ...initDef
  };
  return {
    input(userParser) {
      return internalCreateBuilder({
        ..._def,
        inputParser: userParser
      });
    },
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    },
    onUploadError(userOnUploadError) {
      return internalCreateBuilder({
        ..._def,
        onUploadError: userOnUploadError
      });
    }
  };
}
function createBuilder(opts2) {
  return (input) => {
    return internalCreateBuilder({
      routerConfig: input,
      ...opts2
    });
  };
}
async function uploadPart(opts2, retryCount = 0) {
  const s3Res = await opts2.fetch(opts2.url, {
    method: "PUT",
    body: opts2.chunk,
    headers: {
      "Content-Type": opts2.contentType,
      "Content-Disposition": contentDisposition(opts2.contentDisposition, opts2.fileName)
    }
  });
  if (s3Res.ok) {
    const etag2 = s3Res.headers.get("Etag");
    if (!etag2) {
      throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "Missing Etag header from uploaded part"
      });
    }
    return etag2.replace(/"/g, "");
  }
  if (retryCount < opts2.maxRetries) {
    const delay = 2 ** retryCount * 1e3;
    await new Promise((r5) => setTimeout(r5, delay));
    return uploadPart(opts2, retryCount++);
  }
  await opts2.fetch(generateUploadThingURL("/api/failureCallback"), {
    method: "POST",
    body: JSON.stringify({
      fileKey: opts2.key
    }),
    headers: opts2.utRequestHeaders
  });
  const text3 = await s3Res.text();
  const parsed = maybeParseResponseXML(text3);
  if (parsed?.message) {
    throw new UploadThingError({
      code: "UPLOAD_FAILED",
      message: parsed.message
    });
  }
  throw new UploadThingError({
    code: "UPLOAD_FAILED",
    message: "Failed to upload file to storage provider",
    cause: s3Res
  });
}
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow(apiKey) {
  if (apiKey)
    return apiKey;
  if (w.env.UPLOADTHING_SECRET)
    return w.env.UPLOADTHING_SECRET;
  throw new UploadThingError({
    code: "MISSING_ENV",
    message: "Missing `UPLOADTHING_SECRET` env variable."
  });
}
async function uploadMultipart(file, presigned, opts2) {
  logger.debug("Uploading file", file.name, "with", presigned.urls.length, "chunks of size", presigned.chunkSize, "bytes each");
  const etags = await Promise.all(presigned.urls.map(async (url, index3) => {
    const offset2 = presigned.chunkSize * index3;
    const end = Math.min(offset2 + presigned.chunkSize, file.size);
    const chunk = file.slice(offset2, end);
    const etag2 = await uploadPart({
      fetch: opts2.fetch,
      url,
      chunk,
      contentDisposition: presigned.contentDisposition,
      contentType: file.type,
      fileName: file.name,
      maxRetries: 10,
      key: presigned.key,
      utRequestHeaders: opts2.utRequestHeaders
    });
    logger.debug("Part", index3 + 1, "uploaded successfully:", etag2);
    return {
      tag: etag2,
      partNumber: index3 + 1
    };
  }));
  logger.debug("File", file.name, "uploaded successfully. Notifying UploadThing to complete multipart upload.");
  const completionRes = await opts2.fetch(generateUploadThingURL("/api/completeMultipart"), {
    method: "POST",
    body: JSON.stringify({
      fileKey: presigned.key,
      uploadId: presigned.uploadId,
      etags
    }),
    headers: opts2.utRequestHeaders
  });
  logger.debug("UploadThing responsed with status:", completionRes.status);
}
async function uploadPresignedPost(file, presigned, opts2) {
  logger.debug("Uploading file", file.name, "using presigned POST URL");
  const formData = new FormData();
  Object.entries(presigned.fields).forEach(([k4, v4]) => formData.append(k4, v4));
  formData.append("file", file);
  const res = await opts2.fetch(presigned.url, {
    method: "POST",
    body: formData,
    headers: new Headers({
      Accept: "application/xml"
    })
  });
  if (!res.ok) {
    const text3 = await res.text();
    logger.error("Failed to upload file:", text3);
    throw new UploadThingError({
      code: "UPLOAD_FAILED",
      message: "Failed to upload file",
      cause: text3
    });
  }
  logger.debug("File", file.name, "uploaded successfully");
}
function parseTimeToSeconds(time) {
  const match2 = time.toString().split(/(\d+)/).filter(Boolean);
  const num = Number(match2[0]);
  const unit = (match2[1] ?? "s").trim().slice(0, 1);
  const multiplier = {
    s: 1,
    m: 60,
    h: 3600,
    d: 86400
  }[unit];
  return num * multiplier;
}
function byteToBinary(byte) {
  return byte.toString(2).padStart(8, "0");
}
function bytesToBinary(bytes) {
  return [...bytes].map((val) => byteToBinary(val)).join("");
}
function bytesToInteger(bytes) {
  return parseInt(bytesToBinary(bytes), 2);
}
function generateRandomInteger(max2) {
  if (max2 < 0 || !Number.isInteger(max2)) {
    throw new Error("Argument 'max' must be an integer greater than or equal to 0");
  }
  const bitLength = (max2 - 1).toString(2).length;
  const shift2 = bitLength % 8;
  const bytes = new Uint8Array(Math.ceil(bitLength / 8));
  crypto.getRandomValues(bytes);
  if (shift2 !== 0) {
    bytes[0] &= (1 << shift2) - 1;
  }
  let result = bytesToInteger(bytes);
  while (result >= max2) {
    crypto.getRandomValues(bytes);
    if (shift2 !== 0) {
      bytes[0] &= (1 << shift2) - 1;
    }
    result = bytesToInteger(bytes);
  }
  return result;
}
function generateRandomString(length, alphabet2) {
  let result = "";
  for (let i2 = 0; i2 < length; i2++) {
    result += alphabet2[generateRandomInteger(alphabet2.length)];
  }
  return result;
}
function alphabet(...patterns) {
  const patternSet = new Set(patterns);
  let result = "";
  for (const pattern of patternSet) {
    if (pattern === "a-z") {
      result += "abcdefghijklmnopqrstuvwxyz";
    } else if (pattern === "A-Z") {
      result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    } else if (pattern === "0-9") {
      result += "0123456789";
    } else {
      result += pattern;
    }
  }
  return result;
}
function generateId(length) {
  return generateRandomString(length, alphabet("0-9", "a-z"));
}
var TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER, JSONRPC2_TO_HTTP_CODE, noop2, createRecursiveProxy, createFlatProxy, UnknownCauseError, TRPCError, defaultTransformer, defaultFormatter, procedureTypes, emptyRouter, reservedWords, isServerDefault, deserializeInputValue, getJsonContentTypeInputs, HTTP_METHOD_PROCEDURE_TYPE_MAP, fallbackContentTypeHandler, trimSlashes, entityKind, _a, Column, SubqueryConfig, _a2, Subquery, _a3, WithSubquery, tracer, ViewBaseConfig, TableName, Schema, Columns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, _a4, Table, _a5, StringChunk, _a6, _SQL, SQL, _a7, Name, noopDecoder, noopEncoder, _a8, Param, _a9, Placeholder, _a10, View, _a11, ColumnAliasProxyHandler, _a12, TableAliasProxyHandler, _a13, ColumnBuilder, _a14, DrizzleError, _a15, TransactionRollbackError, eq, ne, gt, gte, lt, lte, _a16, ConsoleLogWriter, _a17, DefaultLogger, _a18, NoopLogger, _a19, QueryPromise, InlineForeignKeys$1, _a20, PgTable, _a21, PrimaryKeyBuilder, _a22, PrimaryKey, _a23, Relation, _a24, Relations, _a25, _One, One, _a26, _Many, Many, InlineForeignKeys, _a27, SQLiteTable, sqliteTable, _a28, ForeignKeyBuilder, _a29, ForeignKey, _a30, SQLiteColumnBuilder, _a31, SQLiteColumn, _a32, SQLiteCustomColumnBuilder, _a33, SQLiteCustomColumn, _a34, SQLiteBaseIntegerBuilder, _a35, SQLiteBaseInteger, _a36, SQLiteIntegerBuilder, _a37, SQLiteInteger, _a38, SQLiteTimestampBuilder, _a39, SQLiteTimestamp, _a40, SQLiteBooleanBuilder, _a41, SQLiteBoolean, _a42, SQLiteTextBuilder, _a43, SQLiteText, _a44, SQLiteTextJsonBuilder, _a45, SQLiteTextJson, _a46, _SelectionProxyHandler, SelectionProxyHandler, _a47, SQLiteDeleteBase, _a48, SQLiteInsertBuilder, _a49, SQLiteInsertBase, _a50, SQLiteViewBase, _a51, SQLiteDialect, _a52, SQLiteSyncDialect, _a53, SQLiteAsyncDialect, _a54, TypedQueryBuilder, _a55, SQLiteSelectBuilder, _a56, SQLiteSelectQueryBuilderBase, _a57, SQLiteSelectBase, getSQLiteSetOperators, union, unionAll, intersect, except, _a58, QueryBuilder, _a59, SQLiteUpdateBuilder, _a60, SQLiteUpdateBase, _a61, RelationalQueryBuilder, _a62, SQLiteRelationalQuery, _a63, SQLiteSyncRelationalQuery, _a64, SQLiteRaw, _a65, BaseSQLiteDatabase, _a66, IndexBuilderOn, _a67, IndexBuilder, _a68, Index, _a69, ExecuteResultSync, _a70, SQLitePreparedQuery, _a71, SQLiteSession, _a72, SQLiteTransaction, SERIALIZED_SQL_KEY, _a73, SQLiteRemoteSession, _a74, _SQLiteProxyTransaction, SQLiteProxyTransaction, _a75, RemotePreparedQuery, _a76, SqliteRemoteDatabase, util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType$1, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z, remoteResultSchema, dateType, jsonType, db, CVS, ATTACHMENTS, middlewareMarker, codeblock, TRPCBuilder, initTRPC, t$1, publicProcedure, statusSchema, inputItem$1, inputSchema$3, outputItem$1, outputSchema$3, changeStatusProcedure, define_globalThis_process_env_default, r2, E, s, t, p, l, I, T, R, C, v, a, _, W, c, w, A, L, D, O, S, N, u, b, F, P, mimeTypesInternal, mimeTypes, extensions, types, withExponentialBackoff, ERROR_CODES, UploadThingError, INTERNAL_DO_NOT_USE__fatalClientError, generateMimeTypes, generateClientDropzoneAccept, generatePermittedFileTypes, capitalizeStart, INTERNAL_doFormatting, allowedContentTextLabelGenerator, styleFieldToClassName, styleFieldToCssObject, contentFieldToContent, signaturePrefix, algorithm, signPayload, verifySignature, LogLevels, LogTypes, defu, paused, queue, Consola, UTFiles, VALID_ACTION_TYPES, version, colorize, icons, logger, initLogger, isValidResponse, conditionalDevServer, createUTFetch, fileCountBoundsCheck, buildRequestHandler, buildPermissionsInfoHandler, maybeParseResponseXML, DEFAULT_ERROR_CODE, s3CodeToUploadThingCode, uploadFilesInternal, UTFile, UTApi, createUploadthing, INTERNAL_DO_NOT_USE_createRouteHandlerCore, createRouteHandler, inputItem, inputSchema$2, outputItem, outputSchema$2, deleteCVProcedure, filterSchema, dateFilterSchema, sortSchema, inputSchema$1, cvSchema, outputSchema$1, getAllCVSProcedure, outputSchema, getStorageInUseProcedure, nameSchema, emailSchema, placeSchema, positionSchema, uploadedFileSchema, inputSchema, insertCVProdedure, appRouter, ALL, _trpc_;
var init_trpc_GIzfMcGy = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/pages/_trpc__GIzfMcGy.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_astro_BO0wYrHs();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    TRPC_ERROR_CODES_BY_KEY = {
      /**
      * Invalid JSON was received by the server.
      * An error occurred on the server while parsing the JSON text.
      */
      PARSE_ERROR: -32700,
      /**
      * The JSON sent is not a valid Request object.
      */
      BAD_REQUEST: -32600,
      // Internal JSON-RPC error
      INTERNAL_SERVER_ERROR: -32603,
      NOT_IMPLEMENTED: -32603,
      // Implementation specific errors
      UNAUTHORIZED: -32001,
      FORBIDDEN: -32003,
      NOT_FOUND: -32004,
      METHOD_NOT_SUPPORTED: -32005,
      TIMEOUT: -32008,
      CONFLICT: -32009,
      PRECONDITION_FAILED: -32012,
      PAYLOAD_TOO_LARGE: -32013,
      UNPROCESSABLE_CONTENT: -32022,
      TOO_MANY_REQUESTS: -32029,
      CLIENT_CLOSED_REQUEST: -32099
    };
    invert(TRPC_ERROR_CODES_BY_KEY);
    TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);
    JSONRPC2_TO_HTTP_CODE = {
      PARSE_ERROR: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      FORBIDDEN: 403,
      METHOD_NOT_SUPPORTED: 405,
      TIMEOUT: 408,
      CONFLICT: 409,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      UNPROCESSABLE_CONTENT: 422,
      TOO_MANY_REQUESTS: 429,
      CLIENT_CLOSED_REQUEST: 499,
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501
    };
    noop2 = () => {
    };
    createRecursiveProxy = (callback) => createInnerProxy(callback, []);
    createFlatProxy = (callback) => {
      return new Proxy(noop2, {
        get(_obj, name) {
          if (typeof name !== "string" || name === "then") {
            return void 0;
          }
          return callback(name);
        }
      });
    };
    UnknownCauseError = class extends Error {
    };
    TRPCError = class extends Error {
      constructor(opts2) {
        const cause = getCauseFromUnknown(opts2.cause);
        const message2 = opts2.message ?? cause?.message ?? opts2.code;
        super(message2, {
          cause
        });
        this.code = opts2.code;
        this.name = "TRPCError";
        if (!this.cause) {
          this.cause = cause;
        }
      }
    };
    defaultTransformer = {
      _default: true,
      input: {
        serialize: (obj) => obj,
        deserialize: (obj) => obj
      },
      output: {
        serialize: (obj) => obj,
        deserialize: (obj) => obj
      }
    };
    defaultFormatter = ({ shape }) => {
      return shape;
    };
    procedureTypes = [
      "query",
      "mutation",
      "subscription"
    ];
    emptyRouter = {
      _ctx: null,
      _errorShape: null,
      _meta: null,
      queries: {},
      mutations: {},
      subscriptions: {},
      errorFormatter: defaultFormatter,
      transformer: defaultTransformer
    };
    reservedWords = [
      /**
      * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
      * since JS will think that `.then` is something that exists
      */
      "then"
    ];
    isServerDefault = typeof window === "undefined" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
    deserializeInputValue = (rawValue, transformer) => {
      return typeof rawValue !== "undefined" ? transformer.input.deserialize(rawValue) : rawValue;
    };
    getJsonContentTypeInputs = (opts2) => {
      const rawInput = getRawProcedureInputOrThrow(opts2);
      const transformer = opts2.router._def._config.transformer;
      if (!opts2.isBatchCall) {
        return {
          0: deserializeInputValue(rawInput, transformer)
        };
      }
      if (rawInput == null || typeof rawInput !== "object" || Array.isArray(rawInput)) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: '"input" needs to be an object when doing a batch call'
        });
      }
      const input = {};
      for (const key in rawInput) {
        const k4 = key;
        const rawValue = rawInput[k4];
        const value = deserializeInputValue(rawValue, transformer);
        input[k4] = value;
      }
      return input;
    };
    HTTP_METHOD_PROCEDURE_TYPE_MAP = {
      GET: "query",
      POST: "mutation"
    };
    fallbackContentTypeHandler = {
      getInputs: getJsonContentTypeInputs
    };
    trimSlashes = (path) => {
      path = path.startsWith("/") ? path.slice(1) : path;
      path = path.endsWith("/") ? path.slice(0, -1) : path;
      return path;
    };
    entityKind = Symbol.for("drizzle:entityKind");
    Column = class {
      constructor(table, config) {
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
      }
      name;
      primary;
      notNull;
      default;
      defaultFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
    };
    _a = entityKind;
    __publicField(Column, _a, "Column");
    SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");
    Subquery = class {
      /** @internal */
      [(_a2 = entityKind, SubqueryConfig)];
      constructor(sql2, selection, alias, isWith = false) {
        this[SubqueryConfig] = {
          sql: sql2,
          selection,
          alias,
          isWith
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    };
    __publicField(Subquery, _a2, "Subquery");
    WithSubquery = class extends Subquery {
    };
    _a3 = entityKind;
    __publicField(WithSubquery, _a3, "WithSubquery");
    tracer = {
      startActiveSpan(name, fn2) {
        {
          return fn2();
        }
      }
    };
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
    TableName = Symbol.for("drizzle:Name");
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [(_a4 = entityKind, TableName)];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      [IsDrizzleTable] = true;
      constructor(name, schema, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
      }
    };
    __publicField(Table, _a4, "Table");
    /** @internal */
    __publicField(Table, "Symbol", {
      Name: TableName,
      Schema,
      OriginalName,
      Columns,
      BaseName,
      IsAlias,
      ExtraConfigBuilder
    });
    StringChunk = class {
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a5 = entityKind;
    __publicField(StringChunk, _a5, "StringChunk");
    _SQL = class {
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
      }
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i2, p4] of chunk.entries()) {
              result.push(p4);
              if (i2 < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config), params: [] };
            }
            let typings;
            if (prepareTyping !== void 0) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk[SubqueryConfig].isWith) {
              return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk[SubqueryConfig].sql,
              new StringChunk(") "),
              new Name(chunk[SubqueryConfig].alias)
            ], config);
          }
          if (isSQLWrapper(chunk)) {
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
        }));
      }
      mapInlineParam(chunk, { escapeString: escapeString2 }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString2(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString2(JSON.stringify(chunk));
          }
          return escapeString2(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder3) {
        this.decoder = typeof decoder3 === "function" ? { mapFromDriverValue: decoder3 } : decoder3;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
    };
    SQL = _SQL;
    _a6 = entityKind;
    __publicField(SQL, _a6, "SQL");
    Name = class {
      constructor(value) {
        this.value = value;
      }
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    _a7 = entityKind;
    __publicField(Name, _a7, "Name");
    noopDecoder = {
      mapFromDriverValue: (value) => value
    };
    noopEncoder = {
      mapToDriverValue: (value) => value
    };
    ({
      ...noopDecoder,
      ...noopEncoder
    });
    Param = class {
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder2 = noopEncoder) {
        this.value = value;
        this.encoder = encoder2;
      }
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    _a8 = entityKind;
    __publicField(Param, _a8, "Param");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      sql2.empty = empty;
      function fromList2(list) {
        return new SQL(list);
      }
      sql2.fromList = fromList2;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      sql2.raw = raw;
      function join(chunks, separator) {
        const result = [];
        for (const [i2, chunk] of chunks.entries()) {
          if (i2 > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      sql2.identifier = identifier;
      function placeholder2(name2) {
        return new Placeholder(name2);
      }
      sql2.placeholder = placeholder2;
      function param2(value, encoder2) {
        return new Param(value, encoder2);
      }
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      constructor(name2) {
        this.name = name2;
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    _a9 = entityKind;
    __publicField(Placeholder, _a9, "Placeholder");
    View = class {
      /** @internal */
      [(_a10 = entityKind, ViewBaseConfig)];
      constructor({ name: name2, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name2,
          originalName: name2,
          schema,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    __publicField(View, _a10, "View");
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
    ColumnAliasProxyHandler = class {
      constructor(table) {
        this.table = table;
      }
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    _a11 = entityKind;
    __publicField(ColumnAliasProxyHandler, _a11, "ColumnAliasProxyHandler");
    TableAliasProxyHandler = class {
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key) => {
            proxiedColumns[key] = new Proxy(
              columns[key],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    _a12 = entityKind;
    __publicField(TableAliasProxyHandler, _a12, "TableAliasProxyHandler");
    ColumnBuilder = class {
      config;
      constructor(name, dataType, columnType) {
        this.config = {
          name,
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn2) {
        this.config.defaultFn = fn2;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
    };
    _a13 = entityKind;
    __publicField(ColumnBuilder, _a13, "ColumnBuilder");
    DrizzleError = class extends Error {
      constructor({ message: message2, cause }) {
        super(message2);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    };
    _a14 = entityKind;
    __publicField(DrizzleError, _a14, "DrizzleError");
    TransactionRollbackError = class extends DrizzleError {
      constructor() {
        super({ message: "Rollback" });
      }
    };
    _a15 = entityKind;
    __publicField(TransactionRollbackError, _a15, "TransactionRollbackError");
    eq = (left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    };
    ne = (left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    };
    gt = (left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    };
    gte = (left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    };
    lt = (left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    };
    lte = (left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    };
    ConsoleLogWriter = class {
      write(message2) {
        console.log(message2);
      }
    };
    _a16 = entityKind;
    __publicField(ConsoleLogWriter, _a16, "ConsoleLogWriter");
    DefaultLogger = class {
      writer;
      constructor(config) {
        this.writer = config?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p4) => {
          try {
            return JSON.stringify(p4);
          } catch {
            return String(p4);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    _a17 = entityKind;
    __publicField(DefaultLogger, _a17, "DefaultLogger");
    NoopLogger = class {
      logQuery() {
      }
    };
    _a18 = entityKind;
    __publicField(NoopLogger, _a18, "NoopLogger");
    QueryPromise = class {
      [(_a19 = entityKind, Symbol.toStringTag)] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
    __publicField(QueryPromise, _a19, "QueryPromise");
    InlineForeignKeys$1 = Symbol.for("drizzle:PgInlineForeignKeys");
    PgTable = class extends Table {
      /**@internal */
      [(_a20 = entityKind, InlineForeignKeys$1)] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __publicField(PgTable, _a20, "PgTable");
    /** @internal */
    __publicField(PgTable, "Symbol", Object.assign({}, Table.Symbol, {
      InlineForeignKeys: InlineForeignKeys$1
    }));
    PrimaryKeyBuilder = class {
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey(table, this.columns, this.name);
      }
    };
    _a21 = entityKind;
    __publicField(PrimaryKeyBuilder, _a21, "PgPrimaryKeyBuilder");
    PrimaryKey = class {
      constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name;
      }
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
    _a22 = entityKind;
    __publicField(PrimaryKey, _a22, "PgPrimaryKey");
    Relation = class {
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      referencedTableName;
      fieldName;
    };
    _a23 = entityKind;
    __publicField(Relation, _a23, "Relation");
    Relations = class {
      constructor(table, config) {
        this.table = table;
        this.config = config;
      }
    };
    _a24 = entityKind;
    __publicField(Relations, _a24, "Relations");
    _One = class extends Relation {
      constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
      }
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    One = _One;
    _a25 = entityKind;
    __publicField(One, _a25, "One");
    _Many = class extends Relation {
      constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
      }
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    Many = _Many;
    _a26 = entityKind;
    __publicField(Many, _a26, "Many");
    InlineForeignKeys = Symbol.for("drizzle:SQLiteInlineForeignKeys");
    SQLiteTable = class extends Table {
      /** @internal */
      [(_a27 = entityKind, Table.Symbol.Columns)];
      /** @internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __publicField(SQLiteTable, _a27, "SQLiteTable");
    /** @internal */
    __publicField(SQLiteTable, "Symbol", Object.assign({}, Table.Symbol, {
      InlineForeignKeys
    }));
    sqliteTable = (name, columns, extraConfig) => {
      return sqliteTableBase(name, columns, extraConfig);
    };
    ForeignKeyBuilder = class {
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey(table, this);
      }
    };
    _a28 = entityKind;
    __publicField(ForeignKeyBuilder, _a28, "SQLiteForeignKeyBuilder");
    ForeignKey = class {
      constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[SQLiteTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[SQLiteTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
    _a29 = entityKind;
    __publicField(ForeignKey, _a29, "SQLiteForeignKey");
    SQLiteColumnBuilder = class extends ColumnBuilder {
      foreignKeyConfigs = [];
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return ((ref2, actions2) => {
            const builder = new ForeignKeyBuilder(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions2.onUpdate) {
              builder.onUpdate(actions2.onUpdate);
            }
            if (actions2.onDelete) {
              builder.onDelete(actions2.onDelete);
            }
            return builder.build(table);
          })(ref, actions);
        });
      }
    };
    _a30 = entityKind;
    __publicField(SQLiteColumnBuilder, _a30, "SQLiteColumnBuilder");
    SQLiteColumn = class extends Column {
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
      }
    };
    _a31 = entityKind;
    __publicField(SQLiteColumn, _a31, "SQLiteColumn");
    SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "SQLiteCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table) {
        return new SQLiteCustomColumn(
          table,
          this.config
        );
      }
    };
    _a32 = entityKind;
    __publicField(SQLiteCustomColumnBuilder, _a32, "SQLiteCustomColumnBuilder");
    SQLiteCustomColumn = class extends SQLiteColumn {
      sqlName;
      mapTo;
      mapFrom;
      constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
    _a33 = entityKind;
    __publicField(SQLiteCustomColumn, _a33, "SQLiteCustomColumn");
    SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
      constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
      }
      primaryKey(config) {
        if (config?.autoIncrement) {
          this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
      }
    };
    _a34 = entityKind;
    __publicField(SQLiteBaseIntegerBuilder, _a34, "SQLiteBaseIntegerBuilder");
    SQLiteBaseInteger = class extends SQLiteColumn {
      autoIncrement = this.config.autoIncrement;
      getSQLType() {
        return "integer";
      }
    };
    _a35 = entityKind;
    __publicField(SQLiteBaseInteger, _a35, "SQLiteBaseInteger");
    SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
      constructor(name) {
        super(name, "number", "SQLiteInteger");
      }
      build(table) {
        return new SQLiteInteger(
          table,
          this.config
        );
      }
    };
    _a36 = entityKind;
    __publicField(SQLiteIntegerBuilder, _a36, "SQLiteIntegerBuilder");
    SQLiteInteger = class extends SQLiteBaseInteger {
    };
    _a37 = entityKind;
    __publicField(SQLiteInteger, _a37, "SQLiteInteger");
    SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
      constructor(name, mode) {
        super(name, "date", "SQLiteTimestamp");
        this.config.mode = mode;
      }
      /**
       * @deprecated Use `default()` with your own expression instead.
       *
       * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
       */
      defaultNow() {
        return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
      }
      build(table) {
        return new SQLiteTimestamp(
          table,
          this.config
        );
      }
    };
    _a38 = entityKind;
    __publicField(SQLiteTimestampBuilder, _a38, "SQLiteTimestampBuilder");
    SQLiteTimestamp = class extends SQLiteBaseInteger {
      mode = this.config.mode;
      mapFromDriverValue(value) {
        if (this.config.mode === "timestamp") {
          return new Date(value * 1e3);
        }
        return new Date(value);
      }
      mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === "timestamp") {
          return Math.floor(unix / 1e3);
        }
        return unix;
      }
    };
    _a39 = entityKind;
    __publicField(SQLiteTimestamp, _a39, "SQLiteTimestamp");
    SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
      constructor(name, mode) {
        super(name, "boolean", "SQLiteBoolean");
        this.config.mode = mode;
      }
      build(table) {
        return new SQLiteBoolean(
          table,
          this.config
        );
      }
    };
    _a40 = entityKind;
    __publicField(SQLiteBooleanBuilder, _a40, "SQLiteBooleanBuilder");
    SQLiteBoolean = class extends SQLiteBaseInteger {
      mode = this.config.mode;
      mapFromDriverValue(value) {
        return Number(value) === 1;
      }
      mapToDriverValue(value) {
        return value ? 1 : 0;
      }
    };
    _a41 = entityKind;
    __publicField(SQLiteBoolean, _a41, "SQLiteBoolean");
    SQLiteTextBuilder = class extends SQLiteColumnBuilder {
      constructor(name, config) {
        super(name, "string", "SQLiteText");
        this.config.enumValues = config.enum;
        this.config.length = config.length;
      }
      /** @internal */
      build(table) {
        return new SQLiteText(table, this.config);
      }
    };
    _a42 = entityKind;
    __publicField(SQLiteTextBuilder, _a42, "SQLiteTextBuilder");
    SQLiteText = class extends SQLiteColumn {
      enumValues = this.config.enumValues;
      length = this.config.length;
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ""}`;
      }
    };
    _a43 = entityKind;
    __publicField(SQLiteText, _a43, "SQLiteText");
    SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
      constructor(name) {
        super(name, "json", "SQLiteTextJson");
      }
      /** @internal */
      build(table) {
        return new SQLiteTextJson(
          table,
          this.config
        );
      }
    };
    _a44 = entityKind;
    __publicField(SQLiteTextJsonBuilder, _a44, "SQLiteTextJsonBuilder");
    SQLiteTextJson = class extends SQLiteColumn {
      getSQLType() {
        return "text";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value);
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
    _a45 = entityKind;
    __publicField(SQLiteTextJson, _a45, "SQLiteTextJson");
    _SelectionProxyHandler = class {
      config;
      constructor(config) {
        this.config = { ...config };
      }
      get(subquery, prop) {
        if (prop === SubqueryConfig) {
          return {
            ...subquery[SubqueryConfig],
            selection: new Proxy(
              subquery[SubqueryConfig].selection,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
    SelectionProxyHandler = _SelectionProxyHandler;
    _a46 = entityKind;
    __publicField(SelectionProxyHandler, _a46, "SelectionProxyHandler");
    SQLiteDeleteBase = class extends QueryPromise {
      constructor(table, session, dialect, withList) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.config = { table, withList };
      }
      /** @internal */
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run"
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute(placeholderValues) {
        return this._prepare().execute(placeholderValues);
      }
      $dynamic() {
        return this;
      }
    };
    _a47 = entityKind;
    __publicField(SQLiteDeleteBase, _a47, "SQLiteDelete");
    SQLiteInsertBuilder = class {
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
    };
    _a48 = entityKind;
    __publicField(SQLiteInsertBuilder, _a48, "SQLiteInsertBuilder");
    SQLiteInsertBase = class extends QueryPromise {
      constructor(table, values, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table, values, withList };
      }
      /** @internal */
      config;
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config = {}) {
        if (config.target === void 0) {
          this.config.onConflict = sql`do nothing`;
        } else {
          const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
          const whereSql = config.where ? sql` where ${config.where}` : sql``;
          this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config) {
        const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
        const whereSql = config.where ? sql` where ${config.where}` : sql``;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = sql`${targetSql} do update set ${setSql}${whereSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run"
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
    _a49 = entityKind;
    __publicField(SQLiteInsertBase, _a49, "SQLiteInsert");
    SQLiteViewBase = class extends View {
    };
    _a50 = entityKind;
    __publicField(SQLiteViewBase, _a50, "SQLiteViewBase");
    SQLiteDialect = class {
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(_num) {
        return "?";
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i2, w5] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w5[SubqueryConfig].alias)} as (${w5[SubqueryConfig].sql})`);
          if (i2 < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table, set2) {
        const setEntries = Object.entries(set2);
        const setSize = setEntries.length;
        return sql.join(
          setEntries.flatMap(([colName, value], i2) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql`${sql.identifier(col.name)} = ${value}`;
            if (i2 < setSize - 1) {
              return [res, sql.raw(", ")];
            }
            return [res];
          })
        );
      }
      buildUpdateQuery({ table, set: set2, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table, set2);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i2) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, Column)) {
                      return sql.identifier(c2.name);
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            const tableName = field.table[Table.Symbol.Name];
            const columnName = field.name;
            if (isSingleTable) {
              chunk.push(sql.identifier(columnName));
            } else {
              chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(columnName)}`);
            }
          }
          if (i2 < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table,
        joins,
        orderBy,
        groupBy,
        limit,
        offset: offset2,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f3 of fieldsList) {
          if (is(f3.field, Column) && getTableName(f3.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
            ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
          ))(f3.field.table)) {
            const tableName = getTableName(f3.field.table);
            throw new Error(
              `Your "${f3.path.join("->")}" field references a column "${tableName}"."${f3.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
            return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
          }
          return table;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index3, joinMeta] of joins.entries()) {
            if (index3 === 0) {
              joinsArray.push(sql` `);
            }
            const table2 = joinMeta.table;
            if (is(table2, SQLiteTable)) {
              const tableName = table2[SQLiteTable.Symbol.Name];
              const tableSchema = table2[SQLiteTable.Symbol.Schema];
              const origTableName = table2[SQLiteTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${table2} on ${joinMeta.on}`
              );
            }
            if (index3 < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        const orderByList = [];
        if (orderBy) {
          for (const [index3, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index3 < orderBy.length - 1) {
              orderByList.push(sql`, `);
            }
          }
        }
        const groupByList = [];
        if (groupBy) {
          for (const [index3, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index3 < groupBy.length - 1) {
              groupByList.push(sql`, `);
            }
          }
        }
        const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
        const orderBySql = orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
        const limitSql = limit ? sql` limit ${limit}` : void 0;
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset: offset2 }
      }) {
        const leftChunk = sql`${leftSelect.getSQL()} `;
        const rightChunk = sql`${rightSelect.getSQL()}`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, SQLiteColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
                const chunk = singleOrderBy.queryChunks[i2];
                if (is(chunk, SQLiteColumn)) {
                  singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
        }
        const limitSql = limit ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset2 ? sql` offset ${offset2}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table, values, onConflict, returning, withList }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              let defaultValue;
              if (col.default !== null && col.default !== void 0) {
                defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
              } else if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              } else {
                defaultValue = sql`null`;
              }
              valueList.push(defaultValue);
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        return sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
      }
      sqlToQuery(sql2) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema,
        tableNamesMap,
        table,
        tableConfig,
        queryConfig: config,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset2, orderBy = [], where;
        const joins = [];
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset2 = config.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = relation.referencedTable[Table.Symbol.Name];
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i2) => eq(
                  aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_group_array(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset2 !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                }
              ],
              where,
              limit,
              offset: offset2,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset2 = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset: offset2,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    _a51 = entityKind;
    __publicField(SQLiteDialect, _a51, "SQLiteDialect");
    SQLiteSyncDialect = class extends SQLiteDialect {
      migrate(migrations, session, config) {
        const migrationsTable = config === void 0 ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        session.run(sql`BEGIN`);
        try {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                session.run(sql.raw(stmt));
              }
              session.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
          session.run(sql`COMMIT`);
        } catch (e2) {
          session.run(sql`ROLLBACK`);
          throw e2;
        }
      }
    };
    _a52 = entityKind;
    __publicField(SQLiteSyncDialect, _a52, "SQLiteSyncDialect");
    SQLiteAsyncDialect = class extends SQLiteDialect {
      async migrate(migrations, session, config) {
        const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.run(sql.raw(stmt));
              }
              await tx.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
    };
    _a53 = entityKind;
    __publicField(SQLiteAsyncDialect, _a53, "SQLiteAsyncDialect");
    TypedQueryBuilder = class {
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
    _a54 = entityKind;
    __publicField(TypedQueryBuilder, _a54, "TypedQueryBuilder");
    SQLiteSelectBuilder = class {
      fields;
      session;
      dialect;
      withList;
      distinct;
      constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
      }
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]])
          );
        } else if (is(source, SQLiteViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new SQLiteSelectBase({
          table: source,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    _a55 = entityKind;
    __publicField(SQLiteSelectBuilder, _a55, "SQLiteSelectBuilder");
    SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
      _;
      /** @internal */
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table, on2) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table, SQL)) {
              const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on2 === "function") {
            on2 = on2(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on2, table, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/sqlite-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/sqlite-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/sqlite-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/sqlite-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset2) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset2;
        } else {
          this.config.offset = offset2;
        }
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    _a56 = entityKind;
    __publicField(SQLiteSelectQueryBuilderBase, _a56, "SQLiteSelectQueryBuilder");
    SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          fieldsList,
          "all"
        );
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.all();
      }
    };
    _a57 = entityKind;
    __publicField(SQLiteSelectBase, _a57, "SQLiteSelect");
    applyMixins(SQLiteSelectBase, [QueryPromise]);
    getSQLiteSetOperators = () => ({
      union,
      unionAll,
      intersect,
      except
    });
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    except = createSetOperator("except", false);
    QueryBuilder = class {
      dialect;
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb3) {
            if (typeof qb3 === "function") {
              qb3 = qb3(queryBuilder);
            }
            return new Proxy(
              new WithSubquery(qb3.getSQL(), qb3.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        return { select, selectDistinct };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new SQLiteSyncDialect();
        }
        return this.dialect;
      }
    };
    _a58 = entityKind;
    __publicField(QueryBuilder, _a58, "SQLiteQueryBuilder");
    SQLiteUpdateBuilder = class {
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      set(values) {
        return new SQLiteUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    };
    _a59 = entityKind;
    __publicField(SQLiteUpdateBuilder, _a59, "SQLiteUpdateBuilder");
    SQLiteUpdateBase = class extends QueryPromise {
      constructor(table, set2, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set: set2, table, withList };
      }
      /** @internal */
      config;
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run"
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = (placeholderValues) => {
        return this._prepare().run(placeholderValues);
      };
      all = (placeholderValues) => {
        return this._prepare().all(placeholderValues);
      };
      get = (placeholderValues) => {
        return this._prepare().get(placeholderValues);
      };
      values = (placeholderValues) => {
        return this._prepare().values(placeholderValues);
      };
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
    _a60 = entityKind;
    __publicField(SQLiteUpdateBase, _a60, "SQLiteUpdate");
    RelationalQueryBuilder = class {
      constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      findMany(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        );
      }
      findFirst(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    _a61 = entityKind;
    __publicField(RelationalQueryBuilder, _a61, "SQLiteAsyncRelationalQueryBuilder");
    SQLiteRelationalQuery = class extends QueryPromise {
      constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
      }
      /** @internal */
      mode;
      /** @internal */
      getSQL() {
        return this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }).sql;
      }
      /** @internal */
      _prepare(isOneTimeQuery = false) {
        const { query, builtQuery } = this._toSQL();
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          builtQuery,
          void 0,
          this.mode === "first" ? "get" : "all",
          (rawRows, mapColumnValue) => {
            const rows = rawRows.map(
              (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
            );
            if (this.mode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      _toSQL() {
        const query = this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      /** @internal */
      executeRaw() {
        if (this.mode === "first") {
          return this._prepare(false).get();
        }
        return this._prepare(false).all();
      }
      async execute() {
        return this.executeRaw();
      }
    };
    _a62 = entityKind;
    __publicField(SQLiteRelationalQuery, _a62, "SQLiteAsyncRelationalQuery");
    SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
      sync() {
        return this.executeRaw();
      }
    };
    _a63 = entityKind;
    __publicField(SQLiteSyncRelationalQuery, _a63, "SQLiteSyncRelationalQuery");
    SQLiteRaw = class extends QueryPromise {
      constructor(execute, getSQL, action, dialect, mapBatchResult) {
        super();
        this.execute = execute;
        this.getSQL = getSQL;
        this.dialect = dialect;
        this.mapBatchResult = mapBatchResult;
        this.config = { action };
      }
      /** @internal */
      config;
      getQuery() {
        return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
    };
    _a64 = entityKind;
    __publicField(SQLiteRaw, _a64, "SQLiteRaw");
    BaseSQLiteDatabase = class {
      constructor(resultKind, dialect, session, schema) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
        this.query = {};
        const query = this.query;
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            query[tableName] = new RelationalQueryBuilder(
              resultKind,
              schema.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with(alias) {
        return {
          as(qb3) {
            if (typeof qb3 === "function") {
              qb3 = qb3(new QueryBuilder());
            }
            return new Proxy(
              new WithSubquery(qb3.getSQL(), qb3.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        function update(table) {
          return new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);
        }
        function insert(into) {
          return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
        }
        function delete_(from) {
          return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
        }
        return { select, selectDistinct, update, insert, delete: delete_ };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(from) {
        return new SQLiteDeleteBase(from, this.session, this.dialect);
      }
      run(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.run(sql2),
            () => sql2,
            "run",
            this.dialect,
            this.session.extractRawRunValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.run(sql2);
      }
      all(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.all(sql2),
            () => sql2,
            "all",
            this.dialect,
            this.session.extractRawAllValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.all(sql2);
      }
      get(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.get(sql2),
            () => sql2,
            "get",
            this.dialect,
            this.session.extractRawGetValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.get(sql2);
      }
      values(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.values(sql2),
            () => sql2,
            "values",
            this.dialect,
            this.session.extractRawValuesValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.values(sql2);
      }
      transaction(transaction, config) {
        return this.session.transaction(transaction, config);
      }
    };
    _a65 = entityKind;
    __publicField(BaseSQLiteDatabase, _a65, "BaseSQLiteDatabase");
    IndexBuilderOn = class {
      constructor(name, unique2) {
        this.name = name;
        this.unique = unique2;
      }
      on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
      }
    };
    _a66 = entityKind;
    __publicField(IndexBuilderOn, _a66, "SQLiteIndexBuilderOn");
    IndexBuilder = class {
      /** @internal */
      config;
      constructor(name, columns, unique2) {
        this.config = {
          name,
          columns,
          unique: unique2,
          where: void 0
        };
      }
      /**
       * Condition for partial index.
       */
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table) {
        return new Index(this.config, table);
      }
    };
    _a67 = entityKind;
    __publicField(IndexBuilder, _a67, "SQLiteIndexBuilder");
    Index = class {
      config;
      constructor(config, table) {
        this.config = { ...config, table };
      }
    };
    _a68 = entityKind;
    __publicField(Index, _a68, "SQLiteIndex");
    ExecuteResultSync = class extends QueryPromise {
      constructor(resultCb) {
        super();
        this.resultCb = resultCb;
      }
      async execute() {
        return this.resultCb();
      }
      sync() {
        return this.resultCb();
      }
    };
    _a69 = entityKind;
    __publicField(ExecuteResultSync, _a69, "ExecuteResultSync");
    SQLitePreparedQuery = class {
      constructor(mode, executeMethod, query) {
        this.mode = mode;
        this.executeMethod = executeMethod;
        this.query = query;
      }
      /** @internal */
      joinsNotNullableMap;
      getQuery() {
        return this.query;
      }
      mapRunResult(result, _isFromBatch) {
        return result;
      }
      mapAllResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      mapGetResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      execute(placeholderValues) {
        if (this.mode === "async") {
          return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
      }
      mapResult(response, isFromBatch) {
        switch (this.executeMethod) {
          case "run": {
            return this.mapRunResult(response, isFromBatch);
          }
          case "all": {
            return this.mapAllResult(response, isFromBatch);
          }
          case "get": {
            return this.mapGetResult(response, isFromBatch);
          }
        }
      }
    };
    _a70 = entityKind;
    __publicField(SQLitePreparedQuery, _a70, "PreparedQuery");
    SQLiteSession = class {
      constructor(dialect) {
        this.dialect = dialect;
      }
      prepareOneTimeQuery(query, fields, executeMethod) {
        return this.prepareQuery(query, fields, executeMethod);
      }
      run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
          return this.prepareOneTimeQuery(staticQuery, void 0, "run").run();
        } catch (err) {
          throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
        }
      }
      /** @internal */
      extractRawRunValueFromBatchResult(result) {
        return result;
      }
      all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").all();
      }
      /** @internal */
      extractRawAllValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").get();
      }
      /** @internal */
      extractRawGetValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").values();
      }
      /** @internal */
      extractRawValuesValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
    };
    _a71 = entityKind;
    __publicField(SQLiteSession, _a71, "SQLiteSession");
    SQLiteTransaction = class extends BaseSQLiteDatabase {
      constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
      }
      rollback() {
        throw new TransactionRollbackError();
      }
    };
    _a72 = entityKind;
    __publicField(SQLiteTransaction, _a72, "SQLiteTransaction");
    SERIALIZED_SQL_KEY = "__serializedSQL";
    if (typeof queueMicrotask !== "undefined")
      ;
    else {
      Promise.resolve();
    }
    SQLiteRemoteSession = class extends SQLiteSession {
      constructor(client, dialect, schema, batchCLient, options = {}) {
        super(dialect);
        this.client = client;
        this.schema = schema;
        this.batchCLient = batchCLient;
        this.logger = options.logger ?? new NoopLogger();
      }
      logger;
      prepareQuery(query, fields, executeMethod, customResultMapper) {
        return new RemotePreparedQuery(this.client, query, this.logger, fields, executeMethod, customResultMapper);
      }
      async batch(queries) {
        const preparedQueries = [];
        const builtQueries = [];
        for (const query of queries) {
          const preparedQuery = query._prepare();
          const builtQuery = preparedQuery.getQuery();
          preparedQueries.push(preparedQuery);
          builtQueries.push({ sql: builtQuery.sql, params: builtQuery.params, method: builtQuery.method });
        }
        const batchResults = await this.batchCLient(builtQueries);
        return batchResults.map((result, i2) => preparedQueries[i2].mapResult(result, true));
      }
      async transaction(transaction, config) {
        const tx = new SQLiteProxyTransaction("async", this.dialect, this, this.schema);
        await this.run(sql.raw(`begin${config?.behavior ? " " + config.behavior : ""}`));
        try {
          const result = await transaction(tx);
          await this.run(sql`commit`);
          return result;
        } catch (err) {
          await this.run(sql`rollback`);
          throw err;
        }
      }
      extractRawAllValueFromBatchResult(result) {
        return result.rows;
      }
      extractRawGetValueFromBatchResult(result) {
        return result.rows[0];
      }
      extractRawValuesValueFromBatchResult(result) {
        return result.rows;
      }
    };
    _a73 = entityKind;
    __publicField(SQLiteRemoteSession, _a73, "SQLiteRemoteSession");
    _SQLiteProxyTransaction = class extends SQLiteTransaction {
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex}`;
        const tx = new _SQLiteProxyTransaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await this.session.run(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await this.session.run(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    };
    SQLiteProxyTransaction = _SQLiteProxyTransaction;
    _a74 = entityKind;
    __publicField(SQLiteProxyTransaction, _a74, "SQLiteProxyTransaction");
    RemotePreparedQuery = class extends SQLitePreparedQuery {
      constructor(client, query, logger2, fields, executeMethod, customResultMapper) {
        super("async", executeMethod, query);
        this.client = client;
        this.logger = logger2;
        this.fields = fields;
        this.customResultMapper = customResultMapper;
        this.customResultMapper = customResultMapper;
        this.method = executeMethod;
      }
      method;
      getQuery() {
        return { ...this.query, method: this.method };
      }
      run(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.client(this.query.sql, params, "run").then((t5) => t5.rows);
      }
      mapAllResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = rows.rows;
        }
        if (!this.fields && !this.customResultMapper) {
          return rows;
        }
        if (this.customResultMapper) {
          return this.customResultMapper(rows);
        }
        return rows.map((row) => {
          return mapResultRow(
            this.fields,
            row,
            this.joinsNotNullableMap
          );
        });
      }
      async all(placeholderValues) {
        const { query, logger: logger2, client } = this;
        const params = fillPlaceholders(query.params, placeholderValues ?? {});
        logger2.logQuery(query.sql, params);
        const { rows } = await client(query.sql, params, "all");
        return this.mapAllResult(rows);
      }
      async get(placeholderValues) {
        const { query, logger: logger2, client } = this;
        const params = fillPlaceholders(query.params, placeholderValues ?? {});
        logger2.logQuery(query.sql, params);
        const clientResult = await client(query.sql, params, "get");
        return this.mapGetResult(clientResult.rows);
      }
      mapGetResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = rows.rows;
        }
        const row = rows;
        if (!this.fields && !this.customResultMapper) {
          return row;
        }
        if (!row) {
          return void 0;
        }
        if (this.customResultMapper) {
          return this.customResultMapper([rows]);
        }
        return mapResultRow(
          this.fields,
          row,
          this.joinsNotNullableMap
        );
      }
      async values(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        const clientResult = await this.client(this.query.sql, params, "values");
        return clientResult.rows;
      }
    };
    _a75 = entityKind;
    __publicField(RemotePreparedQuery, _a75, "SQLiteProxyPreparedQuery");
    SqliteRemoteDatabase = class extends BaseSQLiteDatabase {
      async batch(batch) {
        return this.session.batch(batch);
      }
    };
    _a76 = entityKind;
    __publicField(SqliteRemoteDatabase, _a76, "SqliteRemoteDatabase");
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k4) => typeof obj[obj[k4]] !== "number");
        const filtered = {};
        for (const k4 of validKeys) {
          filtered[k4] = obj[k4];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e2) {
          return obj[e2];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
        const keys = [];
        for (const key in object2) {
          if (Object.prototype.hasOwnProperty.call(object2, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_3, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t5 = typeof data;
      switch (t5) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error2) => {
          for (const issue of error2.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el2 = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el2] = curr[el2] || { _errors: [] };
                } else {
                  curr[el2] = curr[el2] || { _errors: [] };
                  curr[el2]._errors.push(mapper(issue));
                }
                curr = curr[el2];
                i2++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error2 = new ZodError(issues);
      return error2;
    };
    errorMap = (issue, _ctx) => {
      let message2;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message2 = "Required";
          } else {
            message2 = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message2 = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message2 = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message2 = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message2 = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message2 = `Invalid ${issue.validation}`;
          } else {
            message2 = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message2 = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message2 = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message2 = "Number must be finite";
          break;
        default:
          message2 = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message: message2 };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s3 of results) {
          if (s3.status === "aborted")
            return INVALID;
          if (s3.status === "dirty")
            status.dirty();
          arrayValue.push(s3.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x4) => x4.status === "aborted";
    isDirty = (x4) => x4.status === "dirty";
    isValid = (x4) => x4.status === "valid";
    isAsync = (x4) => typeof Promise !== "undefined" && x4 instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
      errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error2 = new ZodError(ctx.common.issues);
            this._error = error2;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a78;
        const ctx = {
          common: {
            issues: [],
            async: (_a78 = params === null || params === void 0 ? void 0 : params.async) !== null && _a78 !== void 0 ? _a78 : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message2) {
        const getIssueProperties = (val) => {
          if (typeof message2 === "string" || typeof message2 === "undefined") {
            return { message: message2 };
          } else if (typeof message2 === "function") {
            return message2(val);
          } else {
            return message2;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[a-z][a-z0-9]*$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    ZodString = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx2,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a78) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message2) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message2)
        });
      }
      _addCheck(check2) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message2) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
      }
      url(message2) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
      }
      emoji(message2) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
      }
      uuid(message2) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
      }
      cuid(message2) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
      }
      cuid2(message2) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
      }
      ulid(message2) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a78;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a78 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a78 !== void 0 ? _a78 : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message2) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message2)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message2) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      endsWith(value, message2) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      min(minLength, message2) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message2)
        });
      }
      max(maxLength, message2) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message2)
        });
      }
      length(len, message2) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message2)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message2) {
        return this.min(1, errorUtil.errToObj(message2));
      }
      trim() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch2) => ch2.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch2) => ch2.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch2) => ch2.kind === "ip");
      }
      get minLength() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
    };
    ZodString.create = (params) => {
      var _a78;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a78 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a78 !== void 0 ? _a78 : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message2) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message2)
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      finite(message2) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message2)
        });
      }
      safe(message2) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
            return true;
          } else if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          } else if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
    };
    ZodBigInt.create = (params) => {
      var _a78;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a78 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a78 !== void 0 ? _a78 : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message2) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      max(maxDate, message2) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message2) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message2) }
        });
      }
      max(maxLength, message2) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message2) }
        });
      }
      length(len, message2) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message2) }
        });
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message2) {
        errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message2 !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a78, _b, _c, _d;
              const defaultError = (_c = (_b = (_a78 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a78, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index3) {
        return new ZodObject({
          ...this._def,
          catchall: index3
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types3, params) => {
      return new ZodUnion({
        options: types3,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    ZodDiscriminatedUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x4) => !!x4);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index3) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index3, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index3, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message2) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message2) }
        });
      }
      max(maxSize, message2) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message2) }
        });
      }
      size(size2, message2) {
        return this.min(size2, message2).max(size2, message2);
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error2) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error2
            }
          });
        }
        function makeReturnsIssue(returns, error2) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x4) => !!x4),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error2
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn2 = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me2 = this;
          return OK(async function(...args) {
            const error2 = new ZodError([]);
            const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
              error2.addIssue(makeArgsIssue(args, e2));
              throw error2;
            });
            const result = await Reflect.apply(fn2, this, parsedArgs);
            const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
              error2.addIssue(makeReturnsIssue(result, e2));
              throw error2;
            });
            return parsedReturns;
          });
        } else {
          const me2 = this;
          return OK(function(...args) {
            const parsedArgs = me2._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn2, this, parsedArgs.data);
            const parsedReturns = me2._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum.create(values);
      }
      exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b2) {
        return new ZodPipeline({
          in: a2,
          out: b2,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    custom = (check2, params = {}, fatal) => {
      if (check2)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a78, _b;
          if (!check2(data)) {
            const p4 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a78 = p4.fatal) !== null && _a78 !== void 0 ? _a78 : fatal) !== null && _b !== void 0 ? _b : true;
            const p22 = typeof p4 === "string" ? { message: p4 } : p4;
            ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType$1 = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType$1,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
    !!process.versions?.webcontainer;
    remoteResultSchema = z.object({
      columns: z.array(z.string()),
      columnTypes: z.array(z.string()),
      rows: z.array(z.array(z.unknown())),
      rowsAffected: z.number(),
      lastInsertRowid: z.unknown().optional()
    });
    `${red("\u25B6 Login required!")}

  To authenticate with Astro Studio, run
  ${cyan("astro db login")}
`;
    `${red("\u25B6 Directory not linked.")}

  To link this directory to an Astro Studio project, run
  ${cyan("astro db link")}
`;
    `${red(
      "\u25B6 No file path provided."
    )} Provide a path by running ${cyan("astro db execute <path>")}
`;
    `${red(
      "\u25B6 Please provide a query to execute using the --query flag."
    )}
`;
    dateType = customType({
      dataType() {
        return "text";
      },
      toDriver(value) {
        return value.toISOString();
      },
      fromDriver(value) {
        return new Date(value);
      }
    });
    jsonType = customType({
      dataType() {
        return "text";
      },
      toDriver(value) {
        return JSON.stringify(value);
      },
      fromDriver(value) {
        return JSON.parse(value);
      }
    });
    sql`CURRENT_TIMESTAMP`;
    sql`TRUE`;
    sql`FALSE`;
    db = await createRemoteDatabaseClient(process.env.ASTRO_STUDIO_APP_TOKEN ?? "97208ed03ee8df4d47cf8cff93d034c3642066b6:qhxqwq862vo4ungliyjlau8kvbxo", { "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": true, "SITE": void 0, "ASSETS_PREFIX": void 0 }.ASTRO_STUDIO_REMOTE_DB_URL ?? "https://db.services.astro.build");
    CVS = asDrizzleTable("CVS", { "columns": { "id": { "type": "text", "schema": { "unique": true, "deprecated": false, "name": "id", "collection": "CVS", "primaryKey": true } }, "name": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "name", "collection": "CVS", "primaryKey": false, "optional": false } }, "email": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "email", "collection": "CVS", "primaryKey": false, "optional": false } }, "place": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "place", "collection": "CVS", "primaryKey": false, "optional": false } }, "position": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "position", "collection": "CVS", "primaryKey": false, "optional": false } }, "status": { "type": "number", "schema": { "unique": false, "deprecated": false, "name": "status", "collection": "CVS", "primaryKey": false, "optional": false, "default": 1 } }, "createdAt": { "type": "date", "schema": { "optional": false, "unique": false, "deprecated": false, "name": "createdAt", "collection": "CVS" } } }, "deprecated": false });
    ATTACHMENTS = asDrizzleTable("ATTACHMENTS", { "columns": { "id": { "type": "number", "schema": { "unique": false, "deprecated": false, "name": "id", "collection": "ATTACHMENTS", "primaryKey": true } }, "name": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "name", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false } }, "url": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "url", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false } }, "size": { "type": "number", "schema": { "unique": false, "deprecated": false, "name": "size", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false } }, "type": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "type", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false } }, "key": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "key", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false } }, "cvId": { "type": "text", "schema": { "unique": false, "deprecated": false, "name": "cvId", "collection": "ATTACHMENTS", "primaryKey": false, "optional": false, "references": { "type": "text", "schema": { "unique": true, "deprecated": false, "name": "id", "collection": "CVS", "primaryKey": true } } } } }, "deprecated": false });
    middlewareMarker = "middlewareMarker";
    codeblock = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
    TRPCBuilder = class {
      context() {
        return new TRPCBuilder();
      }
      meta() {
        return new TRPCBuilder();
      }
      create(options) {
        return createTRPCInner()(options);
      }
    };
    initTRPC = new TRPCBuilder();
    t$1 = initTRPC.context().create({
      isServer: true
    });
    t$1.middleware;
    publicProcedure = t$1.procedure;
    statusSchema = z.number().min(1, { message: "Invalid Status" }).max(4, { message: "Invalid Status" });
    inputItem$1 = z.object({
      id: z.string(),
      name: z.string(),
      newStatus: statusSchema
    });
    inputSchema$3 = inputItem$1.or(z.array(inputItem$1));
    outputItem$1 = z.object({
      name: z.string(),
      newStatus: statusSchema
    });
    outputSchema$3 = outputItem$1.or(z.array(outputItem$1));
    changeStatusProcedure = publicProcedure.input(inputSchema$3).output(outputSchema$3).mutation(async ({ input }) => {
      try {
        if (!Array.isArray(input)) {
          const { id: id3, name, newStatus } = input;
          await db.update(CVS).set({ status: newStatus }).where(eq(CVS.id, id3));
          return {
            name,
            newStatus
          };
        }
        const queries = [];
        input.forEach(
          (i2) => queries.push(
            db.update(CVS).set({ status: i2.newStatus }).where(eq(CVS.id, i2.id))
          )
        );
        await db.batch(queries);
        return input.map((i2) => ({
          name: i2.name,
          newStatus: i2.newStatus
        }));
      } catch (e2) {
        throw new TRPCError({ code: "BAD_REQUEST" });
      }
    });
    define_globalThis_process_env_default = {};
    r2 = /* @__PURE__ */ Object.create(null);
    E = (e2) => define_globalThis_process_env_default || Object.assign({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": true, "SITE": void 0, "ASSETS_PREFIX": void 0 }, { NODE: process.env.NODE, SHELL: process.env.SHELL, TERM: process.env.TERM, COLOR: 1, _: process.env._, NODE_ENV: "production" }) || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e2 ? r2 : globalThis);
    s = new Proxy(r2, { get(e2, o3) {
      return E()[o3] ?? r2[o3];
    }, has(e2, o3) {
      const i2 = E();
      return o3 in i2 || o3 in r2;
    }, set(e2, o3, i2) {
      const g = E(true);
      return g[o3] = i2, true;
    }, deleteProperty(e2, o3) {
      if (!o3)
        return false;
      const i2 = E(true);
      return delete i2[o3], true;
    }, ownKeys() {
      const e2 = E(true);
      return Object.keys(e2);
    } });
    t = typeof process < "u" && process.env && "production" || "";
    p = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"]];
    l = B();
    l.name;
    I = globalThis.process?.platform || "";
    T = n(s.CI) || l.ci !== false;
    R = n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY);
    n(s.DEBUG);
    C = t === "test" || n(s.TEST);
    v = t === "dev" || t === "development";
    n(s.MINIMAL) || T || C || !R;
    a = /^win/i.test(I);
    !n(s.NO_COLOR) && (n(s.FORCE_COLOR) || (R || a) && s.TERM !== "dumb" || T);
    _ = (globalThis.process?.versions?.node || "").replace(/^v/, "") || null;
    Number(_?.split(".")[0]) || null;
    W = globalThis.process || /* @__PURE__ */ Object.create(null);
    c = { versions: {} };
    w = new Proxy(W, { get(e2, o3) {
      if (o3 === "env")
        return s;
      if (o3 in e2)
        return e2[o3];
      if (o3 in c)
        return c[o3];
    } });
    A = globalThis.process?.release?.name === "node";
    L = !!globalThis.Bun || !!globalThis.process?.versions?.bun;
    D = !!globalThis.Deno;
    O = !!globalThis.fastly;
    S = !!globalThis.Netlify;
    N = !!globalThis.EdgeRuntime;
    u = globalThis.navigator?.userAgent === "Cloudflare-Workers";
    b = !!globalThis.__lagon__;
    F = [[S, "netlify"], [N, "edge-light"], [u, "workerd"], [O, "fastly"], [D, "deno"], [L, "bun"], [A, "node"], [b, "lagon"]];
    P = G();
    P?.name || "";
    mimeTypesInternal = {
      "application/andrew-inset": {
        source: "iana",
        extensions: [
          "ez"
        ],
        compressible: null
      },
      "application/applixware": {
        source: "apache",
        extensions: [
          "aw"
        ],
        compressible: null
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atom"
        ]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomcat"
        ]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomdeleted"
        ]
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomsvc"
        ]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dwd"
        ]
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "held"
        ]
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rsat"
        ]
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xcs"
        ]
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ccxml"
        ]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "cdfx"
        ]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: [
          "cdmia"
        ],
        compressible: null
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: [
          "cdmic"
        ],
        compressible: null
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: [
          "cdmid"
        ],
        compressible: null
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: [
          "cdmio"
        ],
        compressible: null
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: [
          "cdmiq"
        ],
        compressible: null
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "cpl"
        ]
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: [
          "cu"
        ],
        compressible: null
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpd"
        ]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpp"
        ]
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "davmount"
        ]
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "dbk"
        ]
      },
      "application/dssc+der": {
        source: "iana",
        extensions: [
          "dssc"
        ],
        compressible: null
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdssc"
        ]
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: [
          "es",
          "ecma"
        ]
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "emma"
        ]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "emotionml"
        ]
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "epub"
        ]
      },
      "application/exi": {
        source: "iana",
        extensions: [
          "exi"
        ],
        compressible: null
      },
      "application/express": {
        source: "iana",
        extensions: [
          "exp"
        ],
        compressible: null
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "fdt"
        ]
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: [
          "pfr"
        ],
        compressible: null
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "geojson"
        ]
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "gml"
        ]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "gpx"
        ]
      },
      "application/gxf": {
        source: "apache",
        extensions: [
          "gxf"
        ],
        compressible: null
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: [
          "gz"
        ]
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: [
          "stk"
        ],
        compressible: null
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ink",
          "inkml"
        ]
      },
      "application/ipfix": {
        source: "iana",
        extensions: [
          "ipfix"
        ],
        compressible: null
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "its"
        ]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: [
          "jar",
          "war",
          "ear"
        ]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: [
          "ser"
        ]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: [
          "class"
        ]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "js",
          "mjs"
        ]
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "json",
          "map"
        ]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: [
          "jsonml"
        ]
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "jsonld"
        ]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lgr"
        ]
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lostxml"
        ]
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: [
          "hqx"
        ],
        compressible: null
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: [
          "cpt"
        ],
        compressible: null
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mads"
        ]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "webmanifest"
        ]
      },
      "application/marc": {
        source: "iana",
        extensions: [
          "mrc"
        ],
        compressible: null
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mrcx"
        ]
      },
      "application/mathematica": {
        source: "iana",
        extensions: [
          "ma",
          "nb",
          "mb"
        ],
        compressible: null
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mathml"
        ]
      },
      "application/mbox": {
        source: "iana",
        extensions: [
          "mbox"
        ],
        compressible: null
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpf"
        ]
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mscml"
        ]
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "metalink"
        ]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "meta4"
        ]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mets"
        ]
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "maei"
        ]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "musd"
        ]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mods"
        ]
      },
      "application/mp21": {
        source: "iana",
        extensions: [
          "m21",
          "mp21"
        ],
        compressible: null
      },
      "application/mp4": {
        source: "iana",
        extensions: [
          "mp4s",
          "m4p"
        ],
        compressible: null
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: [
          "doc",
          "dot"
        ]
      },
      "application/mxf": {
        source: "iana",
        extensions: [
          "mxf"
        ],
        compressible: null
      },
      "application/n-quads": {
        source: "iana",
        extensions: [
          "nq"
        ],
        compressible: null
      },
      "application/n-triples": {
        source: "iana",
        extensions: [
          "nt"
        ],
        compressible: null
      },
      "application/node": {
        source: "iana",
        extensions: [
          "cjs"
        ],
        compressible: null
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: [
          "bin",
          "dms",
          "lrf",
          "mar",
          "so",
          "dist",
          "distz",
          "pkg",
          "bpk",
          "dump",
          "elc",
          "deploy",
          "exe",
          "dll",
          "deb",
          "dmg",
          "iso",
          "img",
          "msi",
          "msp",
          "msm",
          "buffer"
        ]
      },
      "application/oda": {
        source: "iana",
        extensions: [
          "oda"
        ],
        compressible: null
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "opf"
        ]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "ogx"
        ]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "omdoc"
        ]
      },
      "application/onenote": {
        source: "apache",
        extensions: [
          "onetoc",
          "onetoc2",
          "onetmp",
          "onepkg"
        ],
        compressible: null
      },
      "application/oxps": {
        source: "iana",
        extensions: [
          "oxps"
        ],
        compressible: null
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "relo"
        ]
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xer"
        ]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: [
          "pdf"
        ]
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: [
          "pgp"
        ]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: [
          "asc"
        ],
        compressible: null
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: [
          "asc",
          "sig"
        ],
        compressible: null
      },
      "application/pics-rules": {
        source: "apache",
        extensions: [
          "prf"
        ],
        compressible: null
      },
      "application/pkcs10": {
        source: "iana",
        extensions: [
          "p10"
        ],
        compressible: null
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: [
          "p7m",
          "p7c"
        ],
        compressible: null
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: [
          "p7s"
        ],
        compressible: null
      },
      "application/pkcs8": {
        source: "iana",
        extensions: [
          "p8"
        ],
        compressible: null
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: [
          "ac"
        ],
        compressible: null
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: [
          "cer"
        ],
        compressible: null
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: [
          "crl"
        ],
        compressible: null
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: [
          "pkipath"
        ],
        compressible: null
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: [
          "pki"
        ],
        compressible: null
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "pls"
        ]
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: [
          "ai",
          "eps",
          "ps"
        ]
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "provx"
        ]
      },
      "application/prs.cww": {
        source: "iana",
        extensions: [
          "cww"
        ],
        compressible: null
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "pskcxml"
        ]
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rdf",
          "owl"
        ]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rif"
        ]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: [
          "rnc"
        ],
        compressible: null
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rl"
        ]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rld"
        ]
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rs"
        ]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rapd"
        ]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sls"
        ]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rusd"
        ]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: [
          "gbr"
        ],
        compressible: null
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: [
          "mft"
        ],
        compressible: null
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: [
          "roa"
        ],
        compressible: null
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "rsd"
        ]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "rss"
        ]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtf"
        ]
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sbml"
        ]
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: [
          "scq"
        ],
        compressible: null
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: [
          "scs"
        ],
        compressible: null
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: [
          "spq"
        ],
        compressible: null
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: [
          "spp"
        ],
        compressible: null
      },
      "application/sdp": {
        source: "iana",
        extensions: [
          "sdp"
        ],
        compressible: null
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "senmlx"
        ]
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sensmlx"
        ]
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: [
          "setpay"
        ],
        compressible: null
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: [
          "setreg"
        ],
        compressible: null
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "shf"
        ]
      },
      "application/sieve": {
        source: "iana",
        extensions: [
          "siv",
          "sieve"
        ],
        compressible: null
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "smi",
          "smil"
        ]
      },
      "application/sparql-query": {
        source: "iana",
        extensions: [
          "rq"
        ],
        compressible: null
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "srx"
        ]
      },
      "application/srgs": {
        source: "iana",
        extensions: [
          "gram"
        ],
        compressible: null
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "grxml"
        ]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sru"
        ]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "ssdl"
        ]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ssml"
        ]
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "swidtag"
        ]
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "tei",
          "teicorpus"
        ]
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "tfi"
        ]
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: [
          "tsd"
        ],
        compressible: null
      },
      "application/trig": {
        source: "iana",
        extensions: [
          "trig"
        ],
        compressible: null
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ttml"
        ]
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rsheet"
        ]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "td"
        ]
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "1km"
        ]
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: [
          "plb"
        ],
        compressible: null
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: [
          "psb"
        ],
        compressible: null
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: [
          "pvb"
        ],
        compressible: null
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: [
          "tcap"
        ],
        compressible: null
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: [
          "pwn"
        ],
        compressible: null
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: [
          "aso"
        ],
        compressible: null
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: [
          "imp"
        ],
        compressible: null
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: [
          "acu"
        ],
        compressible: null
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: [
          "atc",
          "acutc"
        ],
        compressible: null
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: [
          "air"
        ]
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: [
          "fcdt"
        ],
        compressible: null
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: [
          "fxp",
          "fxpl"
        ],
        compressible: null
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdp"
        ]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: [
          "xfdf"
        ],
        compressible: null
      },
      "application/vnd.age": {
        source: "iana",
        extensions: [
          "age"
        ],
        compressible: null
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: [
          "ahead"
        ],
        compressible: null
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: [
          "azf"
        ],
        compressible: null
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: [
          "azs"
        ],
        compressible: null
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: [
          "azw"
        ],
        compressible: null
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: [
          "acc"
        ],
        compressible: null
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: [
          "ami"
        ],
        compressible: null
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: [
          "apk"
        ]
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: [
          "cii"
        ],
        compressible: null
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: [
          "fti"
        ],
        compressible: null
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: [
          "atx"
        ],
        compressible: null
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpkg"
        ]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: [
          "key"
        ],
        compressible: null
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: [
          "m3u8"
        ],
        compressible: null
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: [
          "numbers"
        ],
        compressible: null
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: [
          "pages"
        ],
        compressible: null
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: [
          "swi"
        ],
        compressible: null
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: [
          "iota"
        ],
        compressible: null
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: [
          "aep"
        ],
        compressible: null
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "bmml"
        ]
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: [
          "mpm"
        ],
        compressible: null
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: [
          "bmi"
        ],
        compressible: null
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: [
          "rep"
        ],
        compressible: null
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "cdxml"
        ]
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: [
          "mmd"
        ],
        compressible: null
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: [
          "cdy"
        ],
        compressible: null
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "csl"
        ]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: [
          "cla"
        ],
        compressible: null
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: [
          "rp9"
        ],
        compressible: null
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: [
          "c4g",
          "c4d",
          "c4f",
          "c4p",
          "c4u"
        ],
        compressible: null
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: [
          "c11amc"
        ],
        compressible: null
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: [
          "c11amz"
        ],
        compressible: null
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: [
          "csp"
        ],
        compressible: null
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: [
          "cdbcmsg"
        ],
        compressible: null
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: [
          "cmc"
        ],
        compressible: null
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: [
          "clkx"
        ],
        compressible: null
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: [
          "clkk"
        ],
        compressible: null
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: [
          "clkp"
        ],
        compressible: null
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: [
          "clkt"
        ],
        compressible: null
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: [
          "clkw"
        ],
        compressible: null
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wbs"
        ]
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: [
          "pml"
        ],
        compressible: null
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: [
          "ppd"
        ],
        compressible: null
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: [
          "car"
        ],
        compressible: null
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: [
          "pcurl"
        ],
        compressible: null
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: [
          "dart"
        ]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: [
          "rdz"
        ],
        compressible: null
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: [
          "dbf"
        ],
        compressible: null
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: [
          "uvf",
          "uvvf",
          "uvd",
          "uvvd"
        ],
        compressible: null
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "uvt",
          "uvvt"
        ]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: [
          "uvx",
          "uvvx"
        ],
        compressible: null
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: [
          "uvz",
          "uvvz"
        ],
        compressible: null
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: [
          "fe_launch"
        ],
        compressible: null
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: [
          "dna"
        ],
        compressible: null
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: [
          "mlp"
        ],
        compressible: null
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: [
          "dpg"
        ],
        compressible: null
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: [
          "dfac"
        ],
        compressible: null
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: [
          "kpxx"
        ],
        compressible: null
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: [
          "ait"
        ],
        compressible: null
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: [
          "svc"
        ],
        compressible: null
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: [
          "geo"
        ],
        compressible: null
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: [
          "mag"
        ],
        compressible: null
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: [
          "nml"
        ],
        compressible: null
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: [
          "esf"
        ],
        compressible: null
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: [
          "msf"
        ],
        compressible: null
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: [
          "qam"
        ],
        compressible: null
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: [
          "slt"
        ],
        compressible: null
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: [
          "ssf"
        ],
        compressible: null
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "es3",
          "et3"
        ]
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: [
          "ez2"
        ],
        compressible: null
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: [
          "ez3"
        ],
        compressible: null
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: [
          "fdf"
        ],
        compressible: null
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: [
          "mseed"
        ],
        compressible: null
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: [
          "seed",
          "dataless"
        ],
        compressible: null
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: [
          "gph"
        ],
        compressible: null
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: [
          "ftc"
        ],
        compressible: null
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: [
          "fm",
          "frame",
          "maker",
          "book"
        ],
        compressible: null
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: [
          "fnc"
        ],
        compressible: null
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: [
          "ltf"
        ],
        compressible: null
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: [
          "fsc"
        ],
        compressible: null
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: [
          "oas"
        ],
        compressible: null
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: [
          "oa2"
        ],
        compressible: null
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: [
          "oa3"
        ],
        compressible: null
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: [
          "fg5"
        ],
        compressible: null
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: [
          "bh2"
        ],
        compressible: null
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: [
          "ddd"
        ],
        compressible: null
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: [
          "xdw"
        ],
        compressible: null
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: [
          "xbd"
        ],
        compressible: null
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: [
          "fzs"
        ],
        compressible: null
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: [
          "txd"
        ],
        compressible: null
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: [
          "ggb"
        ],
        compressible: null
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: [
          "ggt"
        ],
        compressible: null
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: [
          "gex",
          "gre"
        ],
        compressible: null
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: [
          "gxt"
        ],
        compressible: null
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: [
          "g2w"
        ],
        compressible: null
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: [
          "g3w"
        ],
        compressible: null
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: [
          "gmx"
        ],
        compressible: null
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "kml"
        ]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: [
          "kmz"
        ]
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: [
          "gqf",
          "gqs"
        ],
        compressible: null
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: [
          "gac"
        ],
        compressible: null
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: [
          "ghf"
        ],
        compressible: null
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: [
          "gim"
        ],
        compressible: null
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: [
          "grv"
        ],
        compressible: null
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: [
          "gtm"
        ],
        compressible: null
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: [
          "tpl"
        ],
        compressible: null
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: [
          "vcg"
        ],
        compressible: null
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "hal"
        ]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "zmm"
        ]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: [
          "hbci"
        ],
        compressible: null
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: [
          "les"
        ],
        compressible: null
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: [
          "hpgl"
        ],
        compressible: null
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: [
          "hpid"
        ],
        compressible: null
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: [
          "hps"
        ],
        compressible: null
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: [
          "jlt"
        ],
        compressible: null
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: [
          "pcl"
        ],
        compressible: null
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: [
          "pclxl"
        ],
        compressible: null
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: [
          "sfd-hdstx"
        ],
        compressible: null
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: [
          "mpy"
        ],
        compressible: null
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: [
          "afp",
          "listafp",
          "list3820"
        ],
        compressible: null
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: [
          "irm"
        ],
        compressible: null
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: [
          "sc"
        ],
        compressible: null
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: [
          "icc",
          "icm"
        ],
        compressible: null
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: [
          "igl"
        ],
        compressible: null
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: [
          "ivp"
        ],
        compressible: null
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: [
          "ivu"
        ],
        compressible: null
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: [
          "igm"
        ],
        compressible: null
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: [
          "xpw",
          "xpx"
        ],
        compressible: null
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: [
          "i2g"
        ],
        compressible: null
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: [
          "qbo"
        ],
        compressible: null
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: [
          "qfx"
        ],
        compressible: null
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: [
          "rcprofile"
        ],
        compressible: null
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "irp"
        ]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: [
          "xpr"
        ],
        compressible: null
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: [
          "fcs"
        ],
        compressible: null
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: [
          "jam"
        ],
        compressible: null
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: [
          "rms"
        ],
        compressible: null
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: [
          "jisp"
        ],
        compressible: null
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: [
          "joda"
        ],
        compressible: null
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: [
          "ktz",
          "ktr"
        ],
        compressible: null
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: [
          "karbon"
        ],
        compressible: null
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: [
          "chrt"
        ],
        compressible: null
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: [
          "kfo"
        ],
        compressible: null
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: [
          "flw"
        ],
        compressible: null
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: [
          "kon"
        ],
        compressible: null
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: [
          "kpr",
          "kpt"
        ],
        compressible: null
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: [
          "ksp"
        ],
        compressible: null
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: [
          "kwd",
          "kwt"
        ],
        compressible: null
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: [
          "htke"
        ],
        compressible: null
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: [
          "kia"
        ],
        compressible: null
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: [
          "kne",
          "knp"
        ],
        compressible: null
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: [
          "skp",
          "skd",
          "skt",
          "skm"
        ],
        compressible: null
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: [
          "sse"
        ],
        compressible: null
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lasxml"
        ]
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: [
          "lbd"
        ],
        compressible: null
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lbe"
        ]
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: [
          "123"
        ],
        compressible: null
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: [
          "apr"
        ],
        compressible: null
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: [
          "pre"
        ],
        compressible: null
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: [
          "nsf"
        ],
        compressible: null
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: [
          "org"
        ],
        compressible: null
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: [
          "scm"
        ],
        compressible: null
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: [
          "lwp"
        ],
        compressible: null
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: [
          "portpkg"
        ],
        compressible: null
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: [
          "mvt"
        ],
        compressible: null
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: [
          "mcd"
        ],
        compressible: null
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: [
          "mc1"
        ],
        compressible: null
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: [
          "cdkey"
        ],
        compressible: null
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: [
          "mwf"
        ],
        compressible: null
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: [
          "mfm"
        ],
        compressible: null
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: [
          "flo"
        ],
        compressible: null
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: [
          "igx"
        ],
        compressible: null
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: [
          "mif"
        ],
        compressible: null
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: [
          "daf"
        ],
        compressible: null
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: [
          "dis"
        ],
        compressible: null
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: [
          "mbk"
        ],
        compressible: null
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: [
          "mqy"
        ],
        compressible: null
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: [
          "msl"
        ],
        compressible: null
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: [
          "plc"
        ],
        compressible: null
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: [
          "txf"
        ],
        compressible: null
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: [
          "mpn"
        ],
        compressible: null
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: [
          "mpc"
        ],
        compressible: null
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xul"
        ]
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: [
          "cil"
        ],
        compressible: null
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: [
          "cab"
        ],
        compressible: null
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: [
          "xls",
          "xlm",
          "xla",
          "xlc",
          "xlt",
          "xlw"
        ]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlam"
        ],
        compressible: null
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlsb"
        ],
        compressible: null
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlsm"
        ],
        compressible: null
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "xltm"
        ],
        compressible: null
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: [
          "eot"
        ]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: [
          "chm"
        ],
        compressible: null
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: [
          "ims"
        ],
        compressible: null
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: [
          "lrm"
        ],
        compressible: null
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: [
          "thmx"
        ],
        compressible: null
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: [
          "cat"
        ],
        compressible: null
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: [
          "stl"
        ],
        compressible: null
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: [
          "ppt",
          "pps",
          "pot"
        ]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: [
          "ppam"
        ],
        compressible: null
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: [
          "pptm"
        ],
        compressible: null
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: [
          "sldm"
        ],
        compressible: null
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: [
          "ppsm"
        ],
        compressible: null
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "potm"
        ],
        compressible: null
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: [
          "mpp",
          "mpt"
        ],
        compressible: null
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: [
          "docm"
        ],
        compressible: null
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "dotm"
        ],
        compressible: null
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: [
          "wps",
          "wks",
          "wcm",
          "wdb"
        ],
        compressible: null
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: [
          "wpl"
        ],
        compressible: null
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: [
          "xps"
        ]
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: [
          "mseq"
        ],
        compressible: null
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: [
          "mus"
        ],
        compressible: null
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: [
          "msty"
        ],
        compressible: null
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: [
          "taglet"
        ],
        compressible: null
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: [
          "nlu"
        ],
        compressible: null
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: [
          "ntf",
          "nitf"
        ],
        compressible: null
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: [
          "nnd"
        ],
        compressible: null
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: [
          "nns"
        ],
        compressible: null
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: [
          "nnw"
        ],
        compressible: null
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ac"
        ]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: [
          "ngdat"
        ],
        compressible: null
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: [
          "n-gage"
        ],
        compressible: null
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: [
          "rpst"
        ],
        compressible: null
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: [
          "rpss"
        ],
        compressible: null
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: [
          "edm"
        ],
        compressible: null
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: [
          "edx"
        ],
        compressible: null
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: [
          "ext"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: [
          "odc"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: [
          "otc"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: [
          "odb"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: [
          "odf"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: [
          "odft"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: [
          "odg"
        ]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: [
          "otg"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: [
          "odi"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: [
          "oti"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
          "odp"
        ]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: [
          "otp"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: [
          "ods"
        ]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: [
          "ots"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: [
          "odt"
        ]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: [
          "odm"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: [
          "ott"
        ],
        compressible: null
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: [
          "oth"
        ],
        compressible: null
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: [
          "xo"
        ],
        compressible: null
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dd2"
        ]
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "obgx"
        ]
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: [
          "oxt"
        ],
        compressible: null
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "osm"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
          "pptx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: [
          "sldx"
        ],
        compressible: null
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: [
          "ppsx"
        ],
        compressible: null
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: [
          "potx"
        ],
        compressible: null
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: [
          "xlsx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: [
          "xltx"
        ],
        compressible: null
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: [
          "docx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: [
          "dotx"
        ],
        compressible: null
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: [
          "mgp"
        ],
        compressible: null
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: [
          "dp"
        ],
        compressible: null
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: [
          "esa"
        ],
        compressible: null
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: [
          "pdb",
          "pqa",
          "oprc"
        ],
        compressible: null
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: [
          "paw"
        ],
        compressible: null
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: [
          "str"
        ],
        compressible: null
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: [
          "ei6"
        ],
        compressible: null
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: [
          "efif"
        ],
        compressible: null
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: [
          "wg"
        ],
        compressible: null
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: [
          "plf"
        ],
        compressible: null
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: [
          "pbd"
        ],
        compressible: null
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: [
          "box"
        ],
        compressible: null
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: [
          "mgz"
        ],
        compressible: null
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: [
          "qps"
        ],
        compressible: null
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: [
          "ptid"
        ],
        compressible: null
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: [
          "qxd",
          "qxt",
          "qwd",
          "qwt",
          "qxl",
          "qxb"
        ],
        compressible: null
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: [
          "rar"
        ],
        compressible: null
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: [
          "bed"
        ],
        compressible: null
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: [
          "mxl"
        ],
        compressible: null
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "musicxml"
        ]
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: [
          "cryptonote"
        ],
        compressible: null
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: [
          "cod"
        ],
        compressible: null
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: [
          "rm"
        ],
        compressible: null
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: [
          "rmvb"
        ],
        compressible: null
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "link66"
        ]
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: [
          "st"
        ],
        compressible: null
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: [
          "see"
        ],
        compressible: null
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: [
          "sema"
        ],
        compressible: null
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: [
          "semd"
        ],
        compressible: null
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: [
          "semf"
        ],
        compressible: null
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: [
          "ifm"
        ],
        compressible: null
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: [
          "itp"
        ],
        compressible: null
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: [
          "iif"
        ],
        compressible: null
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: [
          "ipk"
        ],
        compressible: null
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: [
          "twd",
          "twds"
        ],
        compressible: null
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: [
          "mmf"
        ],
        compressible: null
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: [
          "teacher"
        ],
        compressible: null
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "fo"
        ]
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sdkm",
          "sdkd"
        ]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: [
          "dxp"
        ],
        compressible: null
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: [
          "sfs"
        ],
        compressible: null
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: [
          "sdc"
        ],
        compressible: null
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: [
          "sda"
        ],
        compressible: null
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: [
          "sdd"
        ],
        compressible: null
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: [
          "smf"
        ],
        compressible: null
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: [
          "sdw",
          "vor"
        ],
        compressible: null
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: [
          "sgl"
        ],
        compressible: null
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: [
          "smzip"
        ],
        compressible: null
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: [
          "sm"
        ],
        compressible: null
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wadl"
        ]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: [
          "sxc"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: [
          "stc"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: [
          "sxd"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: [
          "std"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: [
          "sxi"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: [
          "sti"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: [
          "sxm"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: [
          "sxw"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: [
          "sxg"
        ],
        compressible: null
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: [
          "stw"
        ],
        compressible: null
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: [
          "sus",
          "susp"
        ],
        compressible: null
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: [
          "svd"
        ],
        compressible: null
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: [
          "sis",
          "sisx"
        ],
        compressible: null
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "xsm"
        ]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "bdm"
        ],
        compressible: null
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "xdm"
        ]
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "ddf"
        ]
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: [
          "tao"
        ],
        compressible: null
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: [
          "pcap",
          "cap",
          "dmp"
        ],
        compressible: null
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: [
          "tmo"
        ],
        compressible: null
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: [
          "tpt"
        ],
        compressible: null
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: [
          "mxs"
        ],
        compressible: null
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: [
          "tra"
        ],
        compressible: null
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: [
          "ufd",
          "ufdl"
        ],
        compressible: null
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: [
          "utz"
        ],
        compressible: null
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: [
          "umj"
        ],
        compressible: null
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: [
          "unityweb"
        ],
        compressible: null
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "uoml"
        ]
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: [
          "vcx"
        ],
        compressible: null
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: [
          "vsd",
          "vst",
          "vss",
          "vsw"
        ],
        compressible: null
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: [
          "vis"
        ],
        compressible: null
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: [
          "vsf"
        ],
        compressible: null
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "wbxml"
        ],
        compressible: null
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: [
          "wmlc"
        ],
        compressible: null
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: [
          "wmlsc"
        ],
        compressible: null
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: [
          "wtb"
        ],
        compressible: null
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: [
          "nbp"
        ],
        compressible: null
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: [
          "wpd"
        ],
        compressible: null
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: [
          "wqd"
        ],
        compressible: null
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: [
          "stf"
        ],
        compressible: null
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: [
          "xar"
        ],
        compressible: null
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: [
          "xfdl"
        ],
        compressible: null
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: [
          "hvd"
        ],
        compressible: null
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: [
          "hvs"
        ],
        compressible: null
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: [
          "hvp"
        ],
        compressible: null
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: [
          "osf"
        ],
        compressible: null
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "osfpvg"
        ]
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: [
          "saf"
        ],
        compressible: null
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: [
          "spf"
        ],
        compressible: null
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: [
          "cmp"
        ],
        compressible: null
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: [
          "zir",
          "zirz"
        ],
        compressible: null
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "zaz"
        ]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "vxml"
        ]
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: [
          "wasm"
        ]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wif"
        ]
      },
      "application/widget": {
        source: "iana",
        extensions: [
          "wgt"
        ],
        compressible: null
      },
      "application/winhlp": {
        source: "apache",
        extensions: [
          "hlp"
        ],
        compressible: null
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wsdl"
        ]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wspolicy"
        ]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
          "7z"
        ]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: [
          "abw"
        ],
        compressible: null
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: [
          "ace"
        ],
        compressible: null
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: [
          "dmg"
        ],
        compressible: null
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: [
          "aab",
          "x32",
          "u32",
          "vox"
        ],
        compressible: null
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: [
          "aam"
        ],
        compressible: null
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: [
          "aas"
        ],
        compressible: null
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: [
          "bcpio"
        ],
        compressible: null
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: [
          "torrent"
        ],
        compressible: null
      },
      "application/x-blorb": {
        source: "apache",
        extensions: [
          "blb",
          "blorb"
        ],
        compressible: null
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: [
          "bz"
        ]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: [
          "bz2",
          "boz"
        ]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: [
          "cbr",
          "cba",
          "cbt",
          "cbz",
          "cb7"
        ],
        compressible: null
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: [
          "vcd"
        ],
        compressible: null
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: [
          "cfs"
        ],
        compressible: null
      },
      "application/x-chat": {
        source: "apache",
        extensions: [
          "chat"
        ],
        compressible: null
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: [
          "pgn"
        ],
        compressible: null
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: [
          "cco"
        ],
        compressible: null
      },
      "application/x-conference": {
        source: "apache",
        extensions: [
          "nsc"
        ],
        compressible: null
      },
      "application/x-cpio": {
        source: "apache",
        extensions: [
          "cpio"
        ],
        compressible: null
      },
      "application/x-csh": {
        source: "apache",
        extensions: [
          "csh"
        ],
        compressible: null
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: [
          "deb",
          "udeb"
        ],
        compressible: null
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: [
          "dgc"
        ],
        compressible: null
      },
      "application/x-director": {
        source: "apache",
        extensions: [
          "dir",
          "dcr",
          "dxr",
          "cst",
          "cct",
          "cxt",
          "w3d",
          "fgd",
          "swa"
        ],
        compressible: null
      },
      "application/x-doom": {
        source: "apache",
        extensions: [
          "wad"
        ],
        compressible: null
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "ncx"
        ]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "dtb"
        ]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "res"
        ]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: [
          "dvi"
        ]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: [
          "evy"
        ],
        compressible: null
      },
      "application/x-eva": {
        source: "apache",
        extensions: [
          "eva"
        ],
        compressible: null
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: [
          "bdf"
        ],
        compressible: null
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: [
          "gsf"
        ],
        compressible: null
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: [
          "psf"
        ],
        compressible: null
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: [
          "pcf"
        ],
        compressible: null
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: [
          "snf"
        ],
        compressible: null
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: [
          "pfa",
          "pfb",
          "pfm",
          "afm"
        ],
        compressible: null
      },
      "application/x-freearc": {
        source: "apache",
        extensions: [
          "arc"
        ],
        compressible: null
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: [
          "spl"
        ],
        compressible: null
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: [
          "gca"
        ],
        compressible: null
      },
      "application/x-glulx": {
        source: "apache",
        extensions: [
          "ulx"
        ],
        compressible: null
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: [
          "gnumeric"
        ],
        compressible: null
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: [
          "gramps"
        ],
        compressible: null
      },
      "application/x-gtar": {
        source: "apache",
        extensions: [
          "gtar"
        ],
        compressible: null
      },
      "application/x-hdf": {
        source: "apache",
        extensions: [
          "hdf"
        ],
        compressible: null
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: [
          "install"
        ],
        compressible: null
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: [
          "iso"
        ],
        compressible: null
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: [
          "jardiff"
        ],
        compressible: null
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: [
          "jnlp"
        ]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: [
          "latex"
        ]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: [
          "lzh",
          "lha"
        ],
        compressible: null
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: [
          "run"
        ],
        compressible: null
      },
      "application/x-mie": {
        source: "apache",
        extensions: [
          "mie"
        ],
        compressible: null
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: [
          "prc",
          "mobi"
        ],
        compressible: null
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: [
          "application"
        ],
        compressible: null
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: [
          "lnk"
        ],
        compressible: null
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: [
          "wmd"
        ],
        compressible: null
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: [
          "wmz"
        ],
        compressible: null
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: [
          "xbap"
        ],
        compressible: null
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: [
          "mdb"
        ],
        compressible: null
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: [
          "obd"
        ],
        compressible: null
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: [
          "crd"
        ],
        compressible: null
      },
      "application/x-msclip": {
        source: "apache",
        extensions: [
          "clp"
        ],
        compressible: null
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: [
          "exe",
          "dll",
          "com",
          "bat",
          "msi"
        ],
        compressible: null
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: [
          "mvb",
          "m13",
          "m14"
        ],
        compressible: null
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: [
          "wmf",
          "wmz",
          "emf",
          "emz"
        ],
        compressible: null
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: [
          "mny"
        ],
        compressible: null
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: [
          "pub"
        ],
        compressible: null
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: [
          "scd"
        ],
        compressible: null
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: [
          "trm"
        ],
        compressible: null
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: [
          "wri"
        ],
        compressible: null
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: [
          "nc",
          "cdf"
        ],
        compressible: null
      },
      "application/x-nzb": {
        source: "apache",
        extensions: [
          "nzb"
        ],
        compressible: null
      },
      "application/x-perl": {
        source: "nginx",
        extensions: [
          "pl",
          "pm"
        ],
        compressible: null
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: [
          "prc",
          "pdb"
        ],
        compressible: null
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: [
          "p12",
          "pfx"
        ]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: [
          "p7b",
          "spc"
        ],
        compressible: null
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: [
          "p7r"
        ],
        compressible: null
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
          "rar"
        ]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: [
          "rpm"
        ],
        compressible: null
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: [
          "ris"
        ],
        compressible: null
      },
      "application/x-sea": {
        source: "nginx",
        extensions: [
          "sea"
        ],
        compressible: null
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: [
          "sh"
        ]
      },
      "application/x-shar": {
        source: "apache",
        extensions: [
          "shar"
        ],
        compressible: null
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: [
          "swf"
        ]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: [
          "xap"
        ],
        compressible: null
      },
      "application/x-sql": {
        source: "apache",
        extensions: [
          "sql"
        ],
        compressible: null
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: [
          "sit"
        ]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: [
          "sitx"
        ],
        compressible: null
      },
      "application/x-subrip": {
        source: "apache",
        extensions: [
          "srt"
        ],
        compressible: null
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: [
          "sv4cpio"
        ],
        compressible: null
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: [
          "sv4crc"
        ],
        compressible: null
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: [
          "t3"
        ],
        compressible: null
      },
      "application/x-tads": {
        source: "apache",
        extensions: [
          "gam"
        ],
        compressible: null
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: [
          "tar"
        ]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: [
          "tcl",
          "tk"
        ],
        compressible: null
      },
      "application/x-tex": {
        source: "apache",
        extensions: [
          "tex"
        ],
        compressible: null
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: [
          "tfm"
        ],
        compressible: null
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: [
          "texinfo",
          "texi"
        ],
        compressible: null
      },
      "application/x-tgif": {
        source: "apache",
        extensions: [
          "obj"
        ],
        compressible: null
      },
      "application/x-ustar": {
        source: "apache",
        extensions: [
          "ustar"
        ],
        compressible: null
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: [
          "src"
        ],
        compressible: null
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: [
          "der",
          "crt",
          "pem"
        ],
        compressible: null
      },
      "application/x-xfig": {
        source: "apache",
        extensions: [
          "fig"
        ],
        compressible: null
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xlf"
        ]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: [
          "xpi"
        ]
      },
      "application/x-xz": {
        source: "apache",
        extensions: [
          "xz"
        ],
        compressible: null
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: [
          "z1",
          "z2",
          "z3",
          "z4",
          "z5",
          "z6",
          "z7",
          "z8"
        ],
        compressible: null
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xaml"
        ]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xav"
        ]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xca"
        ]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdf"
        ]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xel"
        ]
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xns"
        ]
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xenc"
        ]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xhtml",
          "xht"
        ]
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xlf"
        ]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xml",
          "xsl",
          "xsd",
          "rng"
        ]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: [
          "dtd"
        ]
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xop"
        ]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xpl"
        ]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xsl",
          "xslt"
        ]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xspf"
        ]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mxml",
          "xhvml",
          "xvml",
          "xvm"
        ]
      },
      "application/yang": {
        source: "iana",
        extensions: [
          "yang"
        ],
        compressible: null
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "yin"
        ]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "zip"
        ]
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: [
          "3gpp"
        ]
      },
      "audio/adpcm": {
        source: "apache",
        extensions: [
          "adp"
        ],
        compressible: null
      },
      "audio/amr": {
        source: "iana",
        extensions: [
          "amr"
        ],
        compressible: null
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: [
          "au",
          "snd"
        ]
      },
      "audio/midi": {
        source: "apache",
        extensions: [
          "mid",
          "midi",
          "kar",
          "rmi"
        ],
        compressible: null
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: [
          "mxmf"
        ],
        compressible: null
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
          "m4a",
          "mp4a"
        ]
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "mpga",
          "mp2",
          "mp2a",
          "mp3",
          "m2a",
          "m3a"
        ]
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "oga",
          "ogg",
          "spx",
          "opus"
        ]
      },
      "audio/s3m": {
        source: "apache",
        extensions: [
          "s3m"
        ],
        compressible: null
      },
      "audio/silk": {
        source: "apache",
        extensions: [
          "sil"
        ],
        compressible: null
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: [
          "uva",
          "uvva"
        ],
        compressible: null
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: [
          "eol"
        ],
        compressible: null
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: [
          "dra"
        ],
        compressible: null
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: [
          "dts"
        ],
        compressible: null
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: [
          "dtshd"
        ],
        compressible: null
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: [
          "lvp"
        ],
        compressible: null
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: [
          "pya"
        ],
        compressible: null
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: [
          "ecelp4800"
        ],
        compressible: null
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: [
          "ecelp7470"
        ],
        compressible: null
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: [
          "ecelp9600"
        ],
        compressible: null
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: [
          "rip"
        ],
        compressible: null
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: [
          "weba"
        ]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: [
          "aac"
        ]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: [
          "aif",
          "aiff",
          "aifc"
        ],
        compressible: null
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: [
          "caf"
        ]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: [
          "flac"
        ],
        compressible: null
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: [
          "m4a"
        ],
        compressible: null
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: [
          "mka"
        ],
        compressible: null
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: [
          "m3u"
        ],
        compressible: null
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: [
          "wax"
        ],
        compressible: null
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: [
          "wma"
        ],
        compressible: null
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: [
          "ram",
          "ra"
        ],
        compressible: null
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: [
          "rmp"
        ],
        compressible: null
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: [
          "ra"
        ],
        compressible: null
      },
      "audio/x-wav": {
        source: "apache",
        extensions: [
          "wav"
        ],
        compressible: null
      },
      "audio/x-gsm": {
        source: "apache",
        extensions: [
          "gsm"
        ],
        compressible: null
      },
      "audio/xm": {
        source: "apache",
        extensions: [
          "xm"
        ],
        compressible: null
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: [
          "cdx"
        ],
        compressible: null
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: [
          "cif"
        ],
        compressible: null
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: [
          "cmdf"
        ],
        compressible: null
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: [
          "cml"
        ],
        compressible: null
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: [
          "csml"
        ],
        compressible: null
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: [
          "xyz"
        ],
        compressible: null
      },
      "font/collection": {
        source: "iana",
        extensions: [
          "ttc"
        ],
        compressible: null
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: [
          "otf"
        ]
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: [
          "ttf"
        ]
      },
      "font/woff": {
        source: "iana",
        extensions: [
          "woff"
        ],
        compressible: null
      },
      "font/woff2": {
        source: "iana",
        extensions: [
          "woff2"
        ],
        compressible: null
      },
      "image/aces": {
        source: "iana",
        extensions: [
          "exr"
        ],
        compressible: null
      },
      "image/avci": {
        source: "iana",
        extensions: [
          "avci"
        ],
        compressible: null
      },
      "image/avcs": {
        source: "iana",
        extensions: [
          "avcs"
        ],
        compressible: null
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: [
          "avif"
        ]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: [
          "bmp"
        ]
      },
      "image/cgm": {
        source: "iana",
        extensions: [
          "cgm"
        ],
        compressible: null
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: [
          "drle"
        ],
        compressible: null
      },
      "image/emf": {
        source: "iana",
        extensions: [
          "emf"
        ],
        compressible: null
      },
      "image/fits": {
        source: "iana",
        extensions: [
          "fits"
        ],
        compressible: null
      },
      "image/g3fax": {
        source: "iana",
        extensions: [
          "g3"
        ],
        compressible: null
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: [
          "gif"
        ]
      },
      "image/heic": {
        source: "iana",
        extensions: [
          "heic"
        ],
        compressible: null
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: [
          "heics"
        ],
        compressible: null
      },
      "image/heif": {
        source: "iana",
        extensions: [
          "heif"
        ],
        compressible: null
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: [
          "heifs"
        ],
        compressible: null
      },
      "image/hej2k": {
        source: "iana",
        extensions: [
          "hej2"
        ],
        compressible: null
      },
      "image/hsj2": {
        source: "iana",
        extensions: [
          "hsj2"
        ],
        compressible: null
      },
      "image/ief": {
        source: "iana",
        extensions: [
          "ief"
        ],
        compressible: null
      },
      "image/jls": {
        source: "iana",
        extensions: [
          "jls"
        ],
        compressible: null
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: [
          "jp2",
          "jpg2"
        ]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpeg",
          "jpg",
          "jpe"
        ]
      },
      "image/jph": {
        source: "iana",
        extensions: [
          "jph"
        ],
        compressible: null
      },
      "image/jphc": {
        source: "iana",
        extensions: [
          "jhc"
        ],
        compressible: null
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpm"
        ]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpx",
          "jpf"
        ]
      },
      "image/jxr": {
        source: "iana",
        extensions: [
          "jxr"
        ],
        compressible: null
      },
      "image/jxra": {
        source: "iana",
        extensions: [
          "jxra"
        ],
        compressible: null
      },
      "image/jxrs": {
        source: "iana",
        extensions: [
          "jxrs"
        ],
        compressible: null
      },
      "image/jxs": {
        source: "iana",
        extensions: [
          "jxs"
        ],
        compressible: null
      },
      "image/jxsc": {
        source: "iana",
        extensions: [
          "jxsc"
        ],
        compressible: null
      },
      "image/jxsi": {
        source: "iana",
        extensions: [
          "jxsi"
        ],
        compressible: null
      },
      "image/jxss": {
        source: "iana",
        extensions: [
          "jxss"
        ],
        compressible: null
      },
      "image/ktx": {
        source: "iana",
        extensions: [
          "ktx"
        ],
        compressible: null
      },
      "image/ktx2": {
        source: "iana",
        extensions: [
          "ktx2"
        ],
        compressible: null
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: [
          "png"
        ]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: [
          "btif"
        ],
        compressible: null
      },
      "image/prs.pti": {
        source: "iana",
        extensions: [
          "pti"
        ],
        compressible: null
      },
      "image/sgi": {
        source: "apache",
        extensions: [
          "sgi"
        ],
        compressible: null
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "svg",
          "svgz"
        ]
      },
      "image/t38": {
        source: "iana",
        extensions: [
          "t38"
        ],
        compressible: null
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: [
          "tif",
          "tiff"
        ]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: [
          "tfx"
        ],
        compressible: null
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: [
          "psd"
        ]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: [
          "azv"
        ],
        compressible: null
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: [
          "uvi",
          "uvvi",
          "uvg",
          "uvvg"
        ],
        compressible: null
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: [
          "djvu",
          "djv"
        ],
        compressible: null
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
          "sub"
        ],
        compressible: null
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: [
          "dwg"
        ],
        compressible: null
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: [
          "dxf"
        ],
        compressible: null
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: [
          "fbs"
        ],
        compressible: null
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: [
          "fpx"
        ],
        compressible: null
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: [
          "fst"
        ],
        compressible: null
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: [
          "mmr"
        ],
        compressible: null
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: [
          "rlc"
        ],
        compressible: null
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: [
          "ico"
        ]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: [
          "mdi"
        ],
        compressible: null
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: [
          "wdp"
        ],
        compressible: null
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: [
          "npx"
        ],
        compressible: null
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: [
          "b16"
        ],
        compressible: null
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: [
          "tap"
        ],
        compressible: null
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: [
          "vtf"
        ],
        compressible: null
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: [
          "wbmp"
        ],
        compressible: null
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: [
          "xif"
        ],
        compressible: null
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: [
          "pcx"
        ],
        compressible: null
      },
      "image/webp": {
        source: "apache",
        extensions: [
          "webp"
        ],
        compressible: null
      },
      "image/wmf": {
        source: "iana",
        extensions: [
          "wmf"
        ],
        compressible: null
      },
      "image/x-3ds": {
        source: "apache",
        extensions: [
          "3ds"
        ],
        compressible: null
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: [
          "ras"
        ],
        compressible: null
      },
      "image/x-cmx": {
        source: "apache",
        extensions: [
          "cmx"
        ],
        compressible: null
      },
      "image/x-freehand": {
        source: "apache",
        extensions: [
          "fh",
          "fhc",
          "fh4",
          "fh5",
          "fh7"
        ],
        compressible: null
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: [
          "ico"
        ]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: [
          "jng"
        ],
        compressible: null
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: [
          "sid"
        ],
        compressible: null
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: [
          "bmp"
        ]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: [
          "pcx"
        ],
        compressible: null
      },
      "image/x-pict": {
        source: "apache",
        extensions: [
          "pic",
          "pct"
        ],
        compressible: null
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: [
          "pnm"
        ],
        compressible: null
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: [
          "pbm"
        ],
        compressible: null
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: [
          "pgm"
        ],
        compressible: null
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: [
          "ppm"
        ],
        compressible: null
      },
      "image/x-rgb": {
        source: "apache",
        extensions: [
          "rgb"
        ],
        compressible: null
      },
      "image/x-tga": {
        source: "apache",
        extensions: [
          "tga"
        ],
        compressible: null
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: [
          "xbm"
        ],
        compressible: null
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: [
          "xpm"
        ],
        compressible: null
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: [
          "xwd"
        ],
        compressible: null
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ],
        compressible: null
      },
      "message/global": {
        source: "iana",
        extensions: [
          "u8msg"
        ],
        compressible: null
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: [
          "u8dsn"
        ],
        compressible: null
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: [
          "u8mdn"
        ],
        compressible: null
      },
      "message/global-headers": {
        source: "iana",
        extensions: [
          "u8hdr"
        ],
        compressible: null
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: [
          "eml",
          "mime"
        ]
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: [
          "wsc"
        ],
        compressible: null
      },
      "model/3mf": {
        source: "iana",
        extensions: [
          "3mf"
        ],
        compressible: null
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "gltf"
        ]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: [
          "glb"
        ]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: [
          "igs",
          "iges"
        ]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: [
          "msh",
          "mesh",
          "silo"
        ]
      },
      "model/mtl": {
        source: "iana",
        extensions: [
          "mtl"
        ],
        compressible: null
      },
      "model/obj": {
        source: "iana",
        extensions: [
          "obj"
        ],
        compressible: null
      },
      "model/step": {
        source: "iana",
        compressible: false,
        extensions: [
          ".p21",
          ".stp",
          ".step",
          ".stpnc",
          ".210"
        ]
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "stpx"
        ]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "stpz"
        ]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "stpxz"
        ]
      },
      "model/stl": {
        source: "iana",
        extensions: [
          "stl"
        ],
        compressible: null
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dae"
        ]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: [
          "dwf"
        ],
        compressible: null
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: [
          "gdl"
        ],
        compressible: null
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: [
          "gtw"
        ],
        compressible: null
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: [
          "mts"
        ],
        compressible: null
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: [
          "ogex"
        ],
        compressible: null
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: [
          "x_b"
        ],
        compressible: null
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: [
          "x_t"
        ],
        compressible: null
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: [
          "vds"
        ],
        compressible: null
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "usdz"
        ]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: [
          "bsp"
        ],
        compressible: null
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: [
          "vtu"
        ],
        compressible: null
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: [
          "wrl",
          "vrml"
        ]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: [
          "x3db",
          "x3dbz"
        ]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: [
          "x3db"
        ],
        compressible: null
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: [
          "x3dv",
          "x3dvz"
        ]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "x3d",
          "x3dz"
        ]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: [
          "x3dv"
        ],
        compressible: null
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: [
          "appcache",
          "manifest"
        ]
      },
      "text/calendar": {
        source: "iana",
        extensions: [
          "ics",
          "ifb"
        ],
        compressible: null
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "css"
        ]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: [
          "csv"
        ]
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: [
          "html",
          "htm",
          "shtml"
        ]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: [
          "markdown",
          "md"
        ]
      },
      "text/mathml": {
        source: "nginx",
        extensions: [
          "mml"
        ],
        compressible: null
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "n3"
        ]
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: [
          "txt",
          "text",
          "conf",
          "def",
          "list",
          "log",
          "in",
          "ini"
        ]
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: [
          "dsc"
        ],
        compressible: null
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtx"
        ]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtf"
        ]
      },
      "text/sgml": {
        source: "iana",
        extensions: [
          "sgml",
          "sgm"
        ],
        compressible: null
      },
      "text/shex": {
        source: "iana",
        extensions: [
          "shex"
        ],
        compressible: null
      },
      "text/spdx": {
        source: "iana",
        extensions: [
          "spdx"
        ],
        compressible: null
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: [
          "tsv"
        ]
      },
      "text/troff": {
        source: "iana",
        extensions: [
          "t",
          "tr",
          "roff",
          "man",
          "me",
          "ms"
        ],
        compressible: null
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "ttl"
        ],
        compressible: null
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: [
          "uri",
          "uris",
          "urls"
        ]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: [
          "vcard"
        ]
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: [
          "curl"
        ],
        compressible: null
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: [
          "dcurl"
        ],
        compressible: null
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: [
          "mcurl"
        ],
        compressible: null
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: [
          "scurl"
        ],
        compressible: null
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
          "sub"
        ],
        compressible: null
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: [
          "ged"
        ],
        compressible: null
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: [
          "fly"
        ],
        compressible: null
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: [
          "flx"
        ],
        compressible: null
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: [
          "gv"
        ],
        compressible: null
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: [
          "3dml"
        ],
        compressible: null
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: [
          "spot"
        ],
        compressible: null
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "jad"
        ],
        compressible: null
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: [
          "wml"
        ],
        compressible: null
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: [
          "wmls"
        ],
        compressible: null
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "vtt"
        ]
      },
      "text/x-asm": {
        source: "apache",
        extensions: [
          "s",
          "asm"
        ],
        compressible: null
      },
      "text/x-c": {
        source: "apache",
        extensions: [
          "c",
          "cc",
          "cxx",
          "cpp",
          "h",
          "hh",
          "dic"
        ],
        compressible: null
      },
      "text/x-component": {
        source: "nginx",
        extensions: [
          "htc"
        ],
        compressible: null
      },
      "text/x-fortran": {
        source: "apache",
        extensions: [
          "f",
          "for",
          "f77",
          "f90"
        ],
        compressible: null
      },
      "text/x-java-source": {
        source: "apache",
        extensions: [
          "java"
        ],
        compressible: null
      },
      "text/x-nfo": {
        source: "apache",
        extensions: [
          "nfo"
        ],
        compressible: null
      },
      "text/x-opml": {
        source: "apache",
        extensions: [
          "opml"
        ],
        compressible: null
      },
      "text/x-pascal": {
        source: "apache",
        extensions: [
          "p",
          "pas"
        ],
        compressible: null
      },
      "text/x-setext": {
        source: "apache",
        extensions: [
          "etx"
        ],
        compressible: null
      },
      "text/x-sfv": {
        source: "apache",
        extensions: [
          "sfv"
        ],
        compressible: null
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: [
          "uu"
        ],
        compressible: null
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: [
          "vcs"
        ],
        compressible: null
      },
      "text/x-vcard": {
        source: "apache",
        extensions: [
          "vcf"
        ],
        compressible: null
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xml"
        ]
      },
      "video/3gpp": {
        source: "iana",
        extensions: [
          "3gp",
          "3gpp"
        ],
        compressible: null
      },
      "video/3gpp2": {
        source: "iana",
        extensions: [
          "3g2"
        ],
        compressible: null
      },
      "video/h261": {
        source: "iana",
        extensions: [
          "h261"
        ],
        compressible: null
      },
      "video/h263": {
        source: "iana",
        extensions: [
          "h263"
        ],
        compressible: null
      },
      "video/h264": {
        source: "iana",
        extensions: [
          "h264"
        ],
        compressible: null
      },
      "video/iso.segment": {
        source: "iana",
        extensions: [
          "m4s"
        ],
        compressible: null
      },
      "video/jpeg": {
        source: "iana",
        extensions: [
          "jpgv"
        ],
        compressible: null
      },
      "video/jpm": {
        source: "apache",
        extensions: [
          "jpm",
          "jpgm"
        ],
        compressible: null
      },
      "video/mj2": {
        source: "iana",
        extensions: [
          "mj2",
          "mjp2"
        ],
        compressible: null
      },
      "video/mp2t": {
        source: "iana",
        extensions: [
          "ts"
        ],
        compressible: null
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
          "mp4",
          "mp4v",
          "mpg4"
        ]
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "mpeg",
          "mpg",
          "mpe",
          "m1v",
          "m2v"
        ]
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "ogv"
        ]
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: [
          "qt",
          "mov"
        ]
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: [
          "uvh",
          "uvvh"
        ],
        compressible: null
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: [
          "uvm",
          "uvvm"
        ],
        compressible: null
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: [
          "uvp",
          "uvvp"
        ],
        compressible: null
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: [
          "uvs",
          "uvvs"
        ],
        compressible: null
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: [
          "uvv",
          "uvvv"
        ],
        compressible: null
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: [
          "dvb"
        ],
        compressible: null
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: [
          "fvt"
        ],
        compressible: null
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: [
          "mxu",
          "m4u"
        ],
        compressible: null
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: [
          "pyv"
        ],
        compressible: null
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: [
          "uvu",
          "uvvu"
        ],
        compressible: null
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: [
          "viv"
        ],
        compressible: null
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: [
          "webm"
        ]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: [
          "f4v"
        ],
        compressible: null
      },
      "video/x-fli": {
        source: "apache",
        extensions: [
          "fli"
        ],
        compressible: null
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: [
          "flv"
        ]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: [
          "m4v"
        ],
        compressible: null
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: [
          "mkv",
          "mk3d",
          "mks"
        ]
      },
      "video/x-mng": {
        source: "apache",
        extensions: [
          "mng"
        ],
        compressible: null
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: [
          "asf",
          "asx"
        ],
        compressible: null
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: [
          "vob"
        ],
        compressible: null
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: [
          "wm"
        ],
        compressible: null
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: [
          "wmv"
        ]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: [
          "wmx"
        ],
        compressible: null
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: [
          "wvx"
        ],
        compressible: null
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: [
          "avi"
        ],
        compressible: null
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: [
          "movie"
        ],
        compressible: null
      },
      "video/x-smv": {
        source: "apache",
        extensions: [
          "smv"
        ],
        compressible: null
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: [
          "ice"
        ],
        compressible: null
      }
    };
    mimeTypes = mimeTypesInternal;
    extensions = {};
    types = {};
    populateMaps(extensions, types);
    withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1e3, MAX_RETRIES = 20) => {
      let tries = 0;
      let backoffMs = 500;
      let backoffFuzzMs = 0;
      let result = void 0;
      while (tries <= MAX_RETRIES) {
        result = await doTheThing();
        if (result !== void 0)
          return result;
        tries += 1;
        backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);
        backoffFuzzMs = Math.floor(Math.random() * 500);
        if (tries > 3) {
          console.error(`[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(backoffMs / 1e3)} seconds...`);
        }
        await new Promise((r5) => setTimeout(r5, backoffMs + backoffFuzzMs));
      }
      return null;
    };
    ERROR_CODES = {
      // Generic
      BAD_REQUEST: 400,
      NOT_FOUND: 404,
      FORBIDDEN: 403,
      INTERNAL_SERVER_ERROR: 500,
      INTERNAL_CLIENT_ERROR: 500,
      // S3 specific
      TOO_LARGE: 413,
      TOO_SMALL: 400,
      TOO_MANY_FILES: 400,
      KEY_TOO_LONG: 400,
      // UploadThing specific
      URL_GENERATION_FAILED: 500,
      UPLOAD_FAILED: 500,
      MISSING_ENV: 500,
      FILE_LIMIT_EXCEEDED: 500
    };
    UploadThingError = class extends Error {
      constructor(initOpts) {
        const opts2 = typeof initOpts === "string" ? {
          code: "INTERNAL_SERVER_ERROR",
          message: initOpts
        } : initOpts;
        const message2 = opts2.message ?? messageFromUnknown(opts2.cause, opts2.code);
        super(message2);
        this.code = opts2.code;
        this.data = opts2.data;
        if (opts2.cause instanceof Error) {
          this.cause = opts2.cause;
        } else if (opts2.cause instanceof Response) {
          this.cause = new Error(`Response ${opts2.cause.status} ${opts2.cause.statusText}`);
        } else if (typeof opts2.cause === "string") {
          this.cause = new Error(opts2.cause);
        } else {
          this.cause = opts2.cause;
        }
      }
      static async fromResponse(response) {
        const jsonOrError = await safeParseJSON(response);
        if (jsonOrError instanceof Error) {
          return new UploadThingError({
            message: jsonOrError.message,
            code: getErrorTypeFromStatusCode(response.status),
            cause: response
          });
        }
        let message2 = void 0;
        if (isObject$1(jsonOrError)) {
          if (typeof jsonOrError.message === "string") {
            message2 = jsonOrError.message;
          } else if (typeof jsonOrError.error === "string") {
            message2 = jsonOrError.error;
          }
        }
        return new UploadThingError({
          message: message2,
          code: getErrorTypeFromStatusCode(response.status),
          cause: response,
          data: jsonOrError
        });
      }
      static toObject(error2) {
        return {
          code: error2.code,
          message: error2.message,
          data: error2.data
        };
      }
      static serialize(error2) {
        return JSON.stringify(UploadThingError.toObject(error2));
      }
    };
    INTERNAL_DO_NOT_USE__fatalClientError = (e2) => new UploadThingError({
      code: "INTERNAL_CLIENT_ERROR",
      message: "Something went wrong. Please report this to UploadThing.",
      cause: e2
    });
    generateMimeTypes = (fileTypes) => {
      const accepted = fileTypes.map((type) => {
        if (type === "blob")
          return "blob";
        if (type === "pdf")
          return "application/pdf";
        if (type.includes("/"))
          return type;
        else
          return `${type}/*`;
      });
      if (accepted.includes("blob")) {
        return void 0;
      }
      return accepted;
    };
    generateClientDropzoneAccept = (fileTypes) => {
      const mimeTypes2 = generateMimeTypes(fileTypes);
      if (!mimeTypes2)
        return void 0;
      return Object.fromEntries(mimeTypes2.map((type) => [
        type,
        []
      ]));
    };
    generatePermittedFileTypes = (config) => {
      const fileTypes = config ? objectKeys(config) : [];
      const maxFileCount = config ? Object.values(config).map((v4) => v4.maxFileCount) : [];
      return {
        fileTypes,
        multiple: maxFileCount.some((v4) => v4 && v4 > 1)
      };
    };
    capitalizeStart = (str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    INTERNAL_doFormatting = (config) => {
      if (!config)
        return "";
      const allowedTypes = objectKeys(config);
      const formattedTypes = allowedTypes.map((f3) => f3 === "blob" ? "file" : f3);
      if (formattedTypes.length > 1) {
        const lastType = formattedTypes.pop();
        return `${formattedTypes.join("s, ")} and ${lastType}s`;
      }
      const key = allowedTypes[0];
      const formattedKey = formattedTypes[0];
      const { maxFileSize, maxFileCount, minFileCount } = config[key];
      if (maxFileCount && maxFileCount > 1) {
        if (minFileCount > 1) {
          return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;
        } else {
          return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;
        }
      } else {
        return `${formattedKey} (${maxFileSize})`;
      }
    };
    allowedContentTextLabelGenerator = (config) => {
      return capitalizeStart(INTERNAL_doFormatting(config));
    };
    styleFieldToClassName = (styleField, args) => {
      if (typeof styleField === "string")
        return styleField;
      if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "string")
          return result;
      }
      return "";
    };
    styleFieldToCssObject = (styleField, args) => {
      if (typeof styleField === "object")
        return styleField;
      if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "object")
          return result;
      }
      return {};
    };
    contentFieldToContent = (contentField, arg) => {
      if (!contentField)
        return null;
      if (typeof contentField !== "function")
        return contentField;
      if (typeof contentField === "function") {
        const result = contentField(arg);
        return result;
      }
    };
    signaturePrefix = "hmac-sha256=";
    algorithm = {
      name: "HMAC",
      hash: "SHA-256"
    };
    signPayload = async (payload, secret) => {
      const encoder2 = new TextEncoder();
      const signingKey = await crypto.subtle.importKey("raw", encoder2.encode(secret), algorithm, false, [
        "sign"
      ]);
      const signature = await crypto.subtle.sign(algorithm, signingKey, encoder2.encode(payload)).then((sig) => Buffer.from(sig).toString("hex"));
      return `${signaturePrefix}${signature}`;
    };
    verifySignature = async (payload, signature, secret) => {
      const sig = signature?.slice(signaturePrefix.length);
      if (!sig)
        return false;
      const encoder2 = new TextEncoder();
      const signingKey = await crypto.subtle.importKey("raw", encoder2.encode(secret), algorithm, false, [
        "verify"
      ]);
      return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, "hex")), encoder2.encode(payload));
    };
    LogLevels = {
      silent: Number.NEGATIVE_INFINITY,
      fatal: 0,
      error: 0,
      warn: 1,
      log: 2,
      info: 3,
      success: 3,
      fail: 3,
      ready: 3,
      start: 3,
      box: 3,
      debug: 4,
      trace: 5,
      verbose: Number.POSITIVE_INFINITY
    };
    LogTypes = {
      // Silent
      silent: {
        level: -1
      },
      // Level 0
      fatal: {
        level: LogLevels.fatal
      },
      error: {
        level: LogLevels.error
      },
      // Level 1
      warn: {
        level: LogLevels.warn
      },
      // Level 2
      log: {
        level: LogLevels.log
      },
      // Level 3
      info: {
        level: LogLevels.info
      },
      success: {
        level: LogLevels.success
      },
      fail: {
        level: LogLevels.fail
      },
      ready: {
        level: LogLevels.info
      },
      start: {
        level: LogLevels.info
      },
      box: {
        level: LogLevels.info
      },
      // Level 4
      debug: {
        level: LogLevels.debug
      },
      // Level 5
      trace: {
        level: LogLevels.trace
      },
      // Verbose
      verbose: {
        level: LogLevels.verbose
      }
    };
    defu = createDefu();
    paused = false;
    queue = [];
    Consola = class {
      constructor(options = {}) {
        const types3 = options.types || LogTypes;
        this.options = defu(
          {
            ...options,
            defaults: { ...options.defaults },
            level: _normalizeLogLevel(options.level, types3),
            reporters: [...options.reporters || []]
          },
          {
            types: LogTypes,
            throttle: 1e3,
            throttleMin: 5,
            formatOptions: {
              date: true,
              colors: false,
              compact: true
            }
          }
        );
        for (const type in types3) {
          const defaults = {
            type,
            ...this.options.defaults,
            ...types3[type]
          };
          this[type] = this._wrapLogFn(defaults);
          this[type].raw = this._wrapLogFn(
            defaults,
            true
          );
        }
        if (this.options.mockFn) {
          this.mockTypes();
        }
        this._lastLog = {};
      }
      get level() {
        return this.options.level;
      }
      set level(level) {
        this.options.level = _normalizeLogLevel(
          level,
          this.options.types,
          this.options.level
        );
      }
      prompt(message2, opts2) {
        if (!this.options.prompt) {
          throw new Error("prompt is not supported!");
        }
        return this.options.prompt(message2, opts2);
      }
      create(options) {
        const instance = new Consola({
          ...this.options,
          ...options
        });
        if (this._mockFn) {
          instance.mockTypes(this._mockFn);
        }
        return instance;
      }
      withDefaults(defaults) {
        return this.create({
          ...this.options,
          defaults: {
            ...this.options.defaults,
            ...defaults
          }
        });
      }
      withTag(tag) {
        return this.withDefaults({
          tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
        });
      }
      addReporter(reporter) {
        this.options.reporters.push(reporter);
        return this;
      }
      removeReporter(reporter) {
        if (reporter) {
          const i2 = this.options.reporters.indexOf(reporter);
          if (i2 >= 0) {
            return this.options.reporters.splice(i2, 1);
          }
        } else {
          this.options.reporters.splice(0);
        }
        return this;
      }
      setReporters(reporters) {
        this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
        return this;
      }
      wrapAll() {
        this.wrapConsole();
        this.wrapStd();
      }
      restoreAll() {
        this.restoreConsole();
        this.restoreStd();
      }
      wrapConsole() {
        for (const type in this.options.types) {
          if (!console["__" + type]) {
            console["__" + type] = console[type];
          }
          console[type] = this[type].raw;
        }
      }
      restoreConsole() {
        for (const type in this.options.types) {
          if (console["__" + type]) {
            console[type] = console["__" + type];
            delete console["__" + type];
          }
        }
      }
      wrapStd() {
        this._wrapStream(this.options.stdout, "log");
        this._wrapStream(this.options.stderr, "log");
      }
      _wrapStream(stream, type) {
        if (!stream) {
          return;
        }
        if (!stream.__write) {
          stream.__write = stream.write;
        }
        stream.write = (data) => {
          this[type].raw(String(data).trim());
        };
      }
      restoreStd() {
        this._restoreStream(this.options.stdout);
        this._restoreStream(this.options.stderr);
      }
      _restoreStream(stream) {
        if (!stream) {
          return;
        }
        if (stream.__write) {
          stream.write = stream.__write;
          delete stream.__write;
        }
      }
      pauseLogs() {
        paused = true;
      }
      resumeLogs() {
        paused = false;
        const _queue = queue.splice(0);
        for (const item of _queue) {
          item[0]._logFn(item[1], item[2]);
        }
      }
      mockTypes(mockFn) {
        const _mockFn = mockFn || this.options.mockFn;
        this._mockFn = _mockFn;
        if (typeof _mockFn !== "function") {
          return;
        }
        for (const type in this.options.types) {
          this[type] = _mockFn(type, this.options.types[type]) || this[type];
          this[type].raw = this[type];
        }
      }
      _wrapLogFn(defaults, isRaw) {
        return (...args) => {
          if (paused) {
            queue.push([this, defaults, args, isRaw]);
            return;
          }
          return this._logFn(defaults, args, isRaw);
        };
      }
      _logFn(defaults, args, isRaw) {
        if ((defaults.level || 0) > this.level) {
          return false;
        }
        const logObj = {
          date: /* @__PURE__ */ new Date(),
          args: [],
          ...defaults,
          level: _normalizeLogLevel(defaults.level, this.options.types)
        };
        if (!isRaw && args.length === 1 && isLogObj(args[0])) {
          Object.assign(logObj, args[0]);
        } else {
          logObj.args = [...args];
        }
        if (logObj.message) {
          logObj.args.unshift(logObj.message);
          delete logObj.message;
        }
        if (logObj.additional) {
          if (!Array.isArray(logObj.additional)) {
            logObj.additional = logObj.additional.split("\n");
          }
          logObj.args.push("\n" + logObj.additional.join("\n"));
          delete logObj.additional;
        }
        logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
        logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
        const resolveLog = (newLog = false) => {
          const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
          if (this._lastLog.object && repeated > 0) {
            const args2 = [...this._lastLog.object.args];
            if (repeated > 1) {
              args2.push(`(repeated ${repeated} times)`);
            }
            this._log({ ...this._lastLog.object, args: args2 });
            this._lastLog.count = 1;
          }
          if (newLog) {
            this._lastLog.object = logObj;
            this._log(logObj);
          }
        };
        clearTimeout(this._lastLog.timeout);
        const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
        this._lastLog.time = logObj.date;
        if (diffTime < this.options.throttle) {
          try {
            const serializedLog = JSON.stringify([
              logObj.type,
              logObj.tag,
              logObj.args
            ]);
            const isSameLog = this._lastLog.serialized === serializedLog;
            this._lastLog.serialized = serializedLog;
            if (isSameLog) {
              this._lastLog.count = (this._lastLog.count || 0) + 1;
              if (this._lastLog.count > this.options.throttleMin) {
                this._lastLog.timeout = setTimeout(
                  resolveLog,
                  this.options.throttle
                );
                return;
              }
            }
          } catch {
          }
        }
        resolveLog(true);
      }
      _log(logObj) {
        for (const reporter of this.options.reporters) {
          reporter.log(logObj, {
            options: this.options
          });
        }
      }
    };
    Consola.prototype.add = Consola.prototype.addReporter;
    Consola.prototype.remove = Consola.prototype.removeReporter;
    Consola.prototype.clear = Consola.prototype.removeReporter;
    Consola.prototype.withScope = Consola.prototype.withTag;
    Consola.prototype.mock = Consola.prototype.mockTypes;
    Consola.prototype.pause = Consola.prototype.pauseLogs;
    Consola.prototype.resume = Consola.prototype.resumeLogs;
    UTFiles = Symbol("uploadthing-custom-id-symbol");
    VALID_ACTION_TYPES = [
      "upload",
      "failure",
      "multipart-complete"
    ];
    version = "6.9.0";
    colorize = (str, level) => {
      switch (level) {
        case "error":
        case "fatal":
          return `\x1B[41m\x1B[30m${str}\x1B[0m`;
        case "warn":
          return `\x1B[43m\x1B[30m${str}\x1B[0m`;
        case "info":
        case "log":
          return `\x1B[44m\x1B[30m${str}\x1B[0m`;
        case "debug":
          return `\x1B[47m\x1B[30m${str}\x1B[0m`;
        case "trace":
          return `\x1B[47m\x1B[30m${str}\x1B[0m`;
        case "success":
          return `\x1B[42m\x1B[30m${str}\x1B[0m`;
        default:
          return str;
      }
    };
    icons = {
      fatal: "\u2A2F",
      error: "\u2A2F",
      warn: "\u26A0\uFE0F",
      info: "\u2139",
      log: "\u2139",
      debug: "\u2699",
      trace: "\u2192",
      success: "\u2713"
    };
    logger = createConsola({
      reporters: [
        {
          log: (logObj) => {
            const { type, tag, date, args } = logObj;
            const icon = icons[type];
            const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
            const lines = formatArgs(args).join(" ").split("\n").map((l4) => logPrefix + " " + l4).join("\n");
            console.log(lines);
          }
        }
      ],
      defaults: {
        tag: "UPLOADTHING"
      }
    });
    initLogger = (level) => {
      logger.level = LogLevels[level ?? "info"];
    };
    isValidResponse = (response) => {
      if (!response.ok)
        return false;
      if (response.status >= 400)
        return false;
      if (!response.headers.has("x-uploadthing-version"))
        return false;
      return true;
    };
    conditionalDevServer = async (opts2) => {
      const fileData = await pollForFileData({
        url: generateUploadThingURL(`/api/pollUpload/${opts2.fileKey}`),
        apiKey: opts2.apiKey,
        sdkVersion: version,
        fetch: opts2.fetch
      }, async (json) => {
        const file = json.fileData;
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http"))
          callbackUrl = "http://" + callbackUrl;
        logger.info("SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
        const payload = JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://utfs.io/f/${encodeURIComponent(opts2.fileKey)}`,
            key: opts2.fileKey,
            name: file.fileName,
            size: file.fileSize,
            type: file.fileType,
            customId: file.customId
          }
        });
        const signature = await signPayload(payload, opts2.apiKey);
        try {
          const response = await opts2.fetch(callbackUrl, {
            method: "POST",
            body: payload,
            headers: {
              "content-type": "application/json",
              "uploadthing-hook": "callback",
              "x-uploadthing-signature": signature
            }
          });
          if (isValidResponse(response)) {
            logger.success("Successfully simulated callback for file", opts2.fileKey);
          } else {
            throw new Error("Invalid response");
          }
        } catch (e2) {
          logger.error(`Failed to simulate callback for file '${opts2.fileKey}'. Is your webhook configured correctly?`);
          logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);
          logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);
        }
        return file;
      });
      if (fileData !== void 0)
        return fileData;
      logger.error(`Failed to simulate callback for file ${opts2.fileKey}`);
      throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "File took too long to upload"
      });
    };
    createUTFetch = (apiKey, fetch2, fePackage, beAdapter) => {
      return async (endpoint, payload) => {
        const response = await fetch2(generateUploadThingURL(endpoint), {
          method: "POST",
          body: JSON.stringify(payload),
          headers: {
            "Content-Type": "application/json",
            "x-uploadthing-api-key": apiKey,
            "x-uploadthing-version": version,
            "x-uploadthing-fe-package": fePackage,
            "x-uploadthing-be-adapter": beAdapter
          }
        });
        return response;
      };
    };
    fileCountBoundsCheck = (files, routeConfig) => {
      const counts = files.reduce((acc, file) => {
        const type = getTypeFromFileName(file.name, objectKeys(routeConfig));
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      }, {});
      for (const _key in counts) {
        const key = _key;
        const config = routeConfig[key];
        if (!config) {
          throw new UploadThingError({
            code: "BAD_REQUEST",
            message: `Invalid config during file count - missing ${key}`,
            cause: `Expected route config to have a config for key ${key} but none was found.`
          });
        }
        const count3 = counts[key];
        const min2 = config.minFileCount;
        const max2 = config.maxFileCount;
        if (min2 > max2) {
          throw new UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config during file count - minFileCount > maxFileCount",
            cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min2} > ${max2}`
          });
        }
        if (count3 < min2 || count3 > max2) {
          return {
            minCount: min2,
            minCountHit: count3 < min2,
            maxCount: max2,
            maxCountHit: count3 > max2,
            count: count3,
            type: key
          };
        }
      }
      return {
        minCountHit: false,
        maxCountHit: false
      };
    };
    buildRequestHandler = (opts2, adapter) => {
      return async (input) => {
        const isDev = opts2.config?.isDev ?? v;
        const fetch2 = opts2.config?.fetch ?? globalThis.fetch;
        if (isDev) {
          logger.info("UploadThing dev server is now running!");
        }
        const { router, config } = opts2;
        const preferredOrEnvSecret = config?.uploadthingSecret ?? w.env.UPLOADTHING_SECRET;
        const req = input.req;
        const url = new URL(req.url);
        const params = url.searchParams;
        const uploadthingHook = req.headers.get("uploadthing-hook") ?? void 0;
        const slug = params.get("slug") ?? void 0;
        const actionType = params.get("actionType") ?? void 0;
        const utFrontendPackage = req.headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = req.headers.get("x-uploadthing-version");
        if (clientVersion != null && clientVersion !== version) {
          logger.error("Client version mismatch");
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "Client version mismatch",
            cause: `Server version: ${version}, Client version: ${clientVersion}`
          });
        }
        if (!slug) {
          logger.error("No slug provided in params:", params);
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "No slug provided in params"
          });
        }
        if (slug && typeof slug !== "string") {
          const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
          logger.error(msg);
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "`slug` must be a string",
            cause: msg
          });
        }
        if (actionType && typeof actionType !== "string") {
          const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;
          logger.error(msg);
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "`actionType` must be a string",
            cause: msg
          });
        }
        if (uploadthingHook && typeof uploadthingHook !== "string") {
          const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "`uploadthingHook` must be a string",
            cause: msg
          });
        }
        if (!preferredOrEnvSecret) {
          const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
          logger.error(msg);
          return new UploadThingError({
            code: "MISSING_ENV",
            message: `No secret provided`,
            cause: msg
          });
        }
        if (!preferredOrEnvSecret.startsWith("sk_")) {
          const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
          logger.error(msg);
          return new UploadThingError({
            code: "MISSING_ENV",
            message: "Invalid API key. API keys must start with 'sk_'.",
            cause: msg
          });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
          const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
          logger.error(msg);
          return new UploadThingError({
            code: "BAD_REQUEST",
            message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
            cause: msg
          });
        }
        const uploadable = router[slug];
        if (!uploadable) {
          const msg = `No file route found for slug ${slug}`;
          logger.error(msg);
          return new UploadThingError({
            code: "NOT_FOUND",
            message: msg
          });
        }
        const utFetch = createUTFetch(preferredOrEnvSecret, fetch2, utFrontendPackage, adapter);
        logger.debug("All request input is valid", {
          slug,
          actionType,
          uploadthingHook
        });
        if (uploadthingHook === "callback") {
          const maybeReqBody = await safeParseJSON(req);
          logger.debug("Handling callback request with input:", maybeReqBody);
          if (maybeReqBody instanceof Error) {
            logger.error("Invalid request body", maybeReqBody);
            return new UploadThingError({
              code: "BAD_REQUEST",
              message: "Invalid request body",
              cause: maybeReqBody
            });
          }
          const verified = await verifySignature(JSON.stringify(maybeReqBody), req.headers.get("x-uploadthing-signature"), preferredOrEnvSecret);
          logger.debug("Signature verified:", verified);
          if (!verified) {
            logger.error("Invalid signature");
            return new UploadThingError({
              code: "BAD_REQUEST",
              message: "Invalid signature"
            });
          }
          const resolverArgs = {
            file: maybeReqBody.file,
            metadata: maybeReqBody.metadata
          };
          logger.debug("Running 'onUploadComplete' callback with input:", resolverArgs);
          const res = await uploadable.resolver(resolverArgs);
          const payload = {
            fileKey: maybeReqBody.file.key,
            callbackData: res ?? null
          };
          logger.debug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
          const callbackResponse = await utFetch("/api/serverCallback", payload);
          logger.debug("UploadThing responded with status:", callbackResponse.status);
          return {
            status: 200,
            body: null
          };
        }
        if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
          const msg = `Expected ${VALID_ACTION_TYPES.map((x4) => `"${x4}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${actionType}"`;
          logger.error("Invalid action type.", msg);
          return new UploadThingError({
            code: "BAD_REQUEST",
            cause: `Invalid action type ${actionType}`,
            message: msg
          });
        }
        switch (actionType) {
          case "upload": {
            const maybeInput = await safeParseJSON(req);
            if (maybeInput instanceof Error) {
              logger.error("Invalid request body", maybeInput);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid request body",
                cause: maybeInput
              });
            }
            logger.debug("Handling upload request with input:", maybeInput);
            const { files, input: userInput } = maybeInput;
            if (!Array.isArray(files) || !files.every((f3) => isObject$1(f3) && typeof f3.name === "string" && typeof f3.size === "number" && typeof f3.type === "string")) {
              const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;
              logger.error(msg);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Files must be an array of objects with name and size",
                cause: msg
              });
            }
            let parsedInput = {};
            try {
              logger.debug("Parsing input");
              const inputParser = uploadable._def.inputParser;
              parsedInput = await getParseFn(inputParser)(userInput);
              logger.debug("Input parsed successfully", parsedInput);
            } catch (error2) {
              logger.error("An error occurred trying to parse input:", error2);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid input.",
                cause: error2
              });
            }
            let metadata = {};
            try {
              logger.debug("Running middleware");
              metadata = await uploadable._def.middleware({
                ...input.middlewareArgs,
                input: parsedInput,
                files
              });
              logger.debug("Middleware finished successfully with:", metadata);
            } catch (error2) {
              logger.error("An error occurred in your middleware function:", error2);
              if (error2 instanceof UploadThingError)
                return error2;
              return new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run middleware.",
                cause: error2
              });
            }
            if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
              const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
              logger.error(msg);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
              });
            }
            const filesWithCustomIds = files.map((file, idx) => {
              const theirs = metadata[UTFiles]?.[idx];
              if (theirs && theirs.size !== file.size) {
                logger.warn("File size mismatch. Reverting to original size");
              }
              return {
                name: theirs?.name ?? file.name,
                size: file.size,
                customId: theirs?.customId
              };
            });
            let parsedConfig;
            try {
              logger.debug("Parsing route config", uploadable._def.routerConfig);
              parsedConfig = fillInputRouteConfig(uploadable._def.routerConfig);
              logger.debug("Route config parsed successfully", parsedConfig);
            } catch (error2) {
              logger.error("Invalid route config", error2);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid config.",
                cause: error2
              });
            }
            try {
              logger.debug("Checking file count bounds", files);
              const { minCount, minCountHit, maxCount, maxCountHit, count: count3, type } = fileCountBoundsCheck(files, parsedConfig);
              if (maxCountHit || minCountHit) {
                const errorMessage = maxCountHit ? `You uploaded ${count3} file(s) of type '${type}', but the limit for that type is ${maxCount}` : `You uploaded ${count3} file(s) of type '${type}', but the minimum for that type is ${minCount}`;
                logger.error(errorMessage);
                return new UploadThingError({
                  code: "BAD_REQUEST",
                  message: maxCountHit ? "Maximum file count not met" : "Minimum file count not met",
                  cause: errorMessage
                });
              }
              logger.debug("File count bounds check passed");
            } catch (error2) {
              logger.error("Invalid route config", error2);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid config.",
                cause: error2
              });
            }
            const callbackUrl = resolveCallbackUrl({
              config,
              req,
              url,
              isDev
            });
            logger.debug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
            const uploadthingApiResponse = await utFetch("/api/prepareUpload", {
              files: filesWithCustomIds,
              routeConfig: parsedConfig,
              metadata,
              callbackUrl: callbackUrl.origin + callbackUrl.pathname,
              callbackSlug: slug
            });
            const parsedResponse = await safeParseJSON(uploadthingApiResponse);
            if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {
              logger.error("Unable to get presigned URLs", parsedResponse);
              return new UploadThingError({
                code: "URL_GENERATION_FAILED",
                message: "Unable to get presigned urls",
                cause: parsedResponse
              });
            }
            logger.debug("UploadThing responded with:", parsedResponse);
            logger.debug("Sending presigned URLs to client");
            let promise = void 0;
            if (isDev) {
              promise = Promise.all(parsedResponse.map((file) => conditionalDevServer({
                fileKey: file.key,
                apiKey: preferredOrEnvSecret,
                fetch: fetch2
              }).catch((error2) => {
                logger.error("Err", error2);
              })));
            }
            return {
              cleanup: promise,
              body: parsedResponse,
              status: 200
            };
          }
          case "multipart-complete": {
            const maybeReqBody = await safeParseJSON(req);
            if (maybeReqBody instanceof Error) {
              logger.error("Invalid request body", maybeReqBody);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid request body",
                cause: maybeReqBody
              });
            }
            logger.debug("Handling multipart-complete request with input:", maybeReqBody);
            logger.debug("Notifying UploadThing that multipart upload is complete");
            const completeRes = await utFetch("/api/completeMultipart", {
              fileKey: maybeReqBody.fileKey,
              uploadId: maybeReqBody.uploadId,
              etags: maybeReqBody.etags
            });
            if (!completeRes.ok) {
              logger.error("Failed to notify UploadThing that multipart upload is complete");
              return new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "Failed to complete multipart upload",
                cause: completeRes
              });
            }
            logger.debug("UploadThing responded with:", completeRes.status);
            return {
              status: 200,
              body: null
            };
          }
          case "failure": {
            const maybeReqBody = await safeParseJSON(req);
            if (maybeReqBody instanceof Error) {
              logger.error("Invalid request body", maybeReqBody);
              return new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid request body",
                cause: maybeReqBody
              });
            }
            const { fileKey, uploadId } = maybeReqBody;
            logger.debug("Handling failure request with input:", maybeReqBody);
            logger.debug("Notifying UploadThing that upload failed");
            const uploadthingApiResponse = await utFetch("/api/failureCallback", {
              fileKey,
              uploadId
            });
            if (!uploadthingApiResponse.ok) {
              const parsedResponse = await safeParseJSON(uploadthingApiResponse);
              logger.error("Failed to mark upload as failed", parsedResponse);
              return new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Unable to mark upload as failed",
                cause: parsedResponse
              });
            }
            logger.debug("UploadThing responded with:", uploadthingApiResponse);
            logger.debug("Running 'onUploadError' callback");
            try {
              uploadable._def.onUploadError({
                error: new UploadThingError({
                  code: "UPLOAD_FAILED",
                  message: `Upload failed for ${fileKey}`
                }),
                fileKey
              });
            } catch (error2) {
              logger.error("Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.", error2);
              return new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadError callback",
                cause: error2
              });
            }
            return {
              status: 200,
              body: null
            };
          }
          default: {
            return new UploadThingError({
              code: "BAD_REQUEST",
              message: `Invalid action type`
            });
          }
        }
      };
    };
    buildPermissionsInfoHandler = (opts2) => {
      return () => {
        const r5 = opts2.router;
        const permissions = Object.keys(r5).map((k4) => {
          const route = r5[k4];
          const config = fillInputRouteConfig(route._def.routerConfig);
          return {
            slug: k4,
            config
          };
        });
        return permissions;
      };
    };
    maybeParseResponseXML = (maybeXml) => {
      const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
      const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
      const code = codeMatch?.[1];
      const message2 = messageMatch?.[1];
      if (!code || !message2)
        return null;
      return {
        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,
        message: message2
      };
    };
    DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
    s3CodeToUploadThingCode = {
      AccessDenied: "FORBIDDEN",
      EntityTooSmall: "TOO_SMALL",
      EntityTooLarge: "TOO_LARGE",
      ExpiredToken: "FORBIDDEN",
      IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
      InternalError: "INTERNAL_SERVER_ERROR",
      KeyTooLongError: "KEY_TOO_LONG",
      MaxMessageLengthExceeded: "TOO_LARGE"
    };
    uploadFilesInternal = async (data, opts2) => {
      const fileData = data.files.map((file) => ({
        name: file.name ?? "unnamed-blob",
        type: file.type,
        size: file.size,
        ..."customId" in file ? {
          customId: file.customId
        } : {}
      }));
      logger.debug("Getting presigned URLs for files", fileData);
      const res = await opts2.fetch(generateUploadThingURL("/api/uploadFiles"), {
        method: "POST",
        headers: opts2.utRequestHeaders,
        cache: "no-store",
        body: JSON.stringify({
          files: fileData,
          metadata: data.metadata,
          contentDisposition: data.contentDisposition,
          acl: data.acl
        })
      });
      if (!res.ok) {
        const error2 = await UploadThingError.fromResponse(res);
        logger.debug("Failed getting presigned URLs:", error2);
        throw error2;
      }
      const json = await res.json();
      logger.debug("Got presigned URLs:", json.data);
      logger.debug("Starting uploads...");
      const uploads = await Promise.allSettled(data.files.map(async (file, i2) => {
        const presigned = json.data[i2];
        if (!presigned) {
          logger.error("Failed to generate presigned URL for file:", file, presigned);
          throw new UploadThingError({
            code: "URL_GENERATION_FAILED",
            message: "Failed to generate presigned URL",
            cause: JSON.stringify(presigned)
          });
        }
        if ("urls" in presigned) {
          await uploadMultipart(file, presigned, {
            ...opts2
          });
        } else {
          await uploadPresignedPost(file, presigned, {
            ...opts2
          });
        }
        logger.debug("Polling for file data...");
        await pollForFileData({
          url: generateUploadThingURL(`/api/pollUpload/${presigned.key}`),
          apiKey: opts2.utRequestHeaders["x-uploadthing-api-key"],
          sdkVersion: version,
          fetch: opts2.fetch
        });
        logger.debug("Polling complete.");
        return {
          key: presigned.key,
          url: presigned.fileUrl,
          name: file.name,
          size: file.size,
          type: file.type,
          customId: "customId" in file ? file.customId ?? null : null
        };
      }));
      logger.debug("All uploads complete, aggregating results...");
      return uploads.map((upload) => {
        if (upload.status === "fulfilled") {
          const data2 = upload.value;
          return {
            data: data2,
            error: null
          };
        }
        const reason = upload.reason;
        const error2 = UploadThingError.toObject(reason);
        return {
          data: null,
          error: error2
        };
      });
    };
    UTFile = class extends Blob {
      constructor(parts, name, options) {
        const optionsWithDefaults = {
          ...options,
          type: options?.type ?? (lookup(name) || void 0),
          lastModified: options?.lastModified ?? Date.now()
        };
        super(parts, optionsWithDefaults);
        this.name = name;
        this.customId = optionsWithDefaults.customId;
        this.lastModified = optionsWithDefaults.lastModified;
      }
    };
    UTApi = class {
      constructor(opts2) {
        this.deleteFiles = async (keys, opts22) => {
          guardServerOnly();
          const { keyType = this.defaultKeyType } = opts22 ?? {};
          return this.requestUploadThing("/api/deleteFile", keyType === "fileKey" ? {
            fileKeys: asArray(keys)
          } : {
            customIds: asArray(keys)
          }, "An unknown error occurred while deleting files.");
        };
        this.getFileUrls = async (keys, opts22) => {
          guardServerOnly();
          const { keyType = this.defaultKeyType } = opts22 ?? {};
          const json = await this.requestUploadThing("/api/getFileUrl", keyType === "fileKey" ? {
            fileKeys: asArray(keys)
          } : {
            customIds: asArray(keys)
          }, "An unknown error occurred while retrieving file URLs.");
          return json.data;
        };
        this.listFiles = async (opts22) => {
          guardServerOnly();
          const json = await this.requestUploadThing("/api/listFiles", {
            ...opts22
          }, "An unknown error occurred while listing files.");
          return json.files;
        };
        this.renameFiles = async (updates) => {
          guardServerOnly();
          return this.requestUploadThing("/api/renameFiles", {
            updates: asArray(updates)
          }, "An unknown error occurred while renaming files.");
        };
        this.renameFile = this.renameFiles;
        this.getUsageInfo = async () => {
          guardServerOnly();
          return this.requestUploadThing("/api/getUsageInfo", {}, "An unknown error occurred while getting usage info.");
        };
        this.getSignedURL = async (key, opts22) => {
          guardServerOnly();
          const expiresIn = opts22?.expiresIn ? parseTimeToSeconds(opts22.expiresIn) : void 0;
          const { keyType = this.defaultKeyType } = opts22 ?? {};
          if (opts22?.expiresIn && isNaN(expiresIn)) {
            throw new UploadThingError({
              code: "BAD_REQUEST",
              message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
            });
          }
          if (expiresIn && expiresIn > 86400 * 7) {
            throw new UploadThingError({
              code: "BAD_REQUEST",
              message: "expiresIn must be less than 7 days (604800 seconds)."
            });
          }
          const json = await this.requestUploadThing("/api/requestFileAccess", keyType === "fileKey" ? {
            fileKey: key,
            expiresIn
          } : {
            customId: key,
            expiresIn
          }, "An unknown error occurred while retrieving presigned URLs.");
          return json.url;
        };
        this.updateACL = (keys, acl, opts22) => {
          guardServerOnly();
          const { keyType = this.defaultKeyType } = opts22 ?? {};
          const updates = asArray(keys).map((key) => {
            return keyType === "fileKey" ? {
              fileKey: key,
              acl
            } : {
              customId: key,
              acl
            };
          });
          return this.requestUploadThing("/api/updateACL", {
            updates
          }, "An unknown error occurred while updating ACLs.");
        };
        this.fetch = opts2?.fetch ?? globalThis.fetch;
        this.apiKey = opts2?.apiKey ?? w.env.UPLOADTHING_SECRET;
        this.defaultHeaders = {
          "Content-Type": "application/json",
          "x-uploadthing-api-key": this.apiKey,
          "x-uploadthing-version": version,
          "x-uploadthing-be-adapter": "server-sdk"
        };
        this.defaultKeyType = opts2?.defaultKeyType ?? "fileKey";
        initLogger(opts2?.logLevel);
        guardServerOnly();
        getApiKeyOrThrow(this.apiKey);
        if (!this.apiKey?.startsWith("sk_")) {
          throw new UploadThingError({
            code: "MISSING_ENV",
            message: "Invalid API key. API keys must start with `sk_`."
          });
        }
        incompatibleNodeGuard();
      }
      async requestUploadThing(pathname, body, fallbackErrorMessage) {
        const url = generateUploadThingURL(pathname);
        logger.debug("Requesting UploadThing:", {
          url,
          body,
          headers: this.defaultHeaders
        });
        const res = await this.fetch(url, {
          method: "POST",
          cache: "no-store",
          headers: this.defaultHeaders,
          body: JSON.stringify(body)
        });
        logger.debug("UploadThing responsed with status:", res.status);
        const json = await res.json();
        if (!res.ok || "error" in json) {
          logger.error("Error:", json);
          throw new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
          });
        }
        logger.debug("UploadThing response:", json);
        return json;
      }
      async uploadFiles(files, opts2) {
        guardServerOnly();
        const uploads = await uploadFilesInternal({
          files: asArray(files),
          metadata: opts2?.metadata ?? {},
          contentDisposition: opts2?.contentDisposition ?? "inline",
          acl: opts2?.acl
        }, {
          fetch: this.fetch,
          utRequestHeaders: this.defaultHeaders
        });
        const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
        logger.debug("Finished uploading:", uploadFileResponse);
        return uploadFileResponse;
      }
      async uploadFilesFromUrl(urls2, opts2) {
        guardServerOnly();
        const formData = new FormData();
        formData.append("metadata", JSON.stringify(opts2?.metadata ?? {}));
        const downloadErrors = {};
        const files = await Promise.all(asArray(urls2).map(async (_url, index3) => {
          let url = isObject$1(_url) ? _url.url : _url;
          if (typeof url === "string") {
            if (url.startsWith("data:")) {
              downloadErrors[index3] = UploadThingError.toObject(new UploadThingError({
                code: "BAD_REQUEST",
                message: "Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only."
              }));
              return void 0;
            }
            url = new URL(url);
          }
          const { name = url.pathname.split("/").pop() ?? "unknown-filename", customId = void 0 } = isObject$1(_url) ? _url : {};
          logger.debug("Downloading file:", url);
          const fileResponse = await this.fetch(url);
          if (!fileResponse.ok) {
            downloadErrors[index3] = UploadThingError.toObject(new UploadThingError({
              code: "BAD_REQUEST",
              message: "Failed to download requested file.",
              cause: fileResponse
            }));
            return void 0;
          }
          logger.debug("Finished downloading file. Reading blob...");
          const blob = await fileResponse.blob();
          logger.debug("Finished reading blob.");
          return new UTFile([
            blob
          ], name, {
            customId
          });
        })).then((files2) => files2.filter((x4) => x4 !== void 0));
        logger.debug("Uploading files:", files);
        const uploads = await uploadFilesInternal({
          files,
          metadata: opts2?.metadata ?? {},
          contentDisposition: opts2?.contentDisposition ?? "inline",
          acl: opts2?.acl
        }, {
          fetch: this.fetch,
          utRequestHeaders: this.defaultHeaders
        });
        const responses = asArray(urls2).map((_3, index3) => {
          if (downloadErrors[index3]) {
            return {
              data: null,
              error: downloadErrors[index3]
            };
          }
          return uploads.shift();
        });
        const uploadFileResponse = Array.isArray(urls2) ? responses : responses[0];
        logger.debug("Finished uploading:", uploadFileResponse);
        return uploadFileResponse;
      }
    };
    createUploadthing = (opts2) => createBuilder(opts2);
    INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts2, adapter) => {
      initLogger(opts2.config?.logLevel);
      incompatibleNodeGuard();
      const requestHandler = buildRequestHandler(opts2, adapter);
      const getBuildPerms = buildPermissionsInfoHandler(opts2);
      const POST2 = async (request) => {
        const req = request instanceof Request ? request : request.request;
        const response = await requestHandler({
          req,
          middlewareArgs: {
            req,
            res: void 0,
            event: void 0
          }
        });
        if (response instanceof UploadThingError) {
          return new Response(JSON.stringify(formatError(response, opts2.router)), {
            status: getStatusCodeFromError(response),
            headers: {
              "x-uploadthing-version": version
            }
          });
        }
        if (response.status !== 200) {
          return new Response("An unknown error occurred", {
            status: 500,
            headers: {
              "x-uploadthing-version": version
            }
          });
        }
        const res = new Response(JSON.stringify(response.body), {
          status: response.status,
          headers: {
            "x-uploadthing-version": version
          }
        });
        res.cleanup = response.cleanup;
        return res;
      };
      const GET3 = (request) => {
        return new Response(JSON.stringify(getBuildPerms()), {
          status: 200,
          headers: {
            "x-uploadthing-version": version
          }
        });
      };
      return {
        GET: GET3,
        POST: POST2
      };
    };
    createRouteHandler = (opts2) => INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts2, "server");
    inputItem = z.object({
      id: z.string(),
      name: z.string()
    });
    inputSchema$2 = inputItem.or(z.array(inputItem));
    outputItem = z.object({
      name: z.string()
    });
    outputSchema$2 = outputItem.or(z.array(outputItem));
    deleteCVProcedure = publicProcedure.input(inputSchema$2).output(outputSchema$2).mutation(async ({ input }) => {
      try {
        const queries = [];
        const results = [];
        const utapi = new UTApi({ apiKey: "sk_live_41657a9ccbef098cf6fbd0e2bd8ee6171bcfa90d890a19945436aff2c7f4d6d0" });
        const inputs = Array.isArray(input) ? input : [input];
        for (const item of inputs) {
          const { id: id3, name } = item;
          const attachments = await db.select().from(ATTACHMENTS).where(eq(ATTACHMENTS.cvId, id3));
          await utapi.deleteFiles(attachments.map((a2) => a2.key));
          for (let a2 of attachments) {
            queries.push(db.delete(ATTACHMENTS).where(eq(ATTACHMENTS.id, a2.id)));
          }
          queries.push(db.delete(CVS).where(eq(CVS.id, id3)));
          results.push({ name });
        }
        await db.batch(queries);
        return Array.isArray(input) ? results : results[0];
      } catch (e2) {
        console.log(e2);
        throw new TRPCError({ code: "BAD_REQUEST" });
      }
    });
    filterSchema = z.object({
      id: z.enum(["place", "position", "status"]),
      value: z.string().or(z.number())
    });
    dateFilterSchema = z.object({
      type: z.literal("single"),
      date: z.string()
    }).optional().or(
      z.object({
        type: z.literal("range"),
        from: z.string(),
        to: z.string()
      }).optional()
    );
    sortSchema = z.object({
      id: z.enum(["name", "email", "createdAt"]),
      desc: z.boolean()
    });
    inputSchema$1 = z.object({
      filters: z.array(filterSchema).optional(),
      dateFilters: dateFilterSchema,
      search: z.object({
        id: z.enum(["name", "email"]),
        value: z.string()
      }).optional(),
      sorting: z.array(sortSchema).max(1, { message: "Only one sorting" }),
      pagination: z.object({
        page: z.number().default(1),
        limit: z.number().default(10)
      })
    });
    cvSchema = z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
      status: z.number(),
      place: z.string(),
      position: z.string(),
      createdAt: z.string(),
      attachments: z.array(
        z.object({
          name: z.string(),
          url: z.string(),
          type: z.string()
        })
      )
    });
    outputSchema$1 = z.object({
      cvs: z.array(cvSchema),
      pages: z.array(z.number())
    });
    getAllCVSProcedure = publicProcedure.input(inputSchema$1).output(outputSchema$1).query(async ({ input }) => {
      const { pagination, sorting, filters, dateFilters, search } = input;
      console.log(input);
      let cvsQuery = db.select().from(CVS).$dynamic();
      let totalPagesQuery = db.select({ count: count() }).from(CVS).$dynamic();
      if (filters) {
        const filterConditions = [];
        filters.forEach((filter) => {
          const { id: id3, value } = filter;
          switch (id3) {
            case "place":
              filterConditions.push(like(CVS.place, `%${value}%`));
              break;
            case "position":
              filterConditions.push(like(CVS.position, `%${value}%`));
              break;
            case "status":
              filterConditions.push(like(CVS.status, `${value}`));
              break;
            default:
              throw new TRPCError({ code: "BAD_REQUEST" });
          }
        });
        if (filterConditions.length > 0) {
          const filterCondition = and(...filterConditions);
          cvsQuery = cvsQuery.where(filterCondition);
          totalPagesQuery = totalPagesQuery.where(filterCondition);
        }
      }
      if (dateFilters) {
        const { type } = dateFilters;
        switch (type) {
          case "single":
            const { date } = dateFilters;
            const singleDate = new Date(date);
            const nextDay = new Date(singleDate.getTime() + 864e5);
            cvsQuery = cvsQuery.where(
              and(gte(CVS.createdAt, singleDate), lt(CVS.createdAt, nextDay))
            );
            totalPagesQuery = totalPagesQuery.where(
              and(gte(CVS.createdAt, singleDate), lt(CVS.createdAt, nextDay))
            );
            break;
          case "range": {
            const { from, to } = dateFilters;
            const fromDate = new Date(from);
            const toDate2 = new Date(to);
            cvsQuery = cvsQuery.where(
              and(gte(CVS.createdAt, fromDate), lt(CVS.createdAt, toDate2))
            );
            totalPagesQuery = totalPagesQuery.where(
              and(gte(CVS.createdAt, fromDate), lt(CVS.createdAt, toDate2))
            );
            break;
          }
          default:
            throw new TRPCError({ code: "BAD_REQUEST" });
        }
      }
      if (search) {
        const { id: id3, value } = search;
        switch (id3) {
          case "name":
            cvsQuery = cvsQuery.where(like(CVS.name, `%${value}%`));
            totalPagesQuery = totalPagesQuery.where(like(CVS.name, `%${value}%`));
            break;
          case "email":
            cvsQuery = cvsQuery.where(like(CVS.email, `%${value}%`));
            totalPagesQuery = totalPagesQuery.where(
              like(CVS.email, `%${value}%`)
            );
            break;
          default:
            throw new TRPCError({ code: "BAD_REQUEST" });
        }
      }
      if (!sorting.length) {
        cvsQuery.orderBy(desc(CVS.createdAt));
        totalPagesQuery.orderBy(desc(CVS.createdAt));
      } else {
        const { id: id3, desc: desc$1 } = sorting[0];
        switch (id3) {
          case "name":
            cvsQuery.orderBy(desc$1 ? desc(CVS.name) : asc(CVS.name));
            totalPagesQuery.orderBy(desc$1 ? desc(CVS.name) : asc(CVS.name));
            break;
          case "email":
            cvsQuery.orderBy(desc$1 ? desc(CVS.email) : asc(CVS.email));
            totalPagesQuery.orderBy(desc$1 ? desc(CVS.email) : asc(CVS.email));
            break;
          case "createdAt":
            cvsQuery.orderBy(desc$1 ? desc(CVS.createdAt) : asc(CVS.createdAt));
            totalPagesQuery.orderBy(
              desc$1 ? desc(CVS.createdAt) : asc(CVS.createdAt)
            );
            break;
          default:
            throw new TRPCError({ code: "BAD_REQUEST" });
        }
      }
      const { page: page6, limit } = pagination;
      const offset2 = (page6 - 1) * limit;
      cvsQuery.offset(offset2).limit(pagination.limit);
      const cvsStartTime = Date.now();
      console.log(cvsQuery.toString());
      const cvsResults = await cvsQuery.all();
      const cvsEndTime = Date.now();
      console.log(`CVs query took ${cvsEndTime - cvsStartTime} ms`);
      const cvsIDs = cvsResults.map((cv) => cv.id);
      const attachmentsStartTime = Date.now();
      const attachmentsResults = cvsIDs.length > 0 ? await db.select().from(ATTACHMENTS).where(inArray(ATTACHMENTS.cvId, cvsIDs)) : [];
      const attachmentsEndTime = Date.now();
      console.log(
        `Attachments query took ${attachmentsEndTime - attachmentsStartTime} ms`
      );
      const cvs2 = cvsResults.map((cv) => {
        const attachments = attachmentsResults.filter(
          (attachment) => attachment.cvId === cv.id
        );
        return {
          id: cv.id,
          name: cv.name,
          email: cv.email,
          status: cv.status,
          place: cv.place,
          position: cv.position,
          createdAt: cv.createdAt.toISOString(),
          attachments: attachments.map((attachment) => ({
            name: attachment.name,
            url: attachment.url,
            type: attachment.type
          }))
        };
      });
      const rowsCount = (await totalPagesQuery.all())[0].count;
      const totalPages = Math.ceil(rowsCount / pagination.limit);
      const pages = Array.from({ length: totalPages }, (_3, i2) => i2 + 1);
      return {
        pages,
        cvs: cvs2
      };
    });
    outputSchema = z.object({
      storageInUse: z.number()
    });
    getStorageInUseProcedure = publicProcedure.output(outputSchema).query(async () => {
      try {
        const sizeSum = await db.select({ value: sum(ATTACHMENTS.size) }).from(ATTACHMENTS);
        const sumString = sizeSum[0].value;
        if (!sumString)
          throw new TRPCError({ code: "BAD_REQUEST" });
        const storageInKB = Number(sumString);
        return {
          storageInUse: storageInKB
        };
      } catch (e2) {
        throw new TRPCError({ code: "BAD_REQUEST" });
      }
    });
    nameSchema = z.string().min(2, {
      message: "Nombre debe tener al menos 2 caracteres."
    });
    emailSchema = z.string().email({
      message: "Email no es v\xE1lido."
    });
    placeSchema = z.enum([
      "And\xFAjar",
      "Brenes",
      "Bollullos Par del Condado",
      "C\xE1diz",
      "Coria del Rio",
      "Estepa",
      "Gilena",
      "Hytasa",
      "La Carolina",
      "Lantejuela",
      "Moguer",
      "Osuna",
      "Sanl\xFAcar de Barrameda",
      "Sevilla",
      "Utrera"
    ]);
    positionSchema = z.enum([
      "Carnicer\xEDa",
      "Charcuter\xEDa",
      "Pescader\xEDa",
      "Fruter\xEDa",
      "Panader\xEDa",
      "Pasteler\xEDa",
      "Cajero",
      "Reponedor",
      "Limpieza"
    ]);
    uploadedFileSchema = z.object({
      name: z.string(),
      url: z.string(),
      key: z.string(),
      size: z.number(),
      type: z.string()
    });
    inputSchema = z.object({
      name: nameSchema,
      email: emailSchema,
      place: placeSchema,
      position: positionSchema,
      attachments: z.array(uploadedFileSchema)
    });
    insertCVProdedure = publicProcedure.input(inputSchema).mutation(async ({ input, ctx }) => {
      const queries = [];
      const cvId = generateId(15);
      queries.push(
        ctx.db.insert(ctx.CVS).values({
          id: cvId,
          name: input.name,
          email: input.email,
          place: input.place,
          position: input.position,
          createdAt: /* @__PURE__ */ new Date()
        })
      );
      for (const attachment of input.attachments) {
        queries.push(
          ctx.db.insert(ctx.ATTACHMENTS).values({
            name: attachment.name,
            url: attachment.url,
            size: attachment.size,
            type: attachment.type,
            key: attachment.key,
            cvId
          })
        );
      }
      await ctx.db.batch(queries);
    });
    appRouter = t$1.router({
      insertCV: insertCVProdedure,
      getAllCVS: getAllCVSProcedure,
      changeStatus: changeStatusProcedure,
      delete: deleteCVProcedure,
      getStorageInUse: getStorageInUseProcedure
    });
    ALL = ({ request }) => {
      return fetchRequestHandler({
        endpoint: "/api/trpc",
        req: request,
        router: appRouter,
        createContext,
        onError: (error2) => {
          console.error("trpc error", error2);
        }
      });
    };
    _trpc_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      ALL
    }, Symbol.toStringTag, { value: "Module" }));
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/pages/cvs_qudRXU8T.mjs
var cvs_qudRXU8T_exports = {};
__export(cvs_qudRXU8T_exports, {
  $: () => $8927f6f2acc4f386$export$250ffa63cdc0d034,
  A: () => SelectTrigger,
  B: () => Button$1,
  C: () => SelectValue,
  D: () => Download,
  E: () => SelectContent,
  F: () => places,
  G: () => SelectItem,
  H: () => positions,
  I: () => Input,
  J: () => trpcReact,
  K: () => ReloadIcon,
  L: () => httpBatchLink,
  M: () => QueryClientProvider,
  N: () => $$Base,
  O: () => cvs,
  P: () => Pause,
  Q: () => QueryClient,
  R: () => React,
  S: () => Square,
  _: () => __awaiter,
  a: () => __generator,
  b: () => __spreadArray$1,
  c: () => __read,
  d: () => _extends,
  e: () => cn$1,
  f: () => cva,
  g: () => $5e63c961fc1ce211$export$8c6ed5c666ac1360,
  h: () => $c512c27ab02ef895$export$50c7b4e9d9f19c1,
  i: () => $cf1ac5d9fe0e8206$export$722aac194ae923,
  j: () => jsxRuntimeExports$1,
  k: () => $921a889cee6df7e8$export$99c2b779aa4e8b8b,
  l: () => $6ed0406888f73fc4$export$c7b2cbe3552a0d05,
  m: () => $5cb92bef7577960e$export$177fb62ff3ec1f22,
  n: () => $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2,
  o: () => $5e63c961fc1ce211$export$d9f1ccf0bdb05d45,
  p: () => $ea1ef594cf570d83$export$be92b6f5f03c0fe9,
  q: () => $1746a345f3d73bb7$export$f680877a34711e37,
  r: () => reactExports,
  s: () => $71cd76cc60e0454e$export$6f32135080cb4c3,
  t: () => twMerge,
  u: () => $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9,
  v: () => $cf1ac5d9fe0e8206$export$b688253958b8dfe7,
  w: () => $e42e1063c40fb3ef$export$b9ecd428b558ff10,
  x: () => SwitchCamera,
  y: () => Plus,
  z: () => Select
});
function _mergeNamespaces(n5, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k4 in e2) {
        if (k4 !== "default" && !(k4 in n5)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k4);
          if (d2) {
            Object.defineProperty(n5, k4, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k4]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n5, Symbol.toStringTag, { value: "Module" }));
}
function A$1(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$1 && a2[z$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
function E$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
function F$1() {
}
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
function M$1(a2, b2, e2) {
  var d2, c2 = {}, k4 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k4 = "" + b2.key), b2)
      J.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g = arguments.length - 2;
  if (1 === g)
    c2.children = e2;
  else if (1 < g) {
    for (var f3 = Array(g), m2 = 0; m2 < g; m2++)
      f3[m2] = arguments[m2 + 2];
    c2.children = f3;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g = a2.defaultProps, g)
      void 0 === c2[d2] && (c2[d2] = g[d2]);
  return { $$typeof: l$2, type: a2, key: k4, ref: h2, props: c2, _owner: K$2.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$2;
}
function escape2(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
function Q$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k4 = typeof a2;
  if ("undefined" === k4 || "boolean" === k4)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k4) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$2:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2))
    for (var g = 0; g < a2.length; g++) {
      k4 = a2[g];
      var f3 = d2 + Q$2(k4, g);
      h2 += R$1(k4, b2, e2, f3, c2);
    }
  else if (f3 = A$1(a2), "function" === typeof f3)
    for (a2 = f3.call(a2), g = 0; !(k4 = a2.next()).done; )
      k4 = k4.value, f3 = d2 + Q$2(k4, g++), h2 += R$1(k4, b2, e2, f3, c2);
  else if ("object" === k4)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
function q$1(c2, a2, g) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g && (e2 = "" + g);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$1.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
function identity(x4) {
  return x4;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn2) => fn2(prev), input);
  };
}
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error2) {
          for (const observer of observers) {
            observer.error?.(error2);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index3 = observers.findIndex((v4) => v4 === observer);
            if (index3 > -1) {
              observers.splice(index3, 1);
            }
          }
        };
      }
    };
  };
}
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}
function createChain(opts2) {
  return observable((observer) => {
    function execute(index3 = 0, op = opts2.op) {
      const next = opts2.links[index3];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index3 + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
function isObject2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error2 = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error: error2
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject2(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject2(result.result)) {
    throw new TransformResultError();
  }
  return result;
}
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
function isTRPCErrorResponse(obj) {
  return isObject2(obj) && isObject2(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction$1(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction$1(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController$1(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts2) {
  return {
    url: opts2.url.toString().replace(/\/$/, ""),
    fetch: opts2.fetch,
    AbortController: getAbortController$1(opts2.AbortController)
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index3 = 0; index3 < array.length; index3++) {
    const element = array[index3];
    dict[index3] = element;
  }
  return dict;
}
function getInput(opts2) {
  return "input" in opts2 ? opts2.runtime.transformer.serialize(opts2.input) : arrayToDict(opts2.inputs.map((_input) => opts2.runtime.transformer.serialize(_input)));
}
async function fetchHTTPResponse(opts2, ac3) {
  const url = opts2.getUrl(opts2);
  const body = opts2.getBody(opts2);
  const { type } = opts2;
  const resolvedHeaders = await opts2.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts2.contentTypeHeader ? {
      "content-type": opts2.contentTypeHeader
    } : {},
    ...opts2.batchModeHeader ? {
      "trpc-batch-mode": opts2.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts2.fetch)(url, {
    method: METHOD[type],
    signal: ac3?.signal,
    body,
    headers
  });
}
function httpRequest(opts2) {
  const ac3 = opts2.AbortController ? new opts2.AbortController() : null;
  const meta = {};
  let done = false;
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts2, ac3).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      done = true;
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = () => {
    if (!done) {
      ac3?.abort();
    }
  };
  return {
    promise,
    cancel
  };
}
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index3 = 0;
    while (true) {
      const item = items[index3];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index3++;
        continue;
      }
      const isValid3 = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid3) {
        lastGroup.push(item);
        index3++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index3++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = (index3, value) => {
        const item = batch.items[index3];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          unitResolver(i2, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise,
      cancel
    };
  }
  return {
    load
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts2) {
    const resolvedOpts = resolveHTTPLinkOptions(opts2);
    const maxURLLength = opts2.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path,
            inputs
          });
          return url.length <= maxURLLength;
        };
        const fetch2 = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts: opts2
        });
        return {
          validate,
          fetch: fetch2
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise, cancel } = loader.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
function createTRPCClient(opts2) {
  const client = new TRPCUntypedClient(opts2);
  return client;
}
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts2) {
  const client = new TRPCUntypedClient(opts2);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
function getArrayQueryKey(queryKey, type) {
  const queryKeyArrayed = Array.isArray(queryKey) ? queryKey : [
    queryKey
  ];
  const [path, input] = queryKeyArrayed;
  const arrayPath = typeof path !== "string" || path === "" ? [] : path.split(".");
  if (!input && (!type || type === "any"))
    return arrayPath.length ? [
      arrayPath
    ] : [];
  return [
    arrayPath,
    {
      ...typeof input !== "undefined" && {
        input
      },
      ...type && type !== "any" && {
        type
      }
    }
  ];
}
function noop$1() {
  return void 0;
}
function functionalUpdate$1(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function difference(array1, array2) {
  return array1.filter((x4) => !array2.includes(x4));
}
function replaceAt(array, index3, value) {
  const copy = array.slice(0);
  copy[index3] = value;
  return copy;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey
  } = filters;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_3, val) => isPlainObject2(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a2, b2) {
  return partialDeepEqual(a2, b2);
}
function partialDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialDeepEqual(a2[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject2(a2) && isPlainObject2(b2)) {
    const aSize = array ? a2.length : Object.keys(a2).length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array ? i2 : bItems[i2];
      copy[key] = replaceEqualDeep(a2[key], b2[key]);
      if (copy[key] === a2[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (a2 && !b2 || b2 && !a2) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject2(o3) {
  if (!hasObjectPrototype(o3)) {
    return false;
  }
  const ctor = o3.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
  return;
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData;
  } else if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort == null ? void 0 : config.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess == null ? void 0 : config.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError == null ? void 0 : config.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        const canContinue = isResolved || !shouldPause();
        if (canContinue) {
          continueResolve(value);
        }
        return canContinue;
      };
      config.onPause == null ? void 0 : config.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue == null ? void 0 : config.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config.fn();
    } catch (error2) {
      promiseOrValue = Promise.reject(error2);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error2) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error2) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error2);
      if (isRetryCancelled || !shouldRetry) {
        reject(error2);
        return;
      }
      failureCount++;
      config.onFail == null ? void 0 : config.onFail(failureCount, error2);
      sleep(delay).then(() => {
        if (shouldPause()) {
          return pause();
        }
        return;
      }).then(() => {
        if (isRetryCancelled) {
          reject(error2);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      const didContinue = continueFn == null ? void 0 : continueFn();
      return didContinue ? promise : Promise.resolve();
    },
    cancelRetry,
    continueRetry
  };
}
function createNotifyManager() {
  let queue2 = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue2.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue2;
    queue2 = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn2) => {
    notifyFn = fn2;
  };
  const setBatchNotifyFunction = (fn2) => {
    batchNotifyFn = fn2;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = typeof data !== "undefined";
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object2) => {
          Object.defineProperty(object2, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
        const buildNewPages = (pages, param, page6, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page6, ...pages] : [...pages, page6];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page6) => buildNewPages(pages, param, page6, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i2 = 1; i2 < oldPages.length; i2++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}
function hasNextPage(options, pages) {
  if (options.getNextPageParam && Array.isArray(pages)) {
    const nextPageParam = getNextPageParam(options, pages);
    return typeof nextPageParam !== "undefined" && nextPageParam !== null && nextPageParam !== false;
  }
  return;
}
function hasPreviousPage(options, pages) {
  if (options.getPreviousPageParam && Array.isArray(pages)) {
    const previousPageParam = getPreviousPageParam(options, pages);
    return typeof previousPageParam !== "undefined" && previousPageParam !== null && previousPageParam !== false;
  }
  return;
}
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
  if (options.keepPreviousData) {
    return false;
  }
  if (options.placeholderData !== void 0) {
    return optimisticResult.isPlaceholderData;
  }
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
function p$1(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v2(a2, b2, c2, d2, e2, f3, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f3;
  this.removeEmptyString = g;
}
function sa(a2) {
  return a2[1].toUpperCase();
}
function ta(a2, b2, c2, d2) {
  var e2 = z2.hasOwnProperty(b2) ? z2[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l4) {
          var d2 = l4;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l4) {
          d2 = l4;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l4) {
        d2 = l4;
      }
      a2();
    }
  } catch (l4) {
    if (l4 && d2 && "string" === typeof l4.stack) {
      for (var e2 = l4.stack.split("\n"), f3 = d2.stack.split("\n"), g = e2.length - 1, h2 = f3.length - 1; 1 <= g && 0 <= h2 && e2[g] !== f3[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e2[g] !== f3[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e2[g] !== f3[h2]) {
                var k4 = "\n" + e2[g].replace(" at new ", " at ");
                a2.displayName && k4.includes("<anonymous>") && (k4 = k4.replace("<anonymous>", a2.displayName));
                return k4;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f3 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f3.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db2(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$1(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$1(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$1(231, b2, typeof c2));
  return c2;
}
function Nb(a2, b2, c2, d2, e2, f3, g, h2, k4) {
  var l4 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l4);
  } catch (m2) {
    this.onError(m2);
  }
}
function Tb(a2, b2, c2, d2, e2, f3, g, h2, k4) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f3, g, h2, k4) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l4 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l4);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$1(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$1(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f3 = e2.alternate;
    if (null === f3) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f3.child) {
      for (f3 = e2.child; f3; ) {
        if (f3 === c2)
          return Xb(e2), a2;
        if (f3 === d2)
          return Xb(e2), b2;
        f3 = f3.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f3;
    else {
      for (var g = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g = true;
          c2 = e2;
          d2 = f3;
          break;
        }
        if (h2 === d2) {
          g = true;
          d2 = e2;
          c2 = f3;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f3.child; h2; ) {
          if (h2 === c2) {
            g = true;
            c2 = f3;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g = true;
            d2 = f3;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$1(190));
  }
  if (3 !== c2.tag)
    throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f3 = a2.pingedLanes, g = c2 & 268435455;
  if (0 !== g) {
    var h2 = g & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f3 &= g, 0 !== f3 && (d2 = tc(f3)));
  } else
    g = c2 & ~e2, 0 !== g ? d2 = tc(g) : 0 !== f3 && (d2 = tc(f3));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f3 = b2 & -b2, e2 >= f3 || 16 === e2 && 0 !== (f3 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f3 = a2.pendingLanes; 0 < f3; ) {
    var g = 31 - oc(f3), h2 = 1 << g, k4 = e2[g];
    if (-1 === k4) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g] = vc(h2, b2);
    } else
      k4 <= b2 && (a2.expiredLanes |= h2);
    f3 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f3 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f3;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f3) {
  if (null === a2 || a2.nativeEvent !== f3)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f3, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f3 = e2.pointerId;
      Oc.set(f3, Tc(Oc.get(f3) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f3 = e2.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca2.unstable_scheduleCallback(ca2.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
function ed(a2, b2, c2, d2) {
  var e2 = C2, f3 = cd.transition;
  cd.transition = null;
  try {
    C2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C2 = e2, cd.transition = f3;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C2, f3 = cd.transition;
  cd.transition = null;
  try {
    C2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C2 = e2, cd.transition = f3;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$1, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f3 = Cb(e2);
        null !== f3 && Ec(f3);
        f3 = Yc(a2, b2, c2, d2);
        null === f3 && hd(a2, b2, d2, id$1, c2);
        if (f3 === e2)
          break;
        e2 = f3;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
function Yc(a2, b2, c2, d2) {
  id$1 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$1 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f3 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g = c2 - a2;
  for (d2 = 1; d2 <= g && b2[c2 - d2] === e2[f3 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f3, g) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f3;
    this.target = g;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f3) : f3[c2]);
    this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne2(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
function re$1(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
function Ae() {
  pe2 && (pe2.detachEvent("onpropertychange", Be$1), qe = pe2 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe)) {
    var b2 = [];
    ne2(b2, qe, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe2 = b2, qe = c2, pe2.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$1(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f3 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f3 : Math.min(d2.end, e2);
        !a2.extend && f3 > d2 && (e2 = d2, d2 = f3, f3 = e2);
        e2 = Ke(c2, f3);
        var g = Ke(
          c2,
          d2
        );
        e2 && g && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f3 > d2 ? (a2.addRange(b2), a2.extend(g.node, g.offset)) : (b2.setEnd(g.node, g.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie$1(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
function Ze$1(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe[a2] = b2[c2];
  return a2;
}
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f3 = void 0;
      if (b2)
        for (var g = d2.length - 1; 0 <= g; g--) {
          var h2 = d2[g], k4 = h2.instance, l4 = h2.currentTarget;
          h2 = h2.listener;
          if (k4 !== f3 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l4);
          f3 = k4;
        }
      else
        for (g = 0; g < d2.length; g++) {
          h2 = d2[g];
          k4 = h2.instance;
          l4 = h2.currentTarget;
          h2 = h2.listener;
          if (k4 !== f3 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l4);
          f3 = k4;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f3 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g)
            for (g = d2.return; null !== g; ) {
              var k4 = g.tag;
              if (3 === k4 || 4 === k4) {
                if (k4 = g.stateNode.containerInfo, k4 === e2 || 8 === k4.nodeType && k4.parentNode === e2)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k4 = g.tag;
            if (5 === k4 || 6 === k4) {
              d2 = f3 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f3, e3 = xb(c2), g2 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k5 = td, n5 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k5 = Rd;
            break;
          case "focusin":
            n5 = "focus";
            k5 = Fd;
            break;
          case "focusout":
            n5 = "blur";
            k5 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k5 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k5 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k5 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k5 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k5 = Hd;
            break;
          case cf:
            k5 = Xd;
            break;
          case "scroll":
            k5 = vd;
            break;
          case "wheel":
            k5 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k5 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k5 = Td;
        }
        var t5 = 0 !== (b2 & 4), J3 = !t5 && "scroll" === a2, x4 = t5 ? null !== h3 ? h3 + "Capture" : null : h3;
        t5 = [];
        for (var w5 = d3, u4; null !== w5; ) {
          u4 = w5;
          var F4 = u4.stateNode;
          5 === u4.tag && null !== F4 && (u4 = F4, null !== x4 && (F4 = Kb(w5, x4), null != F4 && t5.push(tf(w5, F4, u4))));
          if (J3)
            break;
          w5 = w5.return;
        }
        0 < t5.length && (h3 = new k5(h3, n5, null, c2, e3), g2.push({ event: h3, listeners: t5 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k5 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n5 = c2.relatedTarget || c2.fromElement) && (Wc(n5) || n5[uf]))
          break a;
        if (k5 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k5) {
            if (n5 = c2.relatedTarget || c2.toElement, k5 = d3, n5 = n5 ? Wc(n5) : null, null !== n5 && (J3 = Vb(n5), n5 !== J3 || 5 !== n5.tag && 6 !== n5.tag))
              n5 = null;
          } else
            k5 = null, n5 = d3;
          if (k5 !== n5) {
            t5 = Bd;
            F4 = "onMouseLeave";
            x4 = "onMouseEnter";
            w5 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t5 = Td, F4 = "onPointerLeave", x4 = "onPointerEnter", w5 = "pointer";
            J3 = null == k5 ? h3 : ue$1(k5);
            u4 = null == n5 ? h3 : ue$1(n5);
            h3 = new t5(F4, w5 + "leave", k5, c2, e3);
            h3.target = J3;
            h3.relatedTarget = u4;
            F4 = null;
            Wc(e3) === d3 && (t5 = new t5(x4, w5 + "enter", n5, c2, e3), t5.target = u4, t5.relatedTarget = J3, F4 = t5);
            J3 = F4;
            if (k5 && n5)
              b: {
                t5 = k5;
                x4 = n5;
                w5 = 0;
                for (u4 = t5; u4; u4 = vf(u4))
                  w5++;
                u4 = 0;
                for (F4 = x4; F4; F4 = vf(F4))
                  u4++;
                for (; 0 < w5 - u4; )
                  t5 = vf(t5), w5--;
                for (; 0 < u4 - w5; )
                  x4 = vf(x4), u4--;
                for (; w5--; ) {
                  if (t5 === x4 || null !== x4 && t5 === x4.alternate)
                    break b;
                  t5 = vf(t5);
                  x4 = vf(x4);
                }
                t5 = null;
              }
            else
              t5 = null;
            null !== k5 && wf(g2, h3, k5, t5, false);
            null !== n5 && null !== J3 && wf(g2, J3, n5, t5, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k5 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k5 || "input" === k5 && "file" === h3.type)
          var na2 = ve;
        else if (me$1(h3))
          if (we)
            na2 = Fe$1;
          else {
            na2 = De$1;
            var xa2 = Ce$1;
          }
        else
          (k5 = h3.nodeName) && "input" === k5.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee);
        if (na2 && (na2 = na2(a2, d3))) {
          ne2(g2, na2, c2, e3);
          break a;
        }
        xa2 && xa2(a2, h3, d3);
        "focusout" === a2 && (xa2 = h3._wrapperState) && xa2.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa2 = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa2) || "true" === xa2.contentEditable)
            Qe$1 = xa2, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe$1 = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue$1(g2, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g2, c2, e3);
      }
      var $a2;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba2 = "onCompositionStart";
              break b;
            case "compositionend":
              ba2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba2 = "onCompositionUpdate";
              break b;
          }
          ba2 = void 0;
        }
      else
        ie$1 ? ge(a2, c2) && (ba2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba2 = "onCompositionStart");
      ba2 && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie$1 && ($a2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa2 = oe(d3, ba2), 0 < xa2.length && (ba2 = new Ld(ba2, a2, null, c2, e3), g2.push({ event: ba2, listeners: xa2 }), $a2 ? ba2.data = $a2 : ($a2 = he(c2), null !== $a2 && (ba2.data = $a2))));
      if ($a2 = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g2.push({ event: e3, listeners: d3 }), e3.data = $a2);
    }
    se$1(g2, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f3 = e2.stateNode;
    5 === e2.tag && null !== f3 && (e2 = f3, f3 = Kb(a2, c2), null != f3 && d2.unshift(tf(a2, f3, e2)), f3 = Kb(a2, b2), null != f3 && d2.push(tf(a2, f3, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f3 = b2._reactName, g = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k4 = h2.alternate, l4 = h2.stateNode;
    if (null !== k4 && k4 === d2)
      break;
    5 === h2.tag && null !== l4 && (h2 = l4, e2 ? (k4 = Kb(c2, f3), null != k4 && g.unshift(tf(c2, k4, h2))) : e2 || (k4 = Kb(c2, f3), null != k4 && g.push(tf(c2, k4, h2))));
    c2 = c2.return;
  }
  0 !== g.length && a2.push({ event: b2, listeners: g });
}
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$1(425));
}
function Bf() {
}
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$1(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G2(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f3;
  for (f3 in c2)
    e2[f3] = b2[f3];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$1(168));
  G2(H, b2);
  G2(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$1(108, Ra(a2) || "Unknown", e2));
  return A2({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G2(H, a2);
  G2(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$1(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H), G2(H, a2)) : E$1(Wf);
  G2(Wf, c2);
}
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C2;
    try {
      var c2 = eg;
      for (C2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C2 = b2, gg = false;
    }
  }
  return null;
}
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f3 = 32 - oc(b2) + e2;
  if (30 < f3) {
    var g = e2 - e2 % 5;
    f3 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    e2 -= g;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f3 + a2;
  } else
    rg = 1 << f3 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$1(418));
      a2.flags = a2.flags & -4097 | 2;
      I2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I2)
    return Fg(a2), I2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$1(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$1(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A2({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$1(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f3 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f3 ? e2 = f3 = g : f3 = f3.next = g;
        c2 = c2.next;
      } while (null !== c2);
      null === f3 ? e2 = f3 = b2 : f3 = f3.next = b2;
    } else
      e2 = f3 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f3, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f3 = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k4 = h2, l4 = k4.next;
    k4.next = null;
    null === g ? f3 = l4 : g.next = l4;
    g = k4;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l4 : h2.next = l4, m2.lastBaseUpdate = k4));
  }
  if (null !== f3) {
    var q2 = e2.baseState;
    g = 0;
    m2 = l4 = k4 = null;
    h2 = f3;
    do {
      var r5 = h2.lane, y3 = h2.eventTime;
      if ((d2 & r5) === r5) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y3,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n5 = a2, t5 = h2;
          r5 = b2;
          y3 = c2;
          switch (t5.tag) {
            case 1:
              n5 = t5.payload;
              if ("function" === typeof n5) {
                q2 = n5.call(y3, q2, r5);
                break a;
              }
              q2 = n5;
              break a;
            case 3:
              n5.flags = n5.flags & -65537 | 128;
            case 0:
              n5 = t5.payload;
              r5 = "function" === typeof n5 ? n5.call(y3, q2, r5) : n5;
              if (null === r5 || void 0 === r5)
                break a;
              q2 = A2({}, q2, r5);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r5 = e2.effects, null === r5 ? e2.effects = [h2] : r5.push(h2));
      } else
        y3 = { eventTime: y3, lane: r5, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l4 = m2 = y3, k4 = q2) : m2 = m2.next = y3, g |= r5;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r5 = h2, h2 = r5.next, r5.next = null, e2.lastBaseUpdate = r5, e2.shared.pending = null;
    } while (1);
    null === m2 && (k4 = q2);
    e2.baseState = k4;
    e2.firstBaseUpdate = l4;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f3 && (e2.shared.lanes = 0);
    hh |= g;
    a2.lanes = g;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$1(191, e2));
        e2.call(d2);
      }
    }
}
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A2({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
function oh(a2, b2, c2, d2, e2, f3, g) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f3, g) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f3) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f3 = b2.contextType;
  "object" === typeof f3 && null !== f3 ? f3 = Vg(f3) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f3 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f3);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f3);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f3 = b2.contextType;
  "object" === typeof f3 && null !== f3 ? e2.context = Vg(f3) : (f3 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f3));
  e2.state = a2.memoizedState;
  f3 = b2.getDerivedStateFromProps;
  "function" === typeof f3 && (kh(a2, b2, f3, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$1(147, a2));
      var e2 = d2, f3 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f3)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f3] : b3[f3] = a3;
      };
      b2._stringRef = f3;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$1(284));
    if (!c2._owner)
      throw Error(p$1(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f3(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k4(a3, b3, c3, d3) {
    var f4 = c3.type;
    if (f4 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f4 || "object" === typeof f4 && null !== f4 && f4.$$typeof === Ha && uh(f4) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l4(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f4) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f4), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r5(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k4(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l4(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r5(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y3(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k4(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l4(b3, a3, d3, e3);
        case Ha:
          var f4 = d3._init;
          return y3(a3, b3, c3, f4(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n5(e3, g2, h3, k5) {
    for (var l5 = null, m3 = null, u4 = g2, w5 = g2 = 0, x4 = null; null !== u4 && w5 < h3.length; w5++) {
      u4.index > w5 ? (x4 = u4, u4 = null) : x4 = u4.sibling;
      var n6 = r5(e3, u4, h3[w5], k5);
      if (null === n6) {
        null === u4 && (u4 = x4);
        break;
      }
      a2 && u4 && null === n6.alternate && b2(e3, u4);
      g2 = f3(n6, g2, w5);
      null === m3 ? l5 = n6 : m3.sibling = n6;
      m3 = n6;
      u4 = x4;
    }
    if (w5 === h3.length)
      return c2(e3, u4), I2 && tg(e3, w5), l5;
    if (null === u4) {
      for (; w5 < h3.length; w5++)
        u4 = q2(e3, h3[w5], k5), null !== u4 && (g2 = f3(u4, g2, w5), null === m3 ? l5 = u4 : m3.sibling = u4, m3 = u4);
      I2 && tg(e3, w5);
      return l5;
    }
    for (u4 = d2(e3, u4); w5 < h3.length; w5++)
      x4 = y3(u4, e3, w5, h3[w5], k5), null !== x4 && (a2 && null !== x4.alternate && u4.delete(null === x4.key ? w5 : x4.key), g2 = f3(x4, g2, w5), null === m3 ? l5 = x4 : m3.sibling = x4, m3 = x4);
    a2 && u4.forEach(function(a3) {
      return b2(e3, a3);
    });
    I2 && tg(e3, w5);
    return l5;
  }
  function t5(e3, g2, h3, k5) {
    var l5 = Ka(h3);
    if ("function" !== typeof l5)
      throw Error(p$1(150));
    h3 = l5.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u4 = l5 = null, m3 = g2, w5 = g2 = 0, x4 = null, n6 = h3.next(); null !== m3 && !n6.done; w5++, n6 = h3.next()) {
      m3.index > w5 ? (x4 = m3, m3 = null) : x4 = m3.sibling;
      var t6 = r5(e3, m3, n6.value, k5);
      if (null === t6) {
        null === m3 && (m3 = x4);
        break;
      }
      a2 && m3 && null === t6.alternate && b2(e3, m3);
      g2 = f3(t6, g2, w5);
      null === u4 ? l5 = t6 : u4.sibling = t6;
      u4 = t6;
      m3 = x4;
    }
    if (n6.done)
      return c2(
        e3,
        m3
      ), I2 && tg(e3, w5), l5;
    if (null === m3) {
      for (; !n6.done; w5++, n6 = h3.next())
        n6 = q2(e3, n6.value, k5), null !== n6 && (g2 = f3(n6, g2, w5), null === u4 ? l5 = n6 : u4.sibling = n6, u4 = n6);
      I2 && tg(e3, w5);
      return l5;
    }
    for (m3 = d2(e3, m3); !n6.done; w5++, n6 = h3.next())
      n6 = y3(m3, e3, w5, n6.value, k5), null !== n6 && (a2 && null !== n6.alternate && m3.delete(null === n6.key ? w5 : n6.key), g2 = f3(n6, g2, w5), null === u4 ? l5 = n6 : u4.sibling = n6, u4 = n6);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I2 && tg(e3, w5);
    return l5;
  }
  function J3(a3, d3, f4, h3) {
    "object" === typeof f4 && null !== f4 && f4.type === ya && null === f4.key && (f4 = f4.props.children);
    if ("object" === typeof f4 && null !== f4) {
      switch (f4.$$typeof) {
        case va:
          a: {
            for (var k5 = f4.key, l5 = d3; null !== l5; ) {
              if (l5.key === k5) {
                k5 = f4.type;
                if (k5 === ya) {
                  if (7 === l5.tag) {
                    c2(a3, l5.sibling);
                    d3 = e2(l5, f4.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l5.elementType === k5 || "object" === typeof k5 && null !== k5 && k5.$$typeof === Ha && uh(k5) === l5.type) {
                  c2(a3, l5.sibling);
                  d3 = e2(l5, f4.props);
                  d3.ref = sh(a3, l5, f4);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l5);
                break;
              } else
                b2(a3, l5);
              l5 = l5.sibling;
            }
            f4.type === ya ? (d3 = Ah(f4.props.children, a3.mode, h3, f4.key), d3.return = a3, a3 = d3) : (h3 = yh(f4.type, f4.key, f4.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f4), h3.return = a3, a3 = h3);
          }
          return g(a3);
        case wa:
          a: {
            for (l5 = f4.key; null !== d3; ) {
              if (d3.key === l5)
                if (4 === d3.tag && d3.stateNode.containerInfo === f4.containerInfo && d3.stateNode.implementation === f4.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f4.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f4, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g(a3);
        case Ha:
          return l5 = f4._init, J3(a3, d3, l5(f4._payload), h3);
      }
      if (eb(f4))
        return n5(a3, d3, f4, h3);
      if (Ka(f4))
        return t5(a3, d3, f4, h3);
      th(a3, f4);
    }
    return "string" === typeof f4 && "" !== f4 || "number" === typeof f4 ? (f4 = "" + f4, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f4), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f4, a3.mode, h3), d3.return = a3, a3 = d3), g(a3)) : c2(a3, d3);
  }
  return J3;
}
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$1(174));
  return a2;
}
function Ih(a2, b2) {
  G2(Gh, b2);
  G2(Fh, a2);
  G2(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh);
  G2(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G2(Fh, a2), G2(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
function Q$1() {
  throw Error(p$1(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f3) {
  Rh = f3;
  N2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f3 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f3)
        throw Error(p$1(301));
      f3 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N2 = null;
  Sh = false;
  if (b2)
    throw Error(p$1(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O$1) {
    var a2 = N2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$1 ? N2.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$1(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f3 = c2.pending;
  if (null !== f3) {
    if (null !== e2) {
      var g = e2.next;
      e2.next = f3.next;
      f3.next = g;
    }
    d2.baseQueue = e2 = f3;
    c2.pending = null;
  }
  if (null !== e2) {
    f3 = e2.next;
    d2 = d2.baseState;
    var h2 = g = null, k4 = null, l4 = f3;
    do {
      var m2 = l4.lane;
      if ((Rh & m2) === m2)
        null !== k4 && (k4 = k4.next = { lane: 0, action: l4.action, hasEagerState: l4.hasEagerState, eagerState: l4.eagerState, next: null }), d2 = l4.hasEagerState ? l4.eagerState : a2(d2, l4.action);
      else {
        var q2 = {
          lane: m2,
          action: l4.action,
          hasEagerState: l4.hasEagerState,
          eagerState: l4.eagerState,
          next: null
        };
        null === k4 ? (h2 = k4 = q2, g = d2) : k4 = k4.next = q2;
        N2.lanes |= m2;
        hh |= m2;
      }
      l4 = l4.next;
    } while (null !== l4 && l4 !== f3);
    null === k4 ? g = d2 : k4.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g;
    b2.baseQueue = k4;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f3 = e2.lane, N2.lanes |= f3, hh |= f3, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f3 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g = e2 = e2.next;
    do
      f3 = a2(f3, g.action), g = g.next;
    while (g !== e2);
    He$1(f3, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f3;
    null === b2.baseQueue && (b2.baseState = f3);
    c2.lastRenderedState = f3;
  }
  return [f3, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N2, d2 = di(), e2 = b2(), f3 = !He$1(d2.memoizedState, e2);
  f3 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f3 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R2)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N2, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f3 = void 0;
  if (null !== O$1) {
    var g = O$1.memoizedState;
    f3 = g.destroy;
    if (null !== d2 && Wh(d2, g.deps)) {
      e2.memoizedState = li(b2, c2, f3, d2);
      return;
    }
  }
  N2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f3, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C2;
  C2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C2 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$1();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f3 = a2.alternate;
    if (0 === a2.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b2.lastRenderedReducer, null !== f3))
      try {
        var g = b2.lastRenderedState, h2 = f3(g, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g)) {
          var k4 = b2.interleaved;
          null === k4 ? (e2.next = e2, Xg(b2)) : (e2.next = k4.next, k4.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l4) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$1(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N2 || null !== b2 && b2 === N2;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f3) {
    e2 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f3 = a2.stateNode;
  null !== f3 && "function" === typeof f3.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f3 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f3, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f3 = c2.type;
    if ("function" === typeof f3 && !bj(f3) && void 0 === f3.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f3, cj(a2, b2, f3, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f3 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g = f3.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f3, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f3 = a2.memoizedProps;
    if (Ie$1(f3, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f3, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f3 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f3 ? f3.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f3 ? f3.baseLanes : c2;
      G2(fj, gj);
      gj |= d2;
    }
  else
    null !== f3 ? (d2 = f3.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G2(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f3 = Zf(c2) ? Xf : H.current;
  f3 = Yf(b2, f3);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f3, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I2 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f3 = true;
    cg(b2);
  } else
    f3 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g = b2.stateNode, h2 = b2.memoizedProps;
    g.props = h2;
    var k4 = g.context, l4 = c2.contextType;
    "object" === typeof l4 && null !== l4 ? l4 = Vg(l4) : (l4 = Zf(c2) ? Xf : H.current, l4 = Yf(b2, l4));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d2 || k4 !== l4) && qh(b2, g, d2, l4);
    $g = false;
    var r5 = b2.memoizedState;
    g.state = r5;
    gh(b2, d2, g, e2);
    k4 = b2.memoizedState;
    h2 !== d2 || r5 !== k4 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k4 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r5, k4, l4)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k4), g.props = d2, g.state = k4, g.context = l4, d2 = h2) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l4 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g.props = l4;
    q2 = b2.pendingProps;
    r5 = g.context;
    k4 = c2.contextType;
    "object" === typeof k4 && null !== k4 ? k4 = Vg(k4) : (k4 = Zf(c2) ? Xf : H.current, k4 = Yf(b2, k4));
    var y3 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y3 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r5 !== k4) && qh(b2, g, d2, k4);
    $g = false;
    r5 = b2.memoizedState;
    g.state = r5;
    gh(b2, d2, g, e2);
    var n5 = b2.memoizedState;
    h2 !== q2 || r5 !== n5 || Wf.current || $g ? ("function" === typeof y3 && (kh(b2, c2, y3, d2), n5 = b2.memoizedState), (l4 = $g || oh(b2, c2, l4, d2, r5, n5, k4) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n5, k4), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n5, k4)), "function" === typeof g.componentDidUpdate && (b2.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r5 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r5 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n5), g.props = d2, g.state = n5, g.context = k4, d2 = l4) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r5 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r5 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f3, e2);
}
function kj(a2, b2, c2, d2, e2, f3) {
  hj(a2, b2);
  var g = 0 !== (b2.flags & 128);
  if (!d2 && !g)
    return e2 && dg(b2, c2, false), $i(a2, b2, f3);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g ? (b2.child = Bh(b2, a2.child, null, f3), b2.child = Bh(b2, null, h2, f3)) : Yi(a2, b2, h2, f3);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M.current, f3 = false, g = 0 !== (b2.flags & 128), h2;
  (h2 = g) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f3 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G2(M, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g = d2.children;
    a2 = d2.fallback;
    return f3 ? (d2 = b2.mode, f3 = b2.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g) : f3 = qj(g, d2, 0, null), a2 = Ah(a2, d2, c2, null), f3.return = b2, a2.return = b2, f3.sibling = a2, b2.child = f3, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g, d2, h2, e2, c2);
  if (f3) {
    f3 = d2.fallback;
    g = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k4 = { mode: "hidden", children: d2.children };
    0 === (g & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k4, b2.deletions = null) : (d2 = wh(e2, k4), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f3 = wh(h2, f3) : (f3 = Ah(f3, g, c2, null), f3.flags |= 2);
    f3.return = b2;
    d2.return = b2;
    d2.sibling = f3;
    b2.child = d2;
    d2 = f3;
    f3 = b2.child;
    g = a2.child.memoizedState;
    g = null === g ? oj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
    f3.memoizedState = g;
    f3.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f3 = a2.child;
  a2 = f3.sibling;
  d2 = wh(f3, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f3, g) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a2, b2, g, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f3 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f3 = Ah(f3, e2, g, null);
    f3.flags |= 2;
    d2.return = b2;
    f3.return = b2;
    d2.sibling = f3;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g);
    b2.child.memoizedState = oj(g);
    b2.memoizedState = nj;
    return f3;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f3 = Error(p$1(419));
    d2 = Li(f3, d2, void 0);
    return tj(a2, b2, g, d2);
  }
  h2 = 0 !== (g & a2.childLanes);
  if (Ug || h2) {
    d2 = R2;
    if (null !== d2) {
      switch (g & -g) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g)) ? 0 : e2;
      0 !== e2 && e2 !== f3.retryLane && (f3.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$1(421)));
    return tj(a2, b2, g, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f3.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f3 = a2.memoizedState;
  null === f3 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f3.isBackwards = b2, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d2, f3.tail = c2, f3.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f3 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G2(M, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f3);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f3);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$1(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G2(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G2(M, M.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G2(M, M.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G2(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G2(M, M.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
function Ej(a2, b2) {
  if (!I2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S2(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S2(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S2(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$1(166));
          S2(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f3 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f3;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f3);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f3.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f3), D$1("invalid", d2);
          }
          ub(c2, f3);
          e2 = null;
          for (var g in f3)
            if (f3.hasOwnProperty(g)) {
              var h2 = f3[g];
              "children" === g ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f3.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f3.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db2(d2, f3, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f3.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g.createElement(c2, { is: d2.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a2 = g.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$1("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A2({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f3 in h2)
              if (h2.hasOwnProperty(f3)) {
                var k4 = h2[f3];
                "style" === f3 ? sb(a2, k4) : "dangerouslySetInnerHTML" === f3 ? (k4 = k4 ? k4.__html : void 0, null != k4 && nb(a2, k4)) : "children" === f3 ? "string" === typeof k4 ? ("textarea" !== c2 || "" !== k4) && ob(a2, k4) : "number" === typeof k4 && ob(a2, "" + k4) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k4 && "onScroll" === f3 && D$1("scroll", a2) : null != k4 && ta(a2, f3, k4, g));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db2(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f3 = d2.value;
                null != f3 ? fb(a2, !!d2.multiple, f3, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S2(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$1(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f3 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f3 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S2(b2);
      return null;
    case 13:
      E$1(M);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f3 = false;
        else if (f3 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f3)
              throw Error(p$1(318));
            f3 = b2.memoizedState;
            f3 = null !== f3 ? f3.dehydrated : null;
            if (!f3)
              throw Error(p$1(317));
            f3[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S2(b2);
          f3 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f3 = true;
        if (!f3)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M.current & 1) ? 0 === T2 && (T2 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S2(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S2(b2), null;
    case 10:
      return Rg(b2.type._context), S2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S2(b2), null;
    case 19:
      E$1(M);
      f3 = b2.memoizedState;
      if (null === f3)
        return S2(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g = f3.rendering;
      if (null === g)
        if (d2)
          Ej(f3, false);
        else {
          if (0 !== T2 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g = Mh(a2);
              if (null !== g) {
                b2.flags |= 128;
                Ej(f3, false);
                d2 = g.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f3 = c2, a2 = d2, f3.flags &= 14680066, g = f3.alternate, null === g ? (f3.childLanes = 0, f3.lanes = a2, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g.childLanes, f3.lanes = g.lanes, f3.child = g.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g.memoizedProps, f3.memoizedState = g.memoizedState, f3.updateQueue = g.updateQueue, f3.type = g.type, a2 = g.dependencies, f3.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G2(M, M.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f3.tail && B2() > Hj && (b2.flags |= 128, d2 = true, Ej(f3, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g.alternate && !I2)
              return S2(b2), null;
          } else
            2 * B2() - f3.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f3, false), b2.lanes = 4194304);
        f3.isBackwards ? (g.sibling = b2.child, b2.child = g) : (c2 = f3.last, null !== c2 ? c2.sibling = g : b2.child = g, f3.last = g);
      }
      if (null !== f3.tail)
        return b2 = f3.tail, f3.rendering = b2, f3.tail = b2.sibling, f3.renderingStartTime = B2(), b2.sibling = null, c2 = M.current, G2(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S2(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W2(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W2(a2, b2, d2);
  }
}
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f3 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f3.nodeType;
          } catch (F4) {
            c2 = null;
            break a;
          }
          var g = 0, h2 = -1, k4 = -1, l4 = 0, m2 = 0, q2 = a2, r5 = null;
          b:
            for (; ; ) {
              for (var y3; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g + e2);
                q2 !== f3 || 0 !== d2 && 3 !== q2.nodeType || (k4 = g + d2);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y3 = q2.firstChild))
                  break;
                r5 = q2;
                q2 = y3;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r5 === c2 && ++l4 === e2 && (h2 = g);
                r5 === f3 && ++m2 === d2 && (k4 = g);
                if (null !== (y3 = q2.nextSibling))
                  break;
                q2 = r5;
                r5 = q2.parentNode;
              }
              q2 = y3;
            }
          c2 = -1 === h2 || -1 === k4 ? null : { start: h2, end: k4 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V = a2;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n5 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n5) {
                  var t5 = n5.memoizedProps, J3 = n5.memoizedState, x4 = b2.stateNode, w5 = x4.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t5 : Lg(b2.type, t5), J3);
                  x4.__reactInternalSnapshotBeforeUpdate = w5;
                }
                break;
              case 3:
                var u4 = b2.stateNode.containerInfo;
                1 === u4.nodeType ? u4.textContent = "" : 9 === u4.nodeType && u4.documentElement && u4.removeChild(u4.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F4) {
          W2(b2, b2.return, F4);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V = a2;
          break;
        }
        V = b2.return;
      }
  n5 = Oj;
  Oj = false;
  return n5;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f3 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f3 && Nj(b2, c2, f3);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e2 = Yj;
      X$2 = null;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2;
      e2 = Yj;
      X$2 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f3 = e2, g = f3.destroy;
          f3 = f3.tag;
          void 0 !== g && (0 !== (f3 & 2) ? Nj(c2, b2, g) : 0 !== (f3 & 4) && Nj(c2, b2, g));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W2(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f3 = a2, g = b2, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$2)
          throw Error(p$1(160));
        ak(f3, g, e2);
        X$2 = null;
        Yj = false;
        var k4 = e2.alternate;
        null !== k4 && (k4.return = null);
        e2.return = null;
      } catch (l4) {
        W2(e2, b2, l4);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t5) {
          W2(a2, a2.return, t5);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t5) {
          W2(a2, a2.return, t5);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t5) {
          W2(a2, a2.return, t5);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f3 = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f3, h2 = a2.type, k4 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k4)
          try {
            "input" === h2 && "radio" === f3.type && null != f3.name && ab(e2, f3);
            vb(h2, g);
            var l4 = vb(h2, f3);
            for (g = 0; g < k4.length; g += 2) {
              var m2 = k4[g], q2 = k4[g + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l4);
            }
            switch (h2) {
              case "input":
                bb(e2, f3);
                break;
              case "textarea":
                ib(e2, f3);
                break;
              case "select":
                var r5 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f3.multiple;
                var y3 = f3.value;
                null != y3 ? fb(e2, !!f3.multiple, y3, false) : r5 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                  e2,
                  !!f3.multiple,
                  f3.defaultValue,
                  true
                ) : fb(e2, !!f3.multiple, f3.multiple ? [] : "", false));
            }
            e2[Pf] = f3;
          } catch (t5) {
            W2(a2, a2.return, t5);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$1(162));
        e2 = a2.stateNode;
        f3 = a2.memoizedProps;
        try {
          e2.nodeValue = f3;
        } catch (t5) {
          W2(a2, a2.return, t5);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t5) {
          W2(a2, a2.return, t5);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f3 = null !== e2.memoizedState, e2.stateNode.isHidden = f3, !f3 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B2()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l4 = U$1) || m2, dk(b2, a2), U$1 = l4) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l4 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l4) && !m2 && 0 !== (a2.mode & 1))
          for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r5 = V;
              y3 = r5.child;
              switch (r5.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r5, r5.return);
                  break;
                case 1:
                  Mj(r5, r5.return);
                  var n5 = r5.stateNode;
                  if ("function" === typeof n5.componentWillUnmount) {
                    d2 = r5;
                    c2 = r5.return;
                    try {
                      b2 = d2, n5.props = b2.memoizedProps, n5.state = b2.memoizedState, n5.componentWillUnmount();
                    } catch (t5) {
                      W2(d2, c2, t5);
                    }
                  }
                  break;
                case 5:
                  Mj(r5, r5.return);
                  break;
                case 22:
                  if (null !== r5.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y3 ? (y3.return = r5, V = y3) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l4 ? (f3 = e2.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h2 = q2.stateNode, k4 = q2.memoizedProps.style, g = void 0 !== k4 && null !== k4 && k4.hasOwnProperty("display") ? k4.display : null, h2.style.display = rb("display", g));
                } catch (t5) {
                  W2(a2, a2.return, t5);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l4 ? "" : q2.memoizedProps;
                } catch (t5) {
                  W2(a2, a2.return, t5);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f3 = Vj(a2);
          Xj(a2, f3, e2);
          break;
        case 3:
        case 4:
          var g = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k4) {
      W2(a2, a2.return, k4);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f3 = e2.child;
    if (22 === e2.tag && d2) {
      var g = null !== e2.memoizedState || Kj;
      if (!g) {
        var h2 = e2.alternate, k4 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l4 = U$1;
        Kj = g;
        if ((U$1 = k4) && !l4)
          for (V = e2; null !== V; )
            g = V, k4 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e2) : null !== k4 ? (k4.return = g, V = k4) : kk(e2);
        for (; null !== f3; )
          V = f3, jk(f3), f3 = f3.sibling;
        V = e2;
        Kj = h2;
        U$1 = l4;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f3 ? (f3.return = e2, V = f3) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f3 = b2.updateQueue;
              null !== f3 && ih(b2, f3, d2);
              break;
            case 3:
              var g = b2.updateQueue;
              if (null !== g) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k4 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k4.autoFocus && c2.focus();
                    break;
                  case "img":
                    k4.src && (c2.src = k4.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l4 = b2.alternate;
                if (null !== l4) {
                  var m2 = l4.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r5) {
        W2(b2, b2.return, r5);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k4) {
            W2(b2, c2, k4);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k4) {
              W2(b2, e2, k4);
            }
          }
          var f3 = b2.return;
          try {
            Sj(b2);
          } catch (k4) {
            W2(b2, f3, k4);
          }
          break;
        case 5:
          var g = b2.return;
          try {
            Sj(b2);
          } catch (k4) {
            W2(b2, g, k4);
          }
      }
    } catch (k4) {
      W2(b2, b2.return, k4);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
function L$1() {
  return 0 !== (K$1 & 6) ? B2() : -1 !== Bk ? Bk : Bk = B2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R2)
    a2 === R2 && (0 === (K$1 & 2) && (rk |= c2), 4 === T2 && Dk(a2, Z)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R2 ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$1(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R2 ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f3 = Kk();
    if (R2 !== a2 || Z !== b2)
      vk = null, Hj = B2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f3;
    K$1 = e2;
    null !== Y ? b2 = 0 : (R2 = null, Z = 0, b2 = T2);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B2()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f3 = xc(a2), 0 !== f3 && (d2 = f3, b2 = Ok(a2, f3))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$1();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g = 31 - oc(d2);
            f3 = 1 << g;
            g = b2[g];
            g > e2 && (e2 = g);
            d2 &= ~f3;
          }
          d2 = e2;
          d2 = B2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a2, B2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f3 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f3(), e2))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$1(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B2()), c2;
  if (6 === c2)
    throw Error(p$1(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C2;
  try {
    if (pk.transition = null, C2 = 1, a2)
      return a2();
  } finally {
    C2 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M);
          break;
        case 19:
          E$1(M);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R2 = a2;
  Y = a2 = wh(a2.current, null);
  Z = gj = b2;
  T2 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f3 = c2.pending;
        if (null !== f3) {
          var g = f3.next;
          f3.next = e2;
          d2.next = g;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N2.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T2 = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f3 = a2, g = c2.return, h2 = c2, k4 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k4 && "object" === typeof k4 && "function" === typeof k4.then) {
          var l4 = k4, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r5 = m2.alternate;
            r5 ? (m2.updateQueue = r5.updateQueue, m2.memoizedState = r5.memoizedState, m2.lanes = r5.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y3 = Vi(g);
          if (null !== y3) {
            y3.flags &= -257;
            Wi(y3, g, h2, f3, b2);
            y3.mode & 1 && Ti(f3, l4, b2);
            b2 = y3;
            k4 = l4;
            var n5 = b2.updateQueue;
            if (null === n5) {
              var t5 = /* @__PURE__ */ new Set();
              t5.add(k4);
              b2.updateQueue = t5;
            } else
              n5.add(k4);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f3, l4, b2);
              uj();
              break a;
            }
            k4 = Error(p$1(426));
          }
        } else if (I2 && h2.mode & 1) {
          var J3 = Vi(g);
          if (null !== J3) {
            0 === (J3.flags & 65536) && (J3.flags |= 256);
            Wi(J3, g, h2, f3, b2);
            Jg(Ki(k4, h2));
            break a;
          }
        }
        f3 = k4 = Ki(k4, h2);
        4 !== T2 && (T2 = 2);
        null === tk ? tk = [f3] : tk.push(f3);
        f3 = g;
        do {
          switch (f3.tag) {
            case 3:
              f3.flags |= 65536;
              b2 &= -b2;
              f3.lanes |= b2;
              var x4 = Oi(f3, k4, b2);
              fh(f3, x4);
              break a;
            case 1:
              h2 = k4;
              var w5 = f3.type, u4 = f3.stateNode;
              if (0 === (f3.flags & 128) && ("function" === typeof w5.getDerivedStateFromError || null !== u4 && "function" === typeof u4.componentDidCatch && (null === Si || !Si.has(u4)))) {
                f3.flags |= 65536;
                b2 &= -b2;
                f3.lanes |= b2;
                var F4 = Ri(f3, h2, b2);
                fh(f3, F4);
                break a;
              }
          }
          f3 = f3.return;
        } while (null !== f3);
      }
      Tk(c2);
    } catch (na2) {
      b2 = na2;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T2 || 3 === T2 || 2 === T2)
    T2 = 4;
  null === R2 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R2, Z);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R2 !== a2 || Z !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$1(261));
  R2 = null;
  Z = 0;
  return T2;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T2 = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T2 && (T2 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C2, e2 = pk.transition;
  try {
    pk.transition = null, C2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$1(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$1(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f3 = c2.lanes | c2.childLanes;
  Bc(a2, f3);
  a2 === R2 && (Y = R2 = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f3 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f3) {
    f3 = pk.transition;
    pk.transition = null;
    var g = C2;
    C2 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C2 = g;
    pk.transition = f3;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f3 = a2.pendingLanes;
  0 === f3 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B2());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f3 = a2.pendingLanes;
  0 !== (f3 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C2;
    try {
      pk.transition = null;
      C2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$1(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V = a2.current; null !== V; ) {
          var f3 = V, g = f3.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f3.deletions;
            if (null !== h2) {
              for (var k4 = 0; k4 < h2.length; k4++) {
                var l4 = h2[k4];
                for (V = l4; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f3);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r5 = m2.sibling, y3 = m2.return;
                      Tj(m2);
                      if (m2 === l4) {
                        V = null;
                        break;
                      }
                      if (null !== r5) {
                        r5.return = y3;
                        V = r5;
                        break;
                      }
                      V = y3;
                    }
                }
              }
              var n5 = f3.alternate;
              if (null !== n5) {
                var t5 = n5.child;
                if (null !== t5) {
                  n5.child = null;
                  do {
                    var J3 = t5.sibling;
                    t5.sibling = null;
                    t5 = J3;
                  } while (null !== t5);
                }
              }
              V = f3;
            }
          }
          if (0 !== (f3.subtreeFlags & 2064) && null !== g)
            g.return = f3, V = g;
          else
            b:
              for (; null !== V; ) {
                f3 = V;
                if (0 !== (f3.flags & 2048))
                  switch (f3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f3, f3.return);
                  }
                var x4 = f3.sibling;
                if (null !== x4) {
                  x4.return = f3.return;
                  V = x4;
                  break b;
                }
                V = f3.return;
              }
        }
        var w5 = a2.current;
        for (V = w5; null !== V; ) {
          g = V;
          var u4 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u4)
            u4.return = g, V = u4;
          else
            b:
              for (g = w5; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na2) {
                    W2(h2, h2.return, na2);
                  }
                if (h2 === g) {
                  V = null;
                  break b;
                }
                var F4 = h2.sibling;
                if (null !== F4) {
                  F4.return = h2.return;
                  V = F4;
                  break b;
                }
                V = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na2) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$1();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W2(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$1();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$1();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R2 === a2 && (Z & c2) === c2 && (4 === T2 || 3 === T2 && (Z & 130023424) === Z && 500 > B2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$1();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f3) {
  var g = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g = 1);
  else if ("string" === typeof a2)
    g = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f3, b2);
        case za:
          g = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f3, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f3, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f3, a2;
        case Ia:
          return qj(c2, e2, f3, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d2 = null;
                break a;
            }
          throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f3;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f3, g, h2, k4) {
  a2 = new bl(a2, b2, c2, h2, k4);
  1 === b2 ? (b2 = 1, true === f3 && (b2 |= 8)) : b2 = 0;
  f3 = Bg(3, null, null, b2);
  a2.current = f3;
  f3.stateNode = a2;
  f3.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f3);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$1(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f3, g, h2, k4) {
  a2 = cl(c2, d2, true, a2, e2, f3, g, h2, k4);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$1();
  e2 = lh(c2);
  f3 = ch(d2, e2);
  f3.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f3, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f3 = L$1(), g = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f3, g);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g);
  null !== a2 && (mh(a2, e2, g, f3), eh(a2, e2, g));
  return g;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
function ml(a2) {
  this._internalRoot = a2;
}
function nl(a2) {
  this._internalRoot = a2;
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f3 = d2;
      d2 = function() {
        var a3 = hl(g);
        f3.call(a3);
      };
    }
    var g = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g;
    a2[uf] = g.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k4);
      h2.call(a3);
    };
  }
  var k4 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k4;
  a2[uf] = k4.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k4, c2, d2);
  });
  return k4;
}
function sl(a2, b2, c2, d2, e2) {
  var f3 = c2._reactRootContainer;
  if (f3) {
    var g = f3;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g);
        h2.call(a3);
      };
    }
    gl(b2, g, a2, e2);
  } else
    g = rl(c2, b2, a2, e2, d2);
  return hl(g);
}
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
function h(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
function q(a2, b2) {
  var d2 = b2(), f3 = l2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f3[0].inst, g = f3[1];
  n2(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$1(c2) && g({ inst: c2 });
  }, [a2, d2, b2]);
  m(function() {
    r$1(c2) && g({ inst: c2 });
    return a2(function() {
      r$1(c2) && g({ inst: c2 });
    });
  }, [a2]);
  p2(d2);
  return d2;
}
function r$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k(a2, d2);
  } catch (f3) {
    return true;
  }
}
function t2(a2, b2) {
  return b2();
}
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
function useQueries({
  queries,
  context
}) {
  const queryClient = useQueryClient({
    context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedQueries = reactExports.useMemo(() => queries.map((options) => {
    const defaultedOptions = queryClient.defaultQueryOptions(options);
    defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
    return defaultedOptions;
  }), [queries, queryClient, isRestoring]);
  defaultedQueries.forEach((query) => {
    ensureStaleTime(query);
    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);
  });
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(() => new QueriesObserver(queryClient, defaultedQueries));
  const optimisticResult = observer.getOptimisticResult(defaultedQueries);
  useSyncExternalStore(reactExports.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  reactExports.useEffect(() => {
    observer.setQueries(defaultedQueries, {
      listeners: false
    });
  }, [defaultedQueries, observer]);
  const shouldAtLeastOneSuspend = optimisticResult.some((result, index3) => shouldSuspend(defaultedQueries[index3], result, isRestoring));
  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index3) => {
    const options = defaultedQueries[index3];
    const queryObserver = observer.getObservers()[index3];
    if (options && queryObserver) {
      if (shouldSuspend(options, result, isRestoring)) {
        return fetchOptimistic(options, queryObserver, errorResetBoundary);
      } else if (willFetch(result, isRestoring)) {
        void fetchOptimistic(options, queryObserver, errorResetBoundary);
      }
    }
    return [];
  }) : [];
  if (suspensePromises.length > 0) {
    throw Promise.all(suspensePromises);
  }
  const observerQueries = observer.getQueries();
  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index3) => {
    var _defaultedQueries$ind, _defaultedQueries$ind2;
    return getHasError({
      result,
      errorResetBoundary,
      useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index3]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,
      query: observerQueries[index3]
    });
  });
  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {
    throw firstSingleResultWhichShouldThrow.error;
  }
  return optimisticResult;
}
function useBaseQuery(options, Observer) {
  const queryClient = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore(reactExports.useCallback((onStoreChange) => {
    const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
    observer.updateResult();
    return unsubscribe;
  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    useErrorBoundary: defaultedOptions.useErrorBoundary,
    query: observer.getCurrentQuery()
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient, options));
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = reactExports.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop3);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop3() {
}
function useInfiniteQuery(arg1, arg2, arg3) {
  const options = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(options, InfiniteQueryObserver);
}
function getQueryKeyInternal(path, input) {
  if (path.length)
    return input === void 0 ? [
      path
    ] : [
      path,
      input
    ];
  return [];
}
function createReactProxyDecoration(name, hooks) {
  return createRecursiveProxy((opts2) => {
    const args = opts2.args;
    const pathCopy = [
      name,
      ...opts2.path
    ];
    const lastArg = pathCopy.pop();
    const path = pathCopy.join(".");
    if (lastArg === "useMutation") {
      return hooks[lastArg](path, ...args);
    }
    const [input, ...rest] = args;
    const queryKey = getQueryKeyInternal(path, input);
    if (lastArg === "getQueryKey") {
      return getArrayQueryKey(queryKey, rest[0] ?? "any");
    }
    if (lastArg === "_def") {
      return {
        path: pathCopy
      };
    }
    if (lastArg.startsWith("useSuspense")) {
      const opts1 = rest[0] || {};
      const fn2 = lastArg === "useSuspenseQuery" ? "useQuery" : "useInfiniteQuery";
      const result = hooks[fn2](queryKey, {
        ...opts1,
        suspense: true,
        enabled: true
      });
      return [
        result.data,
        result
      ];
    }
    return hooks[lastArg](queryKey, ...rest);
  });
}
function createReactQueryUtilsProxy(context) {
  return createFlatProxy((key) => {
    const contextName = key;
    if (contextName === "client") {
      return createTRPCClientProxy(context.client);
    }
    if (contextProps.includes(contextName)) {
      return context[contextName];
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const utilName = pathCopy.pop();
      const fullPath = pathCopy.join(".");
      const getOpts = (name) => {
        if ([
          "setData",
          "setInfiniteData"
        ].includes(name)) {
          const [input, updater2, ...rest2] = args;
          const queryKey2 = getQueryKeyInternal(fullPath, input);
          return {
            queryKey: queryKey2,
            updater: updater2,
            rest: rest2
          };
        }
        const [input1, ...rest1] = args;
        const queryKey1 = getQueryKeyInternal(fullPath, input1);
        return {
          queryKey: queryKey1,
          rest: rest1
        };
      };
      const { queryKey, rest, updater } = getOpts(utilName);
      const contextMap = {
        fetch: () => context.fetchQuery(queryKey, ...rest),
        fetchInfinite: () => context.fetchInfiniteQuery(queryKey, ...rest),
        prefetch: () => context.prefetchQuery(queryKey, ...rest),
        prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, ...rest),
        ensureData: () => context.ensureQueryData(queryKey, ...rest),
        invalidate: () => context.invalidateQueries(queryKey, ...rest),
        reset: () => context.resetQueries(queryKey, ...rest),
        refetch: () => context.refetchQueries(queryKey, ...rest),
        cancel: () => context.cancelQuery(queryKey, ...rest),
        setData: () => {
          context.setQueryData(queryKey, updater, ...rest);
        },
        setInfiniteData: () => {
          context.setInfiniteQueryData(queryKey, updater, ...rest);
        },
        getData: () => context.getQueryData(queryKey),
        getInfiniteData: () => context.getInfiniteQueryData(queryKey)
      };
      return contextMap[utilName]();
    });
  });
}
function createUseQueriesProxy(client) {
  return createRecursiveProxy((opts2) => {
    const path = opts2.path.join(".");
    const [input, _opts] = opts2.args;
    const queryKey = getQueryKeyInternal(path, input);
    const options = {
      queryKey,
      queryFn: () => {
        return client.query(path, input, _opts?.trpc);
      },
      ..._opts
    };
    return options;
  });
}
function getClientArgs(pathAndInput, opts2) {
  const [path, input] = pathAndInput;
  return [
    path,
    input,
    opts2?.trpc
  ];
}
function useHookResult(value) {
  const { path } = value;
  return reactExports.useMemo(() => ({
    path
  }), [
    path
  ]);
}
function createRootHooks(config) {
  const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? ((options) => options.originalFn());
  const Context = config?.context ?? TRPCContext;
  const ReactQueryContext = config?.reactQueryContext;
  const createClient = (opts2) => {
    return createTRPCClient(opts2);
  };
  const TRPCProvider = (props) => {
    const { abortOnUnmount = false, client, queryClient, ssrContext } = props;
    const [ssrState, setSSRState] = reactExports.useState(props.ssrState ?? false);
    reactExports.useEffect(() => {
      setSSRState((state) => state ? "mounted" : false);
    }, []);
    return /* @__PURE__ */ React.createElement(Context.Provider, {
      value: {
        abortOnUnmount,
        queryClient,
        client,
        ssrContext: ssrContext ?? null,
        ssrState,
        fetchQuery: reactExports.useCallback((pathAndInput, opts2) => {
          return queryClient.fetchQuery({
            ...opts2,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts2))
          });
        }, [
          client,
          queryClient
        ]),
        fetchInfiniteQuery: reactExports.useCallback((pathAndInput, opts2) => {
          return queryClient.fetchInfiniteQuery({
            ...opts2,
            queryKey: getArrayQueryKey(pathAndInput, "infinite"),
            queryFn: ({ pageParam }) => {
              const [path, input] = pathAndInput;
              const actualInput = {
                ...input,
                cursor: pageParam
              };
              return client.query(...getClientArgs([
                path,
                actualInput
              ], opts2));
            }
          });
        }, [
          client,
          queryClient
        ]),
        prefetchQuery: reactExports.useCallback((pathAndInput, opts2) => {
          return queryClient.prefetchQuery({
            ...opts2,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts2))
          });
        }, [
          client,
          queryClient
        ]),
        prefetchInfiniteQuery: reactExports.useCallback((pathAndInput, opts2) => {
          return queryClient.prefetchInfiniteQuery({
            ...opts2,
            queryKey: getArrayQueryKey(pathAndInput, "infinite"),
            queryFn: ({ pageParam }) => {
              const [path, input] = pathAndInput;
              const actualInput = {
                ...input,
                cursor: pageParam
              };
              return client.query(...getClientArgs([
                path,
                actualInput
              ], opts2));
            }
          });
        }, [
          client,
          queryClient
        ]),
        ensureQueryData: reactExports.useCallback((pathAndInput, opts2) => {
          return queryClient.ensureQueryData({
            ...opts2,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts2))
          });
        }, [
          client,
          queryClient
        ]),
        invalidateQueries: reactExports.useCallback((queryKey, filters, options) => {
          return queryClient.invalidateQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        resetQueries: reactExports.useCallback((...args) => {
          const [queryKey, filters, options] = args;
          return queryClient.resetQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        refetchQueries: reactExports.useCallback((...args) => {
          const [queryKey, filters, options] = args;
          return queryClient.refetchQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        cancelQuery: reactExports.useCallback((pathAndInput) => {
          return queryClient.cancelQueries({
            queryKey: getArrayQueryKey(pathAndInput, "any")
          });
        }, [
          queryClient
        ]),
        setQueryData: reactExports.useCallback((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.setQueryData(getArrayQueryKey(queryKey, "query"), ...rest);
        }, [
          queryClient
        ]),
        getQueryData: reactExports.useCallback((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.getQueryData(getArrayQueryKey(queryKey, "query"), ...rest);
        }, [
          queryClient
        ]),
        setInfiniteQueryData: reactExports.useCallback((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.setQueryData(getArrayQueryKey(queryKey, "infinite"), ...rest);
        }, [
          queryClient
        ]),
        getInfiniteQueryData: reactExports.useCallback((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.getQueryData(getArrayQueryKey(queryKey, "infinite"), ...rest);
        }, [
          queryClient
        ])
      }
    }, props.children);
  };
  function useContext() {
    return React.useContext(Context);
  }
  function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts2) {
    const { queryClient, ssrState } = useContext();
    return ssrState && ssrState !== "mounted" && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === "error" ? {
      retryOnMount: false,
      ...opts2
    } : opts2;
  }
  function useQuery$1(pathAndInput, opts2) {
    const context = useContext();
    if (!context) {
      throw new Error("Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?");
    }
    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } = context;
    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, "query"));
    if (typeof window === "undefined" && ssrState === "prepass" && opts2?.trpc?.ssr !== false && (opts2?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, "query"))) {
      void prefetchQuery(pathAndInput, opts2);
    }
    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, "query", {
      ...defaultOpts,
      ...opts2
    });
    const shouldAbortOnUnmount = opts2?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;
    const hook = useQuery({
      ...ssrOpts,
      queryKey: getArrayQueryKey(pathAndInput, "query"),
      queryFn: (queryFunctionContext) => {
        const actualOpts = {
          ...ssrOpts,
          trpc: {
            ...ssrOpts?.trpc,
            ...shouldAbortOnUnmount ? {
              signal: queryFunctionContext.signal
            } : {}
          }
        };
        return client.query(...getClientArgs(pathAndInput, actualOpts));
      },
      context: ReactQueryContext
    });
    hook.trpc = useHookResult({
      path: pathAndInput[0]
    });
    return hook;
  }
  function useMutation$1(path, opts2) {
    const { client } = useContext();
    const queryClient = useQueryClient({
      context: ReactQueryContext
    });
    const actualPath = Array.isArray(path) ? path[0] : path;
    const defaultOpts = queryClient.getMutationDefaults([
      actualPath.split(".")
    ]);
    const hook = useMutation({
      ...opts2,
      mutationKey: [
        actualPath.split(".")
      ],
      mutationFn: (input) => {
        return client.mutation(...getClientArgs([
          actualPath,
          input
        ], opts2));
      },
      context: ReactQueryContext,
      onSuccess(...args) {
        const originalFn = () => opts2?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);
        return mutationSuccessOverride({
          originalFn,
          queryClient,
          meta: opts2?.meta ?? defaultOpts?.meta ?? {}
        });
      }
    });
    hook.trpc = useHookResult({
      path: actualPath
    });
    return hook;
  }
  function useSubscription(pathAndInput, opts2) {
    const enabled = opts2?.enabled ?? true;
    const queryKey = hashQueryKey(pathAndInput);
    const { client } = useContext();
    const optsRef = reactExports.useRef(opts2);
    optsRef.current = opts2;
    reactExports.useEffect(() => {
      if (!enabled) {
        return;
      }
      const [path, input] = pathAndInput;
      let isStopped = false;
      const subscription = client.subscription(path, input ?? void 0, {
        onStarted: () => {
          if (!isStopped) {
            optsRef.current.onStarted?.();
          }
        },
        onData: (data) => {
          if (!isStopped) {
            optsRef.current.onData(data);
          }
        },
        onError: (err) => {
          if (!isStopped) {
            optsRef.current.onError?.(err);
          }
        }
      });
      return () => {
        isStopped = true;
        subscription.unsubscribe();
      };
    }, [
      queryKey,
      enabled
    ]);
  }
  function useInfiniteQuery$1(pathAndInput, opts2) {
    const [path, input] = pathAndInput;
    const { client, ssrState, prefetchInfiniteQuery, queryClient, abortOnUnmount } = useContext();
    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, "infinite"));
    if (typeof window === "undefined" && ssrState === "prepass" && opts2?.trpc?.ssr !== false && (opts2?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, "infinite"))) {
      void prefetchInfiniteQuery(pathAndInput, {
        ...defaultOpts,
        ...opts2
      });
    }
    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, "infinite", {
      ...defaultOpts,
      ...opts2
    });
    const shouldAbortOnUnmount = opts2?.trpc?.abortOnUnmount ?? abortOnUnmount;
    const hook = useInfiniteQuery({
      ...ssrOpts,
      queryKey: getArrayQueryKey(pathAndInput, "infinite"),
      queryFn: (queryFunctionContext) => {
        const actualOpts = {
          ...ssrOpts,
          trpc: {
            ...ssrOpts?.trpc,
            ...shouldAbortOnUnmount ? {
              signal: queryFunctionContext.signal
            } : {}
          }
        };
        const actualInput = {
          ...input ?? {},
          cursor: queryFunctionContext.pageParam ?? opts2?.initialCursor
        };
        return client.query(...getClientArgs([
          path,
          actualInput
        ], actualOpts));
      },
      context: ReactQueryContext
    });
    hook.trpc = useHookResult({
      path
    });
    return hook;
  }
  const useQueries$1 = (queriesCallback, context) => {
    const { ssrState, queryClient, prefetchQuery, client } = useContext();
    const proxy = createUseQueriesProxy(client);
    const queries = queriesCallback(proxy);
    if (typeof window === "undefined" && ssrState === "prepass") {
      for (const query of queries) {
        const queryOption = query;
        if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, "query"))) {
          void prefetchQuery(queryOption.queryKey, queryOption);
        }
      }
    }
    return useQueries({
      queries: queries.map((query) => ({
        ...query,
        queryKey: getArrayQueryKey(query.queryKey, "query")
      })),
      context
    });
  };
  const useDehydratedState = (client, trpcState) => {
    const transformed = reactExports.useMemo(() => {
      if (!trpcState) {
        return trpcState;
      }
      return client.runtime.transformer.deserialize(trpcState);
    }, [
      trpcState,
      client
    ]);
    return transformed;
  };
  return {
    Provider: TRPCProvider,
    createClient,
    useContext,
    useUtils: useContext,
    useQuery: useQuery$1,
    useQueries: useQueries$1,
    useMutation: useMutation$1,
    useSubscription,
    useDehydratedState,
    useInfiniteQuery: useInfiniteQuery$1
  };
}
function createHooksInternal(config) {
  return createRootHooks(config);
}
function createHooksInternalProxy(trpc) {
  return createFlatProxy((key) => {
    if (key === "useContext" || key === "useUtils") {
      return () => {
        const context = trpc.useUtils();
        return reactExports.useMemo(() => {
          return createReactQueryUtilsProxy(context);
        }, [
          context
        ]);
      };
    }
    if (trpc.hasOwnProperty(key)) {
      return trpc[key];
    }
    return createReactProxyDecoration(key, trpc);
  });
}
function createTRPCReact(opts2) {
  const hooks = createHooksInternal(opts2);
  const proxy = createHooksInternalProxy(hooks);
  return proxy;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d2) {
  return d2 instanceof Function;
}
function isNumberArray(d2) {
  return Array.isArray(d2) && d2.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn2, opts2) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts2.key && opts2.debug)
      depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index3) => deps[index3] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts2.key && opts2.debug)
      resultTime = Date.now();
    result = fn2(...newDeps);
    opts2 == null || opts2.onChange == null || opts2.onChange(result);
    if (opts2.key && opts2.debug) {
      if (opts2 != null && opts2.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts2 == null ? void 0 : opts2.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: false,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id3 = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id3) {
    throw new Error();
  }
  let column = {
    id: `${String(id3)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
function createHeader(table, column, options) {
  var _options$id;
  const id3 = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id: id3,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h2) => {
        if (h2.subHeaders && h2.subHeaders.length) {
          h2.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h2);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index3) => createHeader(table, column, {
    depth: maxDepth,
    index: index3
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
function passiveEventSupported() {
  if (typeof passiveSupported$1 === "boolean")
    return passiveSupported$1;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop22 = () => {
    };
    window.addEventListener("test", noop22, options);
    window.removeEventListener("test", noop22);
  } catch (err) {
    supported = false;
  }
  passiveSupported$1 = supported;
  return passiveSupported$1;
}
function isTouchStartEvent(e2) {
  return e2.type === "touchstart";
}
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length))
    return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
function compareBasic(a2, b2) {
  return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;
}
function toString(a2) {
  if (typeof a2 === "number") {
    if (isNaN(a2) || a2 === Infinity || a2 === -Infinity) {
      return "";
    }
    return String(a2);
  }
  if (typeof a2 === "string") {
    return a2;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a2 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b2 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a2.length && b2.length) {
    const aa3 = a2.shift();
    const bb3 = b2.shift();
    const an2 = parseInt(aa3, 10);
    const bn2 = parseInt(bb3, 10);
    const combo = [an2, bn2].sort();
    if (isNaN(combo[0])) {
      if (aa3 > bb3) {
        return 1;
      }
      if (bb3 > aa3) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an2) ? -1 : 1;
    }
    if (an2 > bn2) {
      return 1;
    }
    if (bn2 > an2) {
      return -1;
    }
  }
  return a2.length - b2.length;
}
function createTable(options) {
  var _options$_features, _options$initialState;
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions3 = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions3, options2);
    }
    return {
      ...defaultOptions3,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState2 = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState2 = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState2)) != null ? _feature$getInitialSt : initialState2;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions3,
      ...options
    },
    initialState: initialState2,
    _queue: (cb3) => {
      queued.push(cb3);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error2) => setTimeout(() => {
          throw error2;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index3, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index3, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index3].join(".") : index3}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id3, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id3];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id3];
        if (!row) {
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index3 = 0; index3 < table._features.length; index3++) {
    const feature = table._features[index3];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow(table, table._getRowId(originalRows[i2], i2, parentRow), originalRows[i2], i2, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ reactExports.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = reactExports.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = reactExports.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}
function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext2) {
  const Context = /* @__PURE__ */ reactExports.createContext(defaultContext2);
  function Provider(props) {
    const { children, ...context } = props;
    const value = reactExports.useMemo(
      () => context,
      Object.values(context)
    );
    return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
      value
    }, children);
  }
  function useContext(consumerName) {
    const context = reactExports.useContext(Context);
    if (context)
      return context;
    if (defaultContext2 !== void 0)
      return defaultContext2;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider.displayName = rootComponentName + "Provider";
  return [
    Provider,
    useContext
  ];
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext2) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext2);
    const index3 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext2
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index3]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index3]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context)
        return context;
      if (defaultContext2 !== void 0)
        return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts2
          }
        }),
        [
          scope,
          contexts2
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae11092,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    reactDomExports.flushSync(
      () => target.dispatchEvent(event)
    );
}
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ React.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = reactExports.useContext($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent2();
      } else
        ownerDocument.removeEventListener("click", handleClickRef.current);
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  reactExports.useEffect(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index3 = updatedArray.indexOf(item);
  if (index3 !== -1)
    updatedArray.splice(index3, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id3, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id3 ? `radix-${id3}` : "");
}
function clamp(start, value, end) {
  return max$1(start, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb3 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb3 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x4,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x4,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x4 = ($2 ? round(rect.width) : rect.width) / width;
  let y3 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
function isTopLayer(floating) {
  return topLayerSelectors.some((selector) => {
    try {
      return floating.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max$1(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max$1(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x4 += max$1(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x4 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x4 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x4,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element) || isTopLayer(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x4 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x4 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x4,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size2;
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
function $fe963b355347cc68$export$3e6543de14f8614f(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState2);
}
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          reactDomExports.flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: reactExports.useCallback((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index3) => array[(startIndex + index3) % array.length]
  );
}
function __rest$1(s3, e2) {
  var t5 = {};
  for (var p4 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
      t5[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s3); i2 < p4.length; i2++) {
      if (e2.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i2]))
        t5[p4[i2]] = s3[p4[i2]];
    }
  return t5;
}
function __awaiter(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _3 = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f3, y3, t5, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n5) {
    return function(v4) {
      return step([n5, v4]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_3 = 0)), _3)
      try {
        if (f3 = 1, y3 && (t5 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t5 = y3["return"]) && t5.call(y3), 0) : y3.next) && !(t5 = t5.call(y3, op[1])).done)
          return t5;
        if (y3 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _3.label++;
            return { value: op[1], done: false };
          case 5:
            _3.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _3.ops.pop();
            _3.trys.pop();
            continue;
          default:
            if (!(t5 = _3.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _3 = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _3.label = op[1];
              break;
            }
            if (op[0] === 6 && _3.label < t5[1]) {
              _3.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _3.label < t5[2]) {
              _3.label = t5[2];
              _3.ops.push(op);
              break;
            }
            if (t5[2])
              _3.ops.pop();
            _3.trys.pop();
            continue;
        }
        op = body.call(thisArg, _3);
      } catch (e2) {
        op = [6, e2];
        y3 = 0;
      } finally {
        f3 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read(o3, n5) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r5, ar = [], e2;
  try {
    while ((n5 === void 0 || n5-- > 0) && !(r5 = i2.next()).done)
      ar.push(r5.value);
  } catch (error2) {
    e2 = { error: error2 };
  } finally {
    try {
      if (r5 && !r5.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray$1(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l4 = from.length, ar; i2 < l4; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x4) {
          return x4 !== item;
        });
      };
    },
    assignSyncMedium: function(cb3) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb3);
      }
      buffer = {
        push: function(x4) {
          return cb3(x4);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb3) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb3);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb3);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x4) {
          pendingQueue.push(x4);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$1({ async: true, ssr: false }, options);
  return medium;
}
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id3 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id3));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id3));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id3));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id3));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id3) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
function $6cc32821e9371a1c$var$getOpenState(open) {
  return open ? "open" : "closed";
}
function $6cc32821e9371a1c$var$isIndeterminate(checked) {
  return checked === "indeterminate";
}
function $6cc32821e9371a1c$var$getCheckedState(checked) {
  return $6cc32821e9371a1c$var$isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index3) => array[(startIndex + index3) % array.length]
  );
}
function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every(
    (char) => char === search[0]
  );
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter(
      (v4) => v4 !== currentMatch
    );
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {
  const { x: x4, y: y3 } = point;
  let inside = false;
  for (let i2 = 0, j3 = polygon.length - 1; i2 < polygon.length; j3 = i2++) {
    const xi2 = polygon[i2].x;
    const yi2 = polygon[i2].y;
    const xj2 = polygon[j3].x;
    const yj2 = polygon[j3].y;
    const intersect2 = yi2 > y3 !== yj2 > y3 && x4 < (xj2 - xi2) * (y3 - yi2) / (yj2 - yi2) + xi2;
    if (intersect2)
      inside = !inside;
  }
  return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
}
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index3 = 0; index3 < className.length; index3++) {
      let currentCharacter = className[index3];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index3, index3 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index3));
          modifierStart = index3 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index3;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index3 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index3 < arguments.length) {
    if (argument = arguments[index3++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k4 = 0; k4 < mix.length; k4++) {
    if (mix[k4]) {
      if (resolvedValue = toValue(mix[k4])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert2 = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert2]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert2]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function cn$1(...inputs) {
  return twMerge(clsx(inputs));
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function r3(e2) {
  var t5, f3, n5 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n5 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t5 = 0; t5 < e2.length; t5++)
        e2[t5] && (f3 = r3(e2[t5])) && (n5 && (n5 += " "), n5 += f3);
    else
      for (t5 in e2)
        e2[t5] && (n5 && (n5 += " "), n5 += t5);
  return n5;
}
function clsx2() {
  for (var e2, t5, f3 = 0, n5 = ""; f3 < arguments.length; )
    (e2 = arguments[f3++]) && (t5 = r3(e2)) && (n5 && (n5 += " "), n5 += t5);
  return n5;
}
function SortingColumnHeader({
  id: id3,
  title,
  isDesc: isDesc2,
  isSorting: isSorting2,
  onSort,
  onCleanSort
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        className: "-ml-3 h-8 data-[state=open]:bg-accent",
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: title }),
          isSorting2 ? isDesc2 ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowDown, { className: "ml-2 h-3.5 w-3.5 text-slate-800" }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowUp, { className: "ml-2 h-3.5 w-3.5 text-slate-800" }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(CaretSortIcon, { className: "ml-2 h-3.5 w-3.5 text-slate-800" })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "start", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          onClick: () => onSort({ id: id3, desc: false }),
          className: isSorting2 && !isDesc2 ? "bg-primary text-primary-foreground" : "",
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowUp, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
            "Asc"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          onClick: () => onSort({ id: id3, desc: true }),
          className: isSorting2 && isDesc2 ? "bg-primary text-primary-foreground" : "",
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowDown, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
            "Desc"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { onClick: () => onCleanSort(id3), children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(WandSparkles, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
        "Limpiar"
      ] })
    ] })
  ] });
}
function nameColumnDef({
  sorting
}) {
  return {
    accessorKey: "name",
    header: () => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        SortingColumnHeader,
        {
          id: "name",
          title: "Nombre",
          isDesc: isDesc(sorting.sortingState, "name"),
          isSorting: isSorting(sorting.sortingState, "name"),
          onSort: sorting.onSort,
          onCleanSort: sorting.onCleanSort
        }
      );
    }
  };
}
function isDesc(sortingState, id3) {
  return sortingState.some((s3) => s3.id === id3 && s3.desc === true);
}
function isSorting(sortingState, id3) {
  return sortingState.some((s3) => s3.id === id3);
}
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount))
    return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount))
    return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfDay(date) {
  const _date = toDate(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addWeeks(date, amount) {
  const days = amount * 7;
  return addDays(date, days);
}
function addYears(date, amount) {
  return addMonths(date, amount * 12);
}
function max(dates) {
  let result;
  dates.forEach(function(dirtyDate) {
    const currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
function min(dates) {
  let result;
  dates.forEach((dirtyDate) => {
    const date = toDate(dirtyDate);
    if (!result || result > date || isNaN(+date)) {
      result = date;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}
function compareAsc(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const diff = _dateLeft.getTime() - _dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function constructNow(date) {
  return constructFrom(date, Date.now());
}
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = startOfDay(dateLeft);
  const dateRightStartOfDay = startOfDay(dateRight);
  return +dateLeftStartOfDay === +dateRightStartOfDay;
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid2(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarWeeks(dateLeft, dateRight, options) {
  const startOfWeekLeft = startOfWeek(dateLeft, options);
  const startOfWeekRight = startOfWeek(dateRight, options);
  const timestampLeft = +startOfWeekLeft - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  const timestampRight = +startOfWeekRight - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);
}
function getRoundingMethod(method) {
  return (number) => {
    const round2 = method ? Math[method] : Math.trunc;
    const result = round2(number);
    return result === 0 ? 0 : result;
  };
}
function differenceInMilliseconds(dateLeft, dateRight) {
  return +toDate(dateLeft) - +toDate(dateRight);
}
function endOfDay(date) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function isLastDayOfMonth(date) {
  const _date = toDate(date);
  return +endOfDay(_date) === +endOfMonth(_date);
}
function differenceInMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const sign = compareAsc(_dateLeft, _dateRight);
  const difference2 = Math.abs(
    differenceInCalendarMonths(_dateLeft, _dateRight)
  );
  let result;
  if (difference2 < 1) {
    result = 0;
  } else {
    if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
      _dateLeft.setDate(30);
    }
    _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference2);
    let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
    if (isLastDayOfMonth(toDate(dateLeft)) && difference2 === 1 && compareAsc(dateLeft, _dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign * (difference2 - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
function differenceInSeconds(dateLeft, dateRight, options) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options?.roundingMethod)(diff);
}
function startOfMonth(date) {
  const _date = toDate(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfYear(date) {
  const cleanDate = toDate(date);
  const _date = constructFrom(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfWeek(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfISOWeek(date) {
  return endOfWeek(date, { weekStartsOn: 1 });
}
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index3 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index3];
  };
}
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern2 = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern2);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object2, predicate) {
  for (const key in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function getDayOfYear(date) {
  const _date = toDate(date);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}
function formatTimezoneShort(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, delimiter) {
  if (offset2 % 60 === 0) {
    const sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, delimiter);
}
function formatTimezone(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token))
    throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
function format(date, formatStr, options) {
  const defaultOptions3 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions3.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions3.firstWeekContainsDate ?? defaultOptions3.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions3.weekStartsOn ?? defaultOptions3.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date);
  if (!isValid2(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters$1[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken)
      return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters$1[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function formatDistance$1(date, baseDate, options) {
  const defaultOptions3 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions3.locale ?? enUS;
  const minutesInAlmostTwoDays = 2520;
  const comparison = compareAsc(date, baseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison
  });
  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = toDate(baseDate);
    dateRight = toDate(date);
  } else {
    dateLeft = toDate(date);
    dateRight = toDate(baseDate);
  }
  const seconds = differenceInSeconds(dateRight, dateLeft);
  const offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;
  if (minutes < 2) {
    if (options?.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < minutesInMonth) {
    const days = Math.round(minutes / minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < minutesInMonth * 2) {
    months = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(dateRight, dateLeft);
  if (months < 12) {
    const nearestMonth = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
function formatDistanceToNow(date, options) {
  return formatDistance$1(date, constructNow(date), options);
}
function getDaysInMonth(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth2 = constructFrom(date, 0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}
function getUnixTime(date) {
  return Math.trunc(+toDate(date) / 1e3);
}
function lastDayOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function getWeeksInMonth(date, options) {
  return differenceInCalendarWeeks(
    lastDayOfMonth(date),
    startOfMonth(date),
    options
  ) + 1;
}
function isAfter(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}
function isBefore(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return +_date < +_dateToCompare;
}
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}
function isSameYear(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}
function subDays(date, amount) {
  return addDays(date, -amount);
}
function setMonth(date, month) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const dateWithDesiredMonth = constructFrom(date, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}
function setYear(date, year) {
  const _date = toDate(date);
  if (isNaN(+_date)) {
    return constructFrom(date, NaN);
  }
  _date.setFullYear(year);
  return _date;
}
function __rest(s3, e2) {
  var t5 = {};
  for (var p4 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p4) && e2.indexOf(p4) < 0)
      t5[p4] = s3[p4];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p4 = Object.getOwnPropertySymbols(s3); i2 < p4.length; i2++) {
      if (e2.indexOf(p4[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p4[i2]))
        t5[p4[i2]] = s3[p4[i2]];
    }
  return t5;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l4 = from.length, ar; i2 < l4; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f3 = React, k4 = Symbol.for("react.element"), l4 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n5 = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p4 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g && (e2 = "" + g);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2)
      m2.call(a2, b2) && !p4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a2 = c2.defaultProps, a2)
        void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k4, type: c2, key: e2, ref: h2, props: d2, _owner: n5.current };
  }
  reactJsxRuntime_production_min.Fragment = l4;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
function isDayPickerMultiple(props) {
  return props.mode === "multiple";
}
function isDayPickerRange(props) {
  return props.mode === "range";
}
function isDayPickerSingle(props) {
  return props.mode === "single";
}
function formatCaption(month, options) {
  return format(month, "LLLL y", options);
}
function formatDay(day, options) {
  return format(day, "d", options);
}
function formatMonthCaption(month, options) {
  return format(month, "LLLL", options);
}
function formatWeekNumber(weekNumber) {
  return "".concat(weekNumber);
}
function formatWeekdayName(weekday, options) {
  return format(weekday, "cccccc", options);
}
function formatYearCaption(year, options) {
  return format(year, "yyyy", options);
}
function getDefaultContextValues() {
  var captionLayout = "buttons";
  var classNames = defaultClassNames;
  var locale = enUS;
  var modifiersClassNames = {};
  var modifiers = {};
  var numberOfMonths = 1;
  var styles = {};
  var today = /* @__PURE__ */ new Date();
  return {
    captionLayout,
    classNames,
    formatters,
    labels,
    locale,
    modifiersClassNames,
    modifiers,
    numberOfMonths,
    styles,
    today,
    mode: "default"
  };
}
function parseFromToProps(props) {
  var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;
  var fromDate = props.fromDate, toDate2 = props.toDate;
  if (fromMonth) {
    fromDate = startOfMonth(fromMonth);
  } else if (fromYear) {
    fromDate = new Date(fromYear, 0, 1);
  }
  if (toMonth) {
    toDate2 = endOfMonth(toMonth);
  } else if (toYear) {
    toDate2 = new Date(toYear, 11, 31);
  }
  return {
    fromDate: fromDate ? startOfDay(fromDate) : void 0,
    toDate: toDate2 ? startOfDay(toDate2) : void 0
  };
}
function DayPickerProvider(props) {
  var _a78;
  var initialProps = props.initialProps;
  var defaultContextValues = getDefaultContextValues();
  var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate2 = _b.toDate;
  var captionLayout = (_a78 = initialProps.captionLayout) !== null && _a78 !== void 0 ? _a78 : defaultContextValues.captionLayout;
  if (captionLayout !== "buttons" && (!fromDate || !toDate2)) {
    captionLayout = "buttons";
  }
  var onSelect;
  if (isDayPickerSingle(initialProps) || isDayPickerMultiple(initialProps) || isDayPickerRange(initialProps)) {
    onSelect = initialProps.onSelect;
  }
  var value = __assign(__assign(__assign({}, defaultContextValues), initialProps), { captionLayout, classNames: __assign(__assign({}, defaultContextValues.classNames), initialProps.classNames), components: __assign({}, initialProps.components), formatters: __assign(__assign({}, defaultContextValues.formatters), initialProps.formatters), fromDate, labels: __assign(__assign({}, defaultContextValues.labels), initialProps.labels), mode: initialProps.mode || defaultContextValues.mode, modifiers: __assign(__assign({}, defaultContextValues.modifiers), initialProps.modifiers), modifiersClassNames: __assign(__assign({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames), onSelect, styles: __assign(__assign({}, defaultContextValues.styles), initialProps.styles), toDate: toDate2 });
  return jsxRuntimeExports.jsx(DayPickerContext.Provider, { value, children: props.children });
}
function useDayPicker() {
  var context = reactExports.useContext(DayPickerContext);
  if (!context) {
    throw new Error("useDayPicker must be used within a DayPickerProvider.");
  }
  return context;
}
function CaptionLabel(props) {
  var _a78 = useDayPicker(), locale = _a78.locale, classNames = _a78.classNames, styles = _a78.styles, formatCaption2 = _a78.formatters.formatCaption;
  return jsxRuntimeExports.jsx("div", { className: classNames.caption_label, style: styles.caption_label, "aria-live": "polite", role: "presentation", id: props.id, children: formatCaption2(props.displayMonth, { locale }) });
}
function IconDropdown(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function Dropdown(props) {
  var _a78, _b;
  var onChange = props.onChange, value = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;
  var dayPicker = useDayPicker();
  var IconDropdownComponent = (_b = (_a78 = dayPicker.components) === null || _a78 === void 0 ? void 0 : _a78.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;
  return jsxRuntimeExports.jsxs("div", { className, style, children: [jsxRuntimeExports.jsx("span", { className: dayPicker.classNames.vhidden, children: props["aria-label"] }), jsxRuntimeExports.jsx("select", { name: props.name, "aria-label": props["aria-label"], className: dayPicker.classNames.dropdown, style: dayPicker.styles.dropdown, value, onChange, children }), jsxRuntimeExports.jsxs("div", { className: dayPicker.classNames.caption_label, style: dayPicker.styles.caption_label, "aria-hidden": "true", children: [caption, jsxRuntimeExports.jsx(IconDropdownComponent, { className: dayPicker.classNames.dropdown_icon, style: dayPicker.styles.dropdown_icon })] })] });
}
function MonthsDropdown(props) {
  var _a78;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption2 = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown2 = _b.labels.labelMonthDropdown;
  if (!fromDate)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if (!toDate2)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  var dropdownMonths = [];
  if (isSameYear(fromDate, toDate2)) {
    var date = startOfMonth(fromDate);
    for (var month = fromDate.getMonth(); month <= toDate2.getMonth(); month++) {
      dropdownMonths.push(setMonth(date, month));
    }
  } else {
    var date = startOfMonth(/* @__PURE__ */ new Date());
    for (var month = 0; month <= 11; month++) {
      dropdownMonths.push(setMonth(date, month));
    }
  }
  var handleChange = function(e2) {
    var selectedMonth = Number(e2.target.value);
    var newMonth = setMonth(startOfMonth(props.displayMonth), selectedMonth);
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a78 = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a78 !== void 0 ? _a78 : Dropdown;
  return jsxRuntimeExports.jsx(DropdownComponent, { name: "months", "aria-label": labelMonthDropdown2(), className: classNames.dropdown_month, style: styles.dropdown_month, onChange: handleChange, value: props.displayMonth.getMonth(), caption: formatMonthCaption2(props.displayMonth, { locale }), children: dropdownMonths.map(function(m2) {
    return jsxRuntimeExports.jsx("option", { value: m2.getMonth(), children: formatMonthCaption2(m2, { locale }) }, m2.getMonth());
  }) });
}
function YearsDropdown(props) {
  var _a78;
  var displayMonth = props.displayMonth;
  var _b = useDayPicker(), fromDate = _b.fromDate, toDate2 = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption2 = _b.formatters.formatYearCaption, labelYearDropdown2 = _b.labels.labelYearDropdown;
  var years = [];
  if (!fromDate)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if (!toDate2)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  var fromYear = fromDate.getFullYear();
  var toYear = toDate2.getFullYear();
  for (var year = fromYear; year <= toYear; year++) {
    years.push(setYear(startOfYear(/* @__PURE__ */ new Date()), year));
  }
  var handleChange = function(e2) {
    var newMonth = setYear(startOfMonth(displayMonth), Number(e2.target.value));
    props.onChange(newMonth);
  };
  var DropdownComponent = (_a78 = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a78 !== void 0 ? _a78 : Dropdown;
  return jsxRuntimeExports.jsx(DropdownComponent, { name: "years", "aria-label": labelYearDropdown2(), className: classNames.dropdown_year, style: styles.dropdown_year, onChange: handleChange, value: displayMonth.getFullYear(), caption: formatYearCaption2(displayMonth, { locale }), children: years.map(function(year2) {
    return jsxRuntimeExports.jsx("option", { value: year2.getFullYear(), children: formatYearCaption2(year2, { locale }) }, year2.getFullYear());
  }) });
}
function useControlledValue(defaultValue, controlledValue) {
  var _a78 = reactExports.useState(defaultValue), uncontrolledValue = _a78[0], setValue = _a78[1];
  var value = controlledValue === void 0 ? uncontrolledValue : controlledValue;
  return [value, setValue];
}
function getInitialMonth(context) {
  var month = context.month, defaultMonth = context.defaultMonth, today = context.today;
  var initialMonth = month || defaultMonth || today || /* @__PURE__ */ new Date();
  var toDate2 = context.toDate, fromDate = context.fromDate, _a78 = context.numberOfMonths, numberOfMonths = _a78 === void 0 ? 1 : _a78;
  if (toDate2 && differenceInCalendarMonths(toDate2, initialMonth) < 0) {
    var offset2 = -1 * (numberOfMonths - 1);
    initialMonth = addMonths(toDate2, offset2);
  }
  if (fromDate && differenceInCalendarMonths(initialMonth, fromDate) < 0) {
    initialMonth = fromDate;
  }
  return startOfMonth(initialMonth);
}
function useNavigationState() {
  var context = useDayPicker();
  var initialMonth = getInitialMonth(context);
  var _a78 = useControlledValue(initialMonth, context.month), month = _a78[0], setMonth2 = _a78[1];
  var goToMonth = function(date) {
    var _a210;
    if (context.disableNavigation)
      return;
    var month2 = startOfMonth(date);
    setMonth2(month2);
    (_a210 = context.onMonthChange) === null || _a210 === void 0 ? void 0 : _a210.call(context, month2);
  };
  return [month, goToMonth];
}
function getDisplayMonths(month, _a78) {
  var reverseMonths = _a78.reverseMonths, numberOfMonths = _a78.numberOfMonths;
  var start = startOfMonth(month);
  var end = startOfMonth(addMonths(start, numberOfMonths));
  var monthsDiff = differenceInCalendarMonths(end, start);
  var months = [];
  for (var i2 = 0; i2 < monthsDiff; i2++) {
    var nextMonth = addMonths(start, i2);
    months.push(nextMonth);
  }
  if (reverseMonths)
    months = months.reverse();
  return months;
}
function getNextMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var toDate2 = options.toDate, pagedNavigation = options.pagedNavigation, _a78 = options.numberOfMonths, numberOfMonths = _a78 === void 0 ? 1 : _a78;
  var offset2 = pagedNavigation ? numberOfMonths : 1;
  var month = startOfMonth(startingMonth);
  if (!toDate2) {
    return addMonths(month, offset2);
  }
  var monthsDiff = differenceInCalendarMonths(toDate2, startingMonth);
  if (monthsDiff < numberOfMonths) {
    return void 0;
  }
  return addMonths(month, offset2);
}
function getPreviousMonth(startingMonth, options) {
  if (options.disableNavigation) {
    return void 0;
  }
  var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a78 = options.numberOfMonths, numberOfMonths = _a78 === void 0 ? 1 : _a78;
  var offset2 = pagedNavigation ? numberOfMonths : 1;
  var month = startOfMonth(startingMonth);
  if (!fromDate) {
    return addMonths(month, -offset2);
  }
  var monthsDiff = differenceInCalendarMonths(month, fromDate);
  if (monthsDiff <= 0) {
    return void 0;
  }
  return addMonths(month, -offset2);
}
function NavigationProvider(props) {
  var dayPicker = useDayPicker();
  var _a78 = useNavigationState(), currentMonth = _a78[0], goToMonth = _a78[1];
  var displayMonths = getDisplayMonths(currentMonth, dayPicker);
  var nextMonth = getNextMonth(currentMonth, dayPicker);
  var previousMonth = getPreviousMonth(currentMonth, dayPicker);
  var isDateDisplayed = function(date) {
    return displayMonths.some(function(displayMonth) {
      return isSameMonth(date, displayMonth);
    });
  };
  var goToDate = function(date, refDate) {
    if (isDateDisplayed(date)) {
      return;
    }
    if (refDate && isBefore(date, refDate)) {
      goToMonth(addMonths(date, 1 + dayPicker.numberOfMonths * -1));
    } else {
      goToMonth(date);
    }
  };
  var value = {
    currentMonth,
    displayMonths,
    goToMonth,
    goToDate,
    previousMonth,
    nextMonth,
    isDateDisplayed
  };
  return jsxRuntimeExports.jsx(NavigationContext.Provider, { value, children: props.children });
}
function useNavigation() {
  var context = reactExports.useContext(NavigationContext);
  if (!context) {
    throw new Error("useNavigation must be used within a NavigationProvider");
  }
  return context;
}
function CaptionDropdowns(props) {
  var _a78;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var goToMonth = useNavigation().goToMonth;
  var handleMonthChange = function(newMonth) {
    goToMonth(addMonths(newMonth, props.displayIndex ? -props.displayIndex : 0));
  };
  var CaptionLabelComponent = (_a78 = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a78 !== void 0 ? _a78 : CaptionLabel;
  var captionLabel = jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  return jsxRuntimeExports.jsxs("div", { className: classNames.caption_dropdowns, style: styles.caption_dropdowns, children: [jsxRuntimeExports.jsx("div", { className: classNames.vhidden, children: captionLabel }), jsxRuntimeExports.jsx(MonthsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth }), jsxRuntimeExports.jsx(YearsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth })] });
}
function IconLeft(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function IconRight(props) {
  return jsxRuntimeExports.jsx("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props, { children: jsxRuntimeExports.jsx("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) }));
}
function Navigation(props) {
  var _a78, _b;
  var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious2 = _d.labelPrevious, labelNext2 = _d.labelNext, components = _c.components;
  if (!props.nextMonth && !props.previousMonth) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }
  var previousLabel = labelPrevious2(props.previousMonth, { locale });
  var previousClassName = [
    classNames.nav_button,
    classNames.nav_button_previous
  ].join(" ");
  var nextLabel = labelNext2(props.nextMonth, { locale });
  var nextClassName = [
    classNames.nav_button,
    classNames.nav_button_next
  ].join(" ");
  var IconRightComponent = (_a78 = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a78 !== void 0 ? _a78 : IconRight;
  var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : IconLeft;
  return jsxRuntimeExports.jsxs("div", { className: classNames.nav, style: styles.nav, children: [!props.hidePrevious && jsxRuntimeExports.jsx(Button, { name: "previous-month", "aria-label": previousLabel, className: previousClassName, style: styles.nav_button_previous, disabled: !props.previousMonth, onClick: props.onPreviousClick, children: dir === "rtl" ? jsxRuntimeExports.jsx(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsxRuntimeExports.jsx(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) }), !props.hideNext && jsxRuntimeExports.jsx(Button, { name: "next-month", "aria-label": nextLabel, className: nextClassName, style: styles.nav_button_next, disabled: !props.nextMonth, onClick: props.onNextClick, children: dir === "rtl" ? jsxRuntimeExports.jsx(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon }) : jsxRuntimeExports.jsx(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }) })] });
}
function CaptionNavigation(props) {
  var numberOfMonths = useDayPicker().numberOfMonths;
  var _a78 = useNavigation(), previousMonth = _a78.previousMonth, nextMonth = _a78.nextMonth, goToMonth = _a78.goToMonth, displayMonths = _a78.displayMonths;
  var displayIndex = displayMonths.findIndex(function(month) {
    return isSameMonth(props.displayMonth, month);
  });
  var isFirst = displayIndex === 0;
  var isLast = displayIndex === displayMonths.length - 1;
  var hideNext = numberOfMonths > 1 && (isFirst || !isLast);
  var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);
  var handlePreviousClick = function() {
    if (!previousMonth)
      return;
    goToMonth(previousMonth);
  };
  var handleNextClick = function() {
    if (!nextMonth)
      return;
    goToMonth(nextMonth);
  };
  return jsxRuntimeExports.jsx(Navigation, { displayMonth: props.displayMonth, hideNext, hidePrevious, nextMonth, previousMonth, onPreviousClick: handlePreviousClick, onNextClick: handleNextClick });
}
function Caption(props) {
  var _a78;
  var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;
  var CaptionLabelComponent = (_a78 = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a78 !== void 0 ? _a78 : CaptionLabel;
  var caption;
  if (disableNavigation) {
    caption = jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth });
  } else if (captionLayout === "dropdown") {
    caption = jsxRuntimeExports.jsx(CaptionDropdowns, { displayMonth: props.displayMonth, id: props.id });
  } else if (captionLayout === "dropdown-buttons") {
    caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CaptionDropdowns, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id }), jsxRuntimeExports.jsx(CaptionNavigation, { displayMonth: props.displayMonth, displayIndex: props.displayIndex, id: props.id })] });
  } else {
    caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsxRuntimeExports.jsx(CaptionNavigation, { displayMonth: props.displayMonth, id: props.id })] });
  }
  return jsxRuntimeExports.jsx("div", { className: classNames.caption, style: styles.caption, children: caption });
}
function Footer(props) {
  var _a78 = useDayPicker(), footer = _a78.footer, styles = _a78.styles, tfoot = _a78.classNames.tfoot;
  if (!footer)
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  return jsxRuntimeExports.jsx("tfoot", { className: tfoot, style: styles.tfoot, children: jsxRuntimeExports.jsx("tr", { children: jsxRuntimeExports.jsx("td", { colSpan: 8, children: footer }) }) });
}
function getWeekdays(locale, weekStartsOn, ISOWeek) {
  var start = ISOWeek ? startOfISOWeek(/* @__PURE__ */ new Date()) : startOfWeek(/* @__PURE__ */ new Date(), { locale, weekStartsOn });
  var days = [];
  for (var i2 = 0; i2 < 7; i2++) {
    var day = addDays(start, i2);
    days.push(day);
  }
  return days;
}
function HeadRow() {
  var _a78 = useDayPicker(), classNames = _a78.classNames, styles = _a78.styles, showWeekNumber = _a78.showWeekNumber, locale = _a78.locale, weekStartsOn = _a78.weekStartsOn, ISOWeek = _a78.ISOWeek, formatWeekdayName2 = _a78.formatters.formatWeekdayName, labelWeekday2 = _a78.labels.labelWeekday;
  var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);
  return jsxRuntimeExports.jsxs("tr", { style: styles.head_row, className: classNames.head_row, children: [showWeekNumber && jsxRuntimeExports.jsx("td", { style: styles.head_cell, className: classNames.head_cell }), weekdays.map(function(weekday, i2) {
    return jsxRuntimeExports.jsx("th", { scope: "col", className: classNames.head_cell, style: styles.head_cell, "aria-label": labelWeekday2(weekday, { locale }), children: formatWeekdayName2(weekday, { locale }) }, i2);
  })] });
}
function Head() {
  var _a78;
  var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
  var HeadRowComponent = (_a78 = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a78 !== void 0 ? _a78 : HeadRow;
  return jsxRuntimeExports.jsx("thead", { style: styles.head, className: classNames.head, children: jsxRuntimeExports.jsx(HeadRowComponent, {}) });
}
function DayContent(props) {
  var _a78 = useDayPicker(), locale = _a78.locale, formatDay2 = _a78.formatters.formatDay;
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: formatDay2(props.date, { locale }) });
}
function SelectMultipleProvider(props) {
  if (!isDayPickerMultiple(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        disabled: []
      }
    };
    return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectMultipleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectMultipleProviderInternal(_a78) {
  var initialProps = _a78.initialProps, children = _a78.children;
  var selected = initialProps.selected, min2 = initialProps.min, max2 = initialProps.max;
  var onDayClick = function(day, activeModifiers, e2) {
    var _a210, _b;
    (_a210 = initialProps.onDayClick) === null || _a210 === void 0 ? void 0 : _a210.call(initialProps, day, activeModifiers, e2);
    var isMinSelected = Boolean(activeModifiers.selected && min2 && (selected === null || selected === void 0 ? void 0 : selected.length) === min2);
    if (isMinSelected) {
      return;
    }
    var isMaxSelected = Boolean(!activeModifiers.selected && max2 && (selected === null || selected === void 0 ? void 0 : selected.length) === max2);
    if (isMaxSelected) {
      return;
    }
    var selectedDays = selected ? __spreadArray([], selected, true) : [];
    if (activeModifiers.selected) {
      var index3 = selectedDays.findIndex(function(selectedDay) {
        return isSameDay(day, selectedDay);
      });
      selectedDays.splice(index3, 1);
    } else {
      selectedDays.push(day);
    }
    (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day, activeModifiers, e2);
  };
  var modifiers = {
    disabled: []
  };
  if (selected) {
    modifiers.disabled.push(function(day) {
      var isMaxSelected = max2 && selected.length > max2 - 1;
      var isSelected = selected.some(function(selectedDay) {
        return isSameDay(selectedDay, day);
      });
      return Boolean(isMaxSelected && !isSelected);
    });
  }
  var contextValue = {
    selected,
    onDayClick,
    modifiers
  };
  return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, { value: contextValue, children });
}
function useSelectMultiple() {
  var context = reactExports.useContext(SelectMultipleContext);
  if (!context) {
    throw new Error("useSelectMultiple must be used within a SelectMultipleProvider");
  }
  return context;
}
function addToRange(day, range) {
  var _a78 = range || {}, from = _a78.from, to = _a78.to;
  if (from && to) {
    if (isSameDay(to, day) && isSameDay(from, day)) {
      return void 0;
    }
    if (isSameDay(to, day)) {
      return { from: to, to: void 0 };
    }
    if (isSameDay(from, day)) {
      return void 0;
    }
    if (isAfter(from, day)) {
      return { from: day, to };
    }
    return { from, to: day };
  }
  if (to) {
    if (isAfter(day, to)) {
      return { from: to, to: day };
    }
    return { from: day, to };
  }
  if (from) {
    if (isBefore(day, from)) {
      return { from: day, to: from };
    }
    return { from, to: day };
  }
  return { from: day, to: void 0 };
}
function SelectRangeProvider(props) {
  if (!isDayPickerRange(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0,
      modifiers: {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
      }
    };
    return jsxRuntimeExports.jsx(SelectRangeContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectRangeProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectRangeProviderInternal(_a78) {
  var initialProps = _a78.initialProps, children = _a78.children;
  var selected = initialProps.selected;
  var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;
  var min2 = initialProps.min;
  var max2 = initialProps.max;
  var onDayClick = function(day, activeModifiers, e2) {
    var _a210, _b2;
    (_a210 = initialProps.onDayClick) === null || _a210 === void 0 ? void 0 : _a210.call(initialProps, day, activeModifiers, e2);
    var newRange = addToRange(day, selected);
    (_b2 = initialProps.onSelect) === null || _b2 === void 0 ? void 0 : _b2.call(initialProps, newRange, day, activeModifiers, e2);
  };
  var modifiers = {
    range_start: [],
    range_end: [],
    range_middle: [],
    disabled: []
  };
  if (selectedFrom) {
    modifiers.range_start = [selectedFrom];
    if (!selectedTo) {
      modifiers.range_end = [selectedFrom];
    } else {
      modifiers.range_end = [selectedTo];
      if (!isSameDay(selectedFrom, selectedTo)) {
        modifiers.range_middle = [
          {
            after: selectedFrom,
            before: selectedTo
          }
        ];
      }
    }
  } else if (selectedTo) {
    modifiers.range_start = [selectedTo];
    modifiers.range_end = [selectedTo];
  }
  if (min2) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedFrom, min2 - 1),
        before: addDays(selectedFrom, min2 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: selectedFrom,
        before: addDays(selectedFrom, min2 - 1)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        after: subDays(selectedTo, min2 - 1),
        before: addDays(selectedTo, min2 - 1)
      });
    }
  }
  if (max2) {
    if (selectedFrom && !selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedFrom, -max2 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedFrom, max2 - 1)
      });
    }
    if (selectedFrom && selectedTo) {
      var selectedCount = differenceInCalendarDays(selectedTo, selectedFrom) + 1;
      var offset2 = max2 - selectedCount;
      modifiers.disabled.push({
        before: subDays(selectedFrom, offset2)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, offset2)
      });
    }
    if (!selectedFrom && selectedTo) {
      modifiers.disabled.push({
        before: addDays(selectedTo, -max2 + 1)
      });
      modifiers.disabled.push({
        after: addDays(selectedTo, max2 - 1)
      });
    }
  }
  return jsxRuntimeExports.jsx(SelectRangeContext.Provider, { value: { selected, onDayClick, modifiers }, children });
}
function useSelectRange() {
  var context = reactExports.useContext(SelectRangeContext);
  if (!context) {
    throw new Error("useSelectRange must be used within a SelectRangeProvider");
  }
  return context;
}
function matcherToArray(matcher) {
  if (Array.isArray(matcher)) {
    return __spreadArray([], matcher, true);
  } else if (matcher !== void 0) {
    return [matcher];
  } else {
    return [];
  }
}
function getCustomModifiers(dayModifiers) {
  var customModifiers = {};
  Object.entries(dayModifiers).forEach(function(_a78) {
    var modifier = _a78[0], matcher = _a78[1];
    customModifiers[modifier] = matcherToArray(matcher);
  });
  return customModifiers;
}
function getInternalModifiers(dayPicker, selectMultiple, selectRange) {
  var _a78;
  var internalModifiers = (_a78 = {}, _a78[Selected] = matcherToArray(dayPicker.selected), _a78[Disabled] = matcherToArray(dayPicker.disabled), _a78[Hidden] = matcherToArray(dayPicker.hidden), _a78[Today] = [dayPicker.today], _a78[RangeEnd] = [], _a78[RangeMiddle] = [], _a78[RangeStart] = [], _a78[Outside] = [], _a78);
  if (dayPicker.fromDate) {
    internalModifiers[Disabled].push({ before: dayPicker.fromDate });
  }
  if (dayPicker.toDate) {
    internalModifiers[Disabled].push({ after: dayPicker.toDate });
  }
  if (isDayPickerMultiple(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);
  } else if (isDayPickerRange(dayPicker)) {
    internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);
    internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];
    internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];
    internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];
  }
  return internalModifiers;
}
function ModifiersProvider(props) {
  var dayPicker = useDayPicker();
  var selectMultiple = useSelectMultiple();
  var selectRange = useSelectRange();
  var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);
  var customModifiers = getCustomModifiers(dayPicker.modifiers);
  var modifiers = __assign(__assign({}, internalModifiers), customModifiers);
  return jsxRuntimeExports.jsx(ModifiersContext.Provider, { value: modifiers, children: props.children });
}
function useModifiers() {
  var context = reactExports.useContext(ModifiersContext);
  if (!context) {
    throw new Error("useModifiers must be used within a ModifiersProvider");
  }
  return context;
}
function isDateInterval(matcher) {
  return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
}
function isDateRange(value) {
  return Boolean(value && typeof value === "object" && "from" in value);
}
function isDateAfterType(value) {
  return Boolean(value && typeof value === "object" && "after" in value);
}
function isDateBeforeType(value) {
  return Boolean(value && typeof value === "object" && "before" in value);
}
function isDayOfWeekType(value) {
  return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
}
function isDateInRange(date, range) {
  var _a78;
  var from = range.from, to = range.to;
  if (from && to) {
    var isRangeInverted = differenceInCalendarDays(to, from) < 0;
    if (isRangeInverted) {
      _a78 = [to, from], from = _a78[0], to = _a78[1];
    }
    var isInRange = differenceInCalendarDays(date, from) >= 0 && differenceInCalendarDays(to, date) >= 0;
    return isInRange;
  }
  if (to) {
    return isSameDay(to, date);
  }
  if (from) {
    return isSameDay(from, date);
  }
  return false;
}
function isDateType(value) {
  return isDate(value);
}
function isArrayOfDates(value) {
  return Array.isArray(value) && value.every(isDate);
}
function isMatch(day, matchers) {
  return matchers.some(function(matcher) {
    if (typeof matcher === "boolean") {
      return matcher;
    }
    if (isDateType(matcher)) {
      return isSameDay(day, matcher);
    }
    if (isArrayOfDates(matcher)) {
      return matcher.includes(day);
    }
    if (isDateRange(matcher)) {
      return isDateInRange(day, matcher);
    }
    if (isDayOfWeekType(matcher)) {
      return matcher.dayOfWeek.includes(day.getDay());
    }
    if (isDateInterval(matcher)) {
      var diffBefore = differenceInCalendarDays(matcher.before, day);
      var diffAfter = differenceInCalendarDays(matcher.after, day);
      var isDayBefore = diffBefore > 0;
      var isDayAfter = diffAfter < 0;
      var isClosedInterval = isAfter(matcher.before, matcher.after);
      if (isClosedInterval) {
        return isDayAfter && isDayBefore;
      } else {
        return isDayBefore || isDayAfter;
      }
    }
    if (isDateAfterType(matcher)) {
      return differenceInCalendarDays(day, matcher.after) > 0;
    }
    if (isDateBeforeType(matcher)) {
      return differenceInCalendarDays(matcher.before, day) > 0;
    }
    if (typeof matcher === "function") {
      return matcher(day);
    }
    return false;
  });
}
function getActiveModifiers(day, modifiers, displayMonth) {
  var matchedModifiers = Object.keys(modifiers).reduce(function(result, key) {
    var modifier = modifiers[key];
    if (isMatch(day, modifier)) {
      result.push(key);
    }
    return result;
  }, []);
  var activeModifiers = {};
  matchedModifiers.forEach(function(modifier) {
    return activeModifiers[modifier] = true;
  });
  if (displayMonth && !isSameMonth(day, displayMonth)) {
    activeModifiers.outside = true;
  }
  return activeModifiers;
}
function getInitialFocusTarget(displayMonths, modifiers) {
  var firstDayInMonth = startOfMonth(displayMonths[0]);
  var lastDayInMonth = endOfMonth(displayMonths[displayMonths.length - 1]);
  var firstFocusableDay;
  var today;
  var date = firstDayInMonth;
  while (date <= lastDayInMonth) {
    var activeModifiers = getActiveModifiers(date, modifiers);
    var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
    if (!isFocusable) {
      date = addDays(date, 1);
      continue;
    }
    if (activeModifiers.selected) {
      return date;
    }
    if (activeModifiers.today && !today) {
      today = date;
    }
    if (!firstFocusableDay) {
      firstFocusableDay = date;
    }
    date = addDays(date, 1);
  }
  if (today) {
    return today;
  } else {
    return firstFocusableDay;
  }
}
function getNextFocus(focusedDay, options) {
  var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a78 = options.retry, retry = _a78 === void 0 ? { count: 0, lastFocused: focusedDay } : _a78;
  var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate2 = context.toDate, locale = context.locale;
  var moveFns = {
    day: addDays,
    week: addWeeks,
    month: addMonths,
    year: addYears,
    startOfWeek: function(date) {
      return context.ISOWeek ? startOfISOWeek(date) : startOfWeek(date, { locale, weekStartsOn });
    },
    endOfWeek: function(date) {
      return context.ISOWeek ? endOfISOWeek(date) : endOfWeek(date, { locale, weekStartsOn });
    }
  };
  var newFocusedDay = moveFns[moveBy](focusedDay, direction === "after" ? 1 : -1);
  if (direction === "before" && fromDate) {
    newFocusedDay = max([fromDate, newFocusedDay]);
  } else if (direction === "after" && toDate2) {
    newFocusedDay = min([toDate2, newFocusedDay]);
  }
  var isFocusable = true;
  if (modifiers) {
    var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);
    isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
  }
  if (isFocusable) {
    return newFocusedDay;
  } else {
    if (retry.count > MAX_RETRY) {
      return retry.lastFocused;
    }
    return getNextFocus(newFocusedDay, {
      moveBy,
      direction,
      context,
      modifiers,
      retry: __assign(__assign({}, retry), { count: retry.count + 1 })
    });
  }
}
function FocusProvider(props) {
  var navigation = useNavigation();
  var modifiers = useModifiers();
  var _a78 = reactExports.useState(), focusedDay = _a78[0], setFocusedDay = _a78[1];
  var _b = reactExports.useState(), lastFocused = _b[0], setLastFocused = _b[1];
  var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);
  var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : lastFocused && navigation.isDateDisplayed(lastFocused)) ? lastFocused : initialFocusTarget;
  var blur = function() {
    setLastFocused(focusedDay);
    setFocusedDay(void 0);
  };
  var focus = function(date) {
    setFocusedDay(date);
  };
  var context = useDayPicker();
  var moveFocus = function(moveBy, direction) {
    if (!focusedDay)
      return;
    var nextFocused = getNextFocus(focusedDay, {
      moveBy,
      direction,
      context,
      modifiers
    });
    if (isSameDay(focusedDay, nextFocused))
      return void 0;
    navigation.goToDate(nextFocused, focusedDay);
    focus(nextFocused);
  };
  var value = {
    focusedDay,
    focusTarget,
    blur,
    focus,
    focusDayAfter: function() {
      return moveFocus("day", "after");
    },
    focusDayBefore: function() {
      return moveFocus("day", "before");
    },
    focusWeekAfter: function() {
      return moveFocus("week", "after");
    },
    focusWeekBefore: function() {
      return moveFocus("week", "before");
    },
    focusMonthBefore: function() {
      return moveFocus("month", "before");
    },
    focusMonthAfter: function() {
      return moveFocus("month", "after");
    },
    focusYearBefore: function() {
      return moveFocus("year", "before");
    },
    focusYearAfter: function() {
      return moveFocus("year", "after");
    },
    focusStartOfWeek: function() {
      return moveFocus("startOfWeek", "before");
    },
    focusEndOfWeek: function() {
      return moveFocus("endOfWeek", "after");
    }
  };
  return jsxRuntimeExports.jsx(FocusContext.Provider, { value, children: props.children });
}
function useFocusContext() {
  var context = reactExports.useContext(FocusContext);
  if (!context) {
    throw new Error("useFocusContext must be used within a FocusProvider");
  }
  return context;
}
function useActiveModifiers(day, displayMonth) {
  var modifiers = useModifiers();
  var activeModifiers = getActiveModifiers(day, modifiers, displayMonth);
  return activeModifiers;
}
function SelectSingleProvider(props) {
  if (!isDayPickerSingle(props.initialProps)) {
    var emptyContextValue = {
      selected: void 0
    };
    return jsxRuntimeExports.jsx(SelectSingleContext.Provider, { value: emptyContextValue, children: props.children });
  }
  return jsxRuntimeExports.jsx(SelectSingleProviderInternal, { initialProps: props.initialProps, children: props.children });
}
function SelectSingleProviderInternal(_a78) {
  var initialProps = _a78.initialProps, children = _a78.children;
  var onDayClick = function(day, activeModifiers, e2) {
    var _a210, _b, _c;
    (_a210 = initialProps.onDayClick) === null || _a210 === void 0 ? void 0 : _a210.call(initialProps, day, activeModifiers, e2);
    if (activeModifiers.selected && !initialProps.required) {
      (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, void 0, day, activeModifiers, e2);
      return;
    }
    (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day, day, activeModifiers, e2);
  };
  var contextValue = {
    selected: initialProps.selected,
    onDayClick
  };
  return jsxRuntimeExports.jsx(SelectSingleContext.Provider, { value: contextValue, children });
}
function useSelectSingle() {
  var context = reactExports.useContext(SelectSingleContext);
  if (!context) {
    throw new Error("useSelectSingle must be used within a SelectSingleProvider");
  }
  return context;
}
function useDayEventHandlers(date, activeModifiers) {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range = useSelectRange();
  var _a78 = useFocusContext(), focusDayAfter = _a78.focusDayAfter, focusDayBefore = _a78.focusDayBefore, focusWeekAfter = _a78.focusWeekAfter, focusWeekBefore = _a78.focusWeekBefore, blur = _a78.blur, focus = _a78.focus, focusMonthBefore = _a78.focusMonthBefore, focusMonthAfter = _a78.focusMonthAfter, focusYearBefore = _a78.focusYearBefore, focusYearAfter = _a78.focusYearAfter, focusStartOfWeek = _a78.focusStartOfWeek, focusEndOfWeek = _a78.focusEndOfWeek;
  var onClick = function(e2) {
    var _a210, _b, _c, _d;
    if (isDayPickerSingle(dayPicker)) {
      (_a210 = single.onDayClick) === null || _a210 === void 0 ? void 0 : _a210.call(single, date, activeModifiers, e2);
    } else if (isDayPickerMultiple(dayPicker)) {
      (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e2);
    } else if (isDayPickerRange(dayPicker)) {
      (_c = range.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range, date, activeModifiers, e2);
    } else {
      (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e2);
    }
  };
  var onFocus = function(e2) {
    var _a210;
    focus(date);
    (_a210 = dayPicker.onDayFocus) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onBlur = function(e2) {
    var _a210;
    blur();
    (_a210 = dayPicker.onDayBlur) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onMouseEnter = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayMouseEnter) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onMouseLeave = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayMouseLeave) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onPointerEnter = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayPointerEnter) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onPointerLeave = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayPointerLeave) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onTouchCancel = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayTouchCancel) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onTouchEnd = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayTouchEnd) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onTouchMove = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayTouchMove) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onTouchStart = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayTouchStart) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onKeyUp = function(e2) {
    var _a210;
    (_a210 = dayPicker.onDayKeyUp) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var onKeyDown = function(e2) {
    var _a210;
    switch (e2.key) {
      case "ArrowLeft":
        e2.preventDefault();
        e2.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayAfter() : focusDayBefore();
        break;
      case "ArrowRight":
        e2.preventDefault();
        e2.stopPropagation();
        dayPicker.dir === "rtl" ? focusDayBefore() : focusDayAfter();
        break;
      case "ArrowDown":
        e2.preventDefault();
        e2.stopPropagation();
        focusWeekAfter();
        break;
      case "ArrowUp":
        e2.preventDefault();
        e2.stopPropagation();
        focusWeekBefore();
        break;
      case "PageUp":
        e2.preventDefault();
        e2.stopPropagation();
        e2.shiftKey ? focusYearBefore() : focusMonthBefore();
        break;
      case "PageDown":
        e2.preventDefault();
        e2.stopPropagation();
        e2.shiftKey ? focusYearAfter() : focusMonthAfter();
        break;
      case "Home":
        e2.preventDefault();
        e2.stopPropagation();
        focusStartOfWeek();
        break;
      case "End":
        e2.preventDefault();
        e2.stopPropagation();
        focusEndOfWeek();
        break;
    }
    (_a210 = dayPicker.onDayKeyDown) === null || _a210 === void 0 ? void 0 : _a210.call(dayPicker, date, activeModifiers, e2);
  };
  var eventHandlers = {
    onClick,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyUp,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    onPointerLeave,
    onTouchCancel,
    onTouchEnd,
    onTouchMove,
    onTouchStart
  };
  return eventHandlers;
}
function useSelectedDays() {
  var dayPicker = useDayPicker();
  var single = useSelectSingle();
  var multiple = useSelectMultiple();
  var range = useSelectRange();
  var selectedDays = isDayPickerSingle(dayPicker) ? single.selected : isDayPickerMultiple(dayPicker) ? multiple.selected : isDayPickerRange(dayPicker) ? range.selected : void 0;
  return selectedDays;
}
function isInternalModifier(modifier) {
  return Object.values(InternalModifier).includes(modifier);
}
function getDayClassNames(dayPicker, activeModifiers) {
  var classNames = [dayPicker.classNames.day];
  Object.keys(activeModifiers).forEach(function(modifier) {
    var customClassName = dayPicker.modifiersClassNames[modifier];
    if (customClassName) {
      classNames.push(customClassName);
    } else if (isInternalModifier(modifier)) {
      var internalClassName = dayPicker.classNames["day_".concat(modifier)];
      if (internalClassName) {
        classNames.push(internalClassName);
      }
    }
  });
  return classNames;
}
function getDayStyle(dayPicker, activeModifiers) {
  var style = __assign({}, dayPicker.styles.day);
  Object.keys(activeModifiers).forEach(function(modifier) {
    var _a78;
    style = __assign(__assign({}, style), (_a78 = dayPicker.modifiersStyles) === null || _a78 === void 0 ? void 0 : _a78[modifier]);
  });
  return style;
}
function useDayRender(day, displayMonth, buttonRef) {
  var _a78;
  var _b, _c;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var activeModifiers = useActiveModifiers(day, displayMonth);
  var eventHandlers = useDayEventHandlers(day, activeModifiers);
  var selectedDays = useSelectedDays();
  var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== "default");
  reactExports.useEffect(function() {
    var _a210;
    if (activeModifiers.outside)
      return;
    if (!focusContext.focusedDay)
      return;
    if (!isButton)
      return;
    if (isSameDay(focusContext.focusedDay, day)) {
      (_a210 = buttonRef.current) === null || _a210 === void 0 ? void 0 : _a210.focus();
    }
  }, [
    focusContext.focusedDay,
    day,
    buttonRef,
    isButton,
    activeModifiers.outside
  ]);
  var className = getDayClassNames(dayPicker, activeModifiers).join(" ");
  var style = getDayStyle(dayPicker, activeModifiers);
  var isHidden = Boolean(activeModifiers.outside && !dayPicker.showOutsideDays || activeModifiers.hidden);
  var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;
  var children = jsxRuntimeExports.jsx(DayContentComponent, { date: day, displayMonth, activeModifiers });
  var divProps = {
    style,
    className,
    children,
    role: "gridcell"
  };
  var isFocusTarget = focusContext.focusTarget && isSameDay(focusContext.focusTarget, day) && !activeModifiers.outside;
  var isFocused = focusContext.focusedDay && isSameDay(focusContext.focusedDay, day);
  var buttonProps = __assign(__assign(__assign({}, divProps), (_a78 = { disabled: activeModifiers.disabled, role: "gridcell" }, _a78["aria-selected"] = activeModifiers.selected, _a78.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a78)), eventHandlers);
  var dayRender = {
    isButton,
    isHidden,
    activeModifiers,
    selectedDays,
    buttonProps,
    divProps
  };
  return dayRender;
}
function Day(props) {
  var buttonRef = reactExports.useRef(null);
  var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);
  if (dayRender.isHidden) {
    return jsxRuntimeExports.jsx("div", { role: "gridcell" });
  }
  if (!dayRender.isButton) {
    return jsxRuntimeExports.jsx("div", __assign({}, dayRender.divProps));
  }
  return jsxRuntimeExports.jsx(Button, __assign({ name: "day", ref: buttonRef }, dayRender.buttonProps));
}
function WeekNumber(props) {
  var weekNumber = props.number, dates = props.dates;
  var _a78 = useDayPicker(), onWeekNumberClick = _a78.onWeekNumberClick, styles = _a78.styles, classNames = _a78.classNames, locale = _a78.locale, labelWeekNumber2 = _a78.labels.labelWeekNumber, formatWeekNumber2 = _a78.formatters.formatWeekNumber;
  var content = formatWeekNumber2(Number(weekNumber), { locale });
  if (!onWeekNumberClick) {
    return jsxRuntimeExports.jsx("span", { className: classNames.weeknumber, style: styles.weeknumber, children: content });
  }
  var label = labelWeekNumber2(Number(weekNumber), { locale });
  var handleClick = function(e2) {
    onWeekNumberClick(weekNumber, dates, e2);
  };
  return jsxRuntimeExports.jsx(Button, { name: "week-number", "aria-label": label, className: classNames.weeknumber, style: styles.weeknumber, onClick: handleClick, children: content });
}
function Row(props) {
  var _a78, _b;
  var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;
  var DayComponent = (_a78 = components === null || components === void 0 ? void 0 : components.Day) !== null && _a78 !== void 0 ? _a78 : Day;
  var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;
  var weekNumberCell;
  if (showWeekNumber) {
    weekNumberCell = jsxRuntimeExports.jsx("td", { className: classNames.cell, style: styles.cell, children: jsxRuntimeExports.jsx(WeeknumberComponent, { number: props.weekNumber, dates: props.dates }) });
  }
  return jsxRuntimeExports.jsxs("tr", { className: classNames.row, style: styles.row, children: [weekNumberCell, props.dates.map(function(date) {
    return jsxRuntimeExports.jsx("td", { className: classNames.cell, style: styles.cell, role: "presentation", children: jsxRuntimeExports.jsx(DayComponent, { displayMonth: props.displayMonth, date }) }, getUnixTime(date));
  })] });
}
function daysToMonthWeeks(fromDate, toDate2, options) {
  var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? endOfISOWeek(toDate2) : endOfWeek(toDate2, options);
  var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? startOfISOWeek(fromDate) : startOfWeek(fromDate, options);
  var nOfDays = differenceInCalendarDays(toWeek, fromWeek);
  var days = [];
  for (var i2 = 0; i2 <= nOfDays; i2++) {
    days.push(addDays(fromWeek, i2));
  }
  var weeksInMonth = days.reduce(function(result, date) {
    var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? getISOWeek(date) : getWeek(date, options);
    var existingWeek = result.find(function(value) {
      return value.weekNumber === weekNumber;
    });
    if (existingWeek) {
      existingWeek.dates.push(date);
      return result;
    }
    result.push({
      weekNumber,
      dates: [date]
    });
    return result;
  }, []);
  return weeksInMonth;
}
function getMonthWeeks(month, options) {
  var weeksInMonth = daysToMonthWeeks(startOfMonth(month), endOfMonth(month), options);
  if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {
    var nrOfMonthWeeks = getWeeksInMonth(month, options);
    if (nrOfMonthWeeks < 6) {
      var lastWeek = weeksInMonth[weeksInMonth.length - 1];
      var lastDate = lastWeek.dates[lastWeek.dates.length - 1];
      var toDate2 = addWeeks(lastDate, 6 - nrOfMonthWeeks);
      var extraWeeks = daysToMonthWeeks(addWeeks(lastDate, 1), toDate2, options);
      weeksInMonth.push.apply(weeksInMonth, extraWeeks);
    }
  }
  return weeksInMonth;
}
function Table$1(props) {
  var _a78, _b, _c;
  var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;
  var weeks = getMonthWeeks(props.displayMonth, {
    useFixedWeeks: Boolean(fixedWeeks),
    ISOWeek,
    locale,
    weekStartsOn,
    firstWeekContainsDate
  });
  var HeadComponent = (_a78 = components === null || components === void 0 ? void 0 : components.Head) !== null && _a78 !== void 0 ? _a78 : Head;
  var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : Row;
  var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;
  return jsxRuntimeExports.jsxs("table", { id: props.id, className: classNames.table, style: styles.table, role: "grid", "aria-labelledby": props["aria-labelledby"], children: [!hideHead && jsxRuntimeExports.jsx(HeadComponent, {}), jsxRuntimeExports.jsx("tbody", { className: classNames.tbody, style: styles.tbody, children: weeks.map(function(week) {
    return jsxRuntimeExports.jsx(RowComponent, { displayMonth: props.displayMonth, dates: week.dates, weekNumber: week.weekNumber }, week.weekNumber);
  }) }), jsxRuntimeExports.jsx(FooterComponent, { displayMonth: props.displayMonth })] });
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function genId() {
  return "react-day-picker-".concat(++id);
}
function useId(providedId) {
  var _a78;
  var initialId = providedId !== null && providedId !== void 0 ? providedId : serverHandoffComplete ? genId() : null;
  var _b = reactExports.useState(initialId), id22 = _b[0], setId = _b[1];
  useIsomorphicLayoutEffect(function() {
    if (id22 === null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return (_a78 = providedId !== null && providedId !== void 0 ? providedId : id22) !== null && _a78 !== void 0 ? _a78 : void 0;
}
function Month(props) {
  var _a78;
  var _b;
  var dayPicker = useDayPicker();
  var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;
  var displayMonths = useNavigation().displayMonths;
  var captionId = useId(dayPicker.id ? "".concat(dayPicker.id, "-").concat(props.displayIndex) : void 0);
  var tableId = dayPicker.id ? "".concat(dayPicker.id, "-grid-").concat(props.displayIndex) : void 0;
  var className = [classNames.month];
  var style = styles.month;
  var isStart = props.displayIndex === 0;
  var isEnd = props.displayIndex === displayMonths.length - 1;
  var isCenter = !isStart && !isEnd;
  if (dir === "rtl") {
    _a78 = [isStart, isEnd], isEnd = _a78[0], isStart = _a78[1];
  }
  if (isStart) {
    className.push(classNames.caption_start);
    style = __assign(__assign({}, style), styles.caption_start);
  }
  if (isEnd) {
    className.push(classNames.caption_end);
    style = __assign(__assign({}, style), styles.caption_end);
  }
  if (isCenter) {
    className.push(classNames.caption_between);
    style = __assign(__assign({}, style), styles.caption_between);
  }
  var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;
  return jsxRuntimeExports.jsxs("div", { className: className.join(" "), style, children: [jsxRuntimeExports.jsx(CaptionComponent, { id: captionId, displayMonth: props.displayMonth, displayIndex: props.displayIndex }), jsxRuntimeExports.jsx(Table$1, { id: tableId, "aria-labelledby": captionId, displayMonth: props.displayMonth })] }, props.displayIndex);
}
function Months(props) {
  var _a78 = useDayPicker(), classNames = _a78.classNames, styles = _a78.styles;
  return jsxRuntimeExports.jsx("div", { className: classNames.months, style: styles.months, children: props.children });
}
function Root(_a78) {
  var _b, _c;
  var initialProps = _a78.initialProps;
  var dayPicker = useDayPicker();
  var focusContext = useFocusContext();
  var navigation = useNavigation();
  var _d = reactExports.useState(false), hasInitialFocus = _d[0], setHasInitialFocus = _d[1];
  reactExports.useEffect(function() {
    if (!dayPicker.initialFocus)
      return;
    if (!focusContext.focusTarget)
      return;
    if (hasInitialFocus)
      return;
    focusContext.focus(focusContext.focusTarget);
    setHasInitialFocus(true);
  }, [
    dayPicker.initialFocus,
    hasInitialFocus,
    focusContext.focus,
    focusContext.focusTarget,
    focusContext
  ]);
  var classNames = [dayPicker.classNames.root, dayPicker.className];
  if (dayPicker.numberOfMonths > 1) {
    classNames.push(dayPicker.classNames.multiple_months);
  }
  if (dayPicker.showWeekNumber) {
    classNames.push(dayPicker.classNames.with_weeknumber);
  }
  var style = __assign(__assign({}, dayPicker.styles.root), dayPicker.style);
  var dataAttributes = Object.keys(initialProps).filter(function(key) {
    return key.startsWith("data-");
  }).reduce(function(attrs, key) {
    var _a210;
    return __assign(__assign({}, attrs), (_a210 = {}, _a210[key] = initialProps[key], _a210));
  }, {});
  var MonthsComponent = (_c = (_b = initialProps.components) === null || _b === void 0 ? void 0 : _b.Months) !== null && _c !== void 0 ? _c : Months;
  return jsxRuntimeExports.jsx("div", __assign({ className: classNames.join(" "), style, dir: dayPicker.dir, id: dayPicker.id, nonce: initialProps.nonce, title: initialProps.title, lang: initialProps.lang }, dataAttributes, { children: jsxRuntimeExports.jsx(MonthsComponent, { children: navigation.displayMonths.map(function(month, i2) {
    return jsxRuntimeExports.jsx(Month, { displayIndex: i2, displayMonth: month }, i2);
  }) }) }));
}
function RootProvider(props) {
  var children = props.children, initialProps = __rest(props, ["children"]);
  return jsxRuntimeExports.jsx(DayPickerProvider, { initialProps, children: jsxRuntimeExports.jsx(NavigationProvider, { children: jsxRuntimeExports.jsx(SelectSingleProvider, { initialProps, children: jsxRuntimeExports.jsx(SelectMultipleProvider, { initialProps, children: jsxRuntimeExports.jsx(SelectRangeProvider, { initialProps, children: jsxRuntimeExports.jsx(ModifiersProvider, { children: jsxRuntimeExports.jsx(FocusProvider, { children }) }) }) }) }) }) });
}
function DayPicker(props) {
  return jsxRuntimeExports.jsx(RootProvider, __assign({}, props, { children: jsxRuntimeExports.jsx(Root, { initialProps: props }) }));
}
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    DayPicker,
    {
      showOutsideDays,
      className: cn$1("p-3", className),
      classNames: {
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn$1(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn$1(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames
      },
      components: {
        IconLeft: ({ ...props2 }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronLeft, { className: "h-4 w-4" }),
        IconRight: ({ ...props2 }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronRight, { className: "h-4 w-4" })
      },
      ...props
    }
  );
}
function DateFilteringColumnHeader({
  onDateFilter,
  onSort
}) {
  const [open, setOpen] = reactExports.useState(false);
  const [single, setSingle] = reactExports.useState();
  const [range, setRange] = reactExports.useState();
  const handleOnDateFilter = (type) => {
    if (type === "single") {
      if (!single)
        throw new Error("Single date undefined");
      onDateFilter({ type: "single", value: single });
    }
    if (type === "range") {
      if (!range)
        throw new Error("Range date undefined");
      onDateFilter({ type: "range", value: range });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        className: `-ml-3 h-8 data-[state=open]:bg-accent`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: "Enviado" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ListFilter, { className: `h-3.5 w-3.5 ml-2 text-slate-800` })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuContent, { align: "start", className: "w-fit", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Tabs,
      {
        defaultValue: "single",
        onValueChange: (val) => {
          if (val === "desc") {
            onSort({ id: "createdAt", desc: false });
            setOpen(false);
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsList, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsTrigger, { value: "single", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Calendar$1, { className: "mr-2 h-3.5 w-3.5" }),
              "Fecha"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsTrigger, { value: "range", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(CalendarDays, { className: "mr-2 h-3.5 w-3.5" }),
              "Rango"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsTrigger, { value: "desc", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowUp, { className: "mr-2 h-3.5 w-3.5" }),
              "Asc"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsContent, { value: "single", className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Calendar,
              {
                locale: es,
                mode: "single",
                selected: single,
                onSelect: setSingle,
                initialFocus: true
              }
            ),
            single && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                variant: "default",
                size: "sm",
                onClick: () => handleOnDateFilter("single"),
                children: "Aplicar"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(TabsContent, { value: "range", className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Calendar,
              {
                locale: es,
                mode: "range",
                defaultMonth: range?.from,
                selected: range,
                onSelect: setRange,
                numberOfMonths: 2
              }
            ),
            range && range.to && range.from && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                variant: "default",
                size: "sm",
                onClick: () => handleOnDateFilter("range"),
                children: "Aplicar"
              }
            )
          ] })
        ]
      }
    ) })
  ] });
}
function createdAtColumnDef({
  dateFiltering
}) {
  return {
    accessorKey: "createdAt",
    header: () => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        DateFilteringColumnHeader,
        {
          onDateFilter: dateFiltering.onDateFilter,
          onSort: dateFiltering.onSort
        }
      );
    },
    cell: ({ row }) => {
      const createdAt = row.getValue("createdAt");
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(CreatedAtCell, { createdAt });
    }
  };
}
function CreatedAtCell({ createdAt }) {
  const formatted = formatDistanceToNow(new Date(createdAt), {
    addSuffix: false,
    locale: es
  });
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: formatted.replace("alrededor de ", "") }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-xs text-slate-500", children: `${format(createdAt, "dd/MM/yyyy", { locale: es })}` })
  ] });
}
function PlaceFilteringColumnHeader({
  onFilter,
  filteringState,
  onClearFilter
}) {
  const currentFilter = filteringState.find((f3) => f3.id === "place");
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        className: `-ml-3 h-8 data-[state=open]:bg-accent`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: "Ubicaci\xF3n" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ListFilter, { className: `h-3.5 w-3.5 ml-2 text-slate-800` })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "start", children: [
      places.map((place, i2) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === place ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "place", value: place }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === place ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            place
          ]
        },
        `dropdown-filter-${place}-${i2}`
      )),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { onClick: () => onClearFilter("place"), children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(WandSparkles, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
        "Limpiar"
      ] })
    ] })
  ] });
}
function placeColumnDef({
  filtering
}) {
  return {
    accessorKey: "place",
    header: () => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        PlaceFilteringColumnHeader,
        {
          filteringState: filtering.filteringState,
          onFilter: filtering.onFilteringChange,
          onClearFilter: filtering.onClearFilter
        }
      );
    }
  };
}
function PositionFilteringColumnHeader({
  filteringState,
  onFilter,
  onClearFilter
}) {
  const currentFilter = filteringState.find((f3) => f3.id === "position");
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        className: `-ml-3 h-8 data-[state=open]:bg-accent`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: "Puesto" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ListFilter, { className: `h-3.5 w-3.5 ml-2 text-slate-800` })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "start", children: [
      positions.map((position, i2) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === position ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "position", value: position }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === position ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            position
          ]
        },
        `dropdown-filter-${position}-${i2}`
      )),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { onClick: () => onClearFilter("position"), children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(WandSparkles, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
        "Limpiar"
      ] })
    ] })
  ] });
}
function positionColumnDef({
  filtering
}) {
  return {
    accessorKey: "position",
    header: () => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        PositionFilteringColumnHeader,
        {
          filteringState: filtering.filteringState,
          onFilter: filtering.onFilteringChange,
          onClearFilter: filtering.onClearFilter
        }
      );
    }
  };
}
function StatusFilteringColumnHeader({
  onFilter,
  filteringState,
  onClearFilter
}) {
  const currentFilter = filteringState.find((f3) => f3.id === "status");
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Button$1,
      {
        variant: "ghost",
        size: "sm",
        className: `-ml-3 h-8 data-[state=open]:bg-accent`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: "Estado" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ListFilter, { className: `h-3.5 w-3.5 ml-2 text-slate-800` })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "start", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === CVSStatus.PENDING ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "status", value: CVSStatus.PENDING }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === CVSStatus.PENDING ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            "Pendiente"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === CVSStatus.REVIEWED ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "status", value: CVSStatus.REVIEWED }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === CVSStatus.REVIEWED ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            "Revisado"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === CVSStatus.REJECTED ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "status", value: CVSStatus.REJECTED }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === CVSStatus.REJECTED ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            "Rechazado"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        DropdownMenuItem,
        {
          className: currentFilter?.value === CVSStatus.SELECTED ? "bg-primary text-primary-foreground" : "",
          onClick: () => onFilter({ id: "status", value: CVSStatus.SELECTED }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Dot,
              {
                className: `mr-2 h-3.5 w-3.5 ${currentFilter?.value === CVSStatus.SELECTED ? "text-primary-foreground" : "text-muted-foreground/70"}`
              }
            ),
            "Seleccionado"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { onClick: () => onClearFilter("status"), children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(WandSparkles, { className: "mr-2 h-3.5 w-3.5 text-muted-foreground/70" }),
        "Limpiar"
      ] })
    ] })
  ] });
}
function Badge({ className, variant, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: cn$1(badgeVariants({ variant }), className), ...props });
}
function statusColumnDef({
  filtering
}) {
  return {
    accessorKey: "status",
    header: () => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        StatusFilteringColumnHeader,
        {
          filteringState: filtering.filteringState,
          onFilter: filtering.onFilteringChange,
          onClearFilter: filtering.onClearFilter
        }
      );
    },
    cell: ({ row }) => {
      const status = row.getValue("status");
      let badgeColor = "";
      let badgeText = "";
      switch (status) {
        case CVSStatus.PENDING:
          badgeColor = "bg-yellow-300 text-yellow-900 hover:bg-yellow-300/80 hover:text-yellow-900";
          badgeText = "Pendiente";
          break;
        case CVSStatus.REVIEWED:
          badgeColor = "bg-green-300 text-green-900 hover:bg-green-300/80 hover:text-green-900";
          badgeText = "Revisado";
          break;
        case CVSStatus.REJECTED:
          badgeColor = "bg-red-300 text-red-900 hover:bg-red-300/80 hover:text-red-900";
          badgeText = "Rechazado";
          break;
        case CVSStatus.SELECTED:
          badgeColor = "bg-blue-300 text-blue-900 hover:bg-blue-300/80 hover:text-blue-900";
          badgeText = "Seleccionado";
          break;
        default:
          throw new Error("Invalid status");
      }
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Badge, { className: badgeColor, children: badgeText });
    }
  };
}
function $5d3850c4d0b4e6c7$var$getState(open) {
  return open ? "open" : "closed";
}
function attachmentsColumnDef() {
  return {
    accessorKey: "attachments",
    header: () => /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-slate-800", children: "Adjuntos" }),
    cell: ({ row }) => {
      const attachments = row.getValue("attachments");
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center gap-2", children: attachments.map((att, i2) => {
        const isPdf = att.type.includes("application/pdf");
        const isVideo = att.type.includes("video/");
        if (!isPdf && !isVideo)
          throw new Error("Invalid attachment type");
        if (isPdf) {
          return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button$1,
            {
              variant: "outline",
              size: "icon",
              className: "font-normal",
              asChild: true,
              children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                "a",
                {
                  href: att.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: "flex items-center gap-1",
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(FileText, { className: "h-3.5 w-3.5" })
                }
              )
            },
            `attachment-header-${att.type}`
          );
        }
        if (isVideo) {
          return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialog, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                variant: "outline",
                size: "icon",
                className: "font-normal",
                children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Video, { className: "h-3.5 w-3.5" })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                "video",
                {
                  className: "rounded-md",
                  width: 1280,
                  height: 720,
                  controls: true,
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("source", { src: att.url, type: att.type })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogCancel, { children: "Cerrar" }) })
            ] })
          ] }, `attachment-header-${att.type}`);
        }
        return null;
      }) }, "random key");
    }
  };
}
function actionsColumnDef({
  actions,
  batchActions,
  isActionColumnLoading
}) {
  return {
    id: "actions",
    header: ({ table }) => {
      const rowSelectionState = table.getState().rowSelection;
      const rows = table.getCoreRowModel().rows;
      const someSelected = table.getIsSomeRowsSelected();
      const pageSelected = table.getIsAllPageRowsSelected();
      if (isActionColumnLoading) {
        return /* @__PURE__ */ jsxRuntimeExports$1.jsx(RefreshCcw, { className: "ml-3 h-3.5 w-3.5 text-slate-800 animate-spin" });
      }
      return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialog, { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
            Button$1,
            {
              size: "icon",
              variant: "ghost",
              className: "relative",
              disabled: !someSelected && !pageSelected,
              children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Open menu" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(Ellipsis, { className: "w-3.5 h-3.5" }),
                (someSelected || pageSelected) && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-4 h-4 flex items-center justify-center rounded-full bg-red-600 absolute top-0 right-0", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-xs font-thin text-white", children: Object.values(rowSelectionState).length }) })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "end", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuLabel, { children: "Acciones en bloque" }),
            hasSameStatus({
              status: CVSStatus.REVIEWED,
              selectedRows: selectedRows({ rowSelectionState, rows })
            }) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsRejected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(X$1, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como rechazado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsSelected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckCheck, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como seleccionado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsPending(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Clock, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como pendiente"
                  ]
                }
              )
            ] }),
            hasSameStatus({
              status: CVSStatus.REJECTED,
              selectedRows: selectedRows({ rowSelectionState, rows })
            }) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsReviewed(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como revisado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsSelected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckCheck, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como seleccionado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsPending(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Clock, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como pendiente"
                  ]
                }
              )
            ] }),
            hasSameStatus({
              status: CVSStatus.PENDING,
              selectedRows: selectedRows({ rowSelectionState, rows })
            }) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsReviewed(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como revisado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsSelected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckCheck, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como seleccionado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsRejected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(X$1, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como rechazado"
                  ]
                }
              )
            ] }),
            hasSameStatus({
              status: CVSStatus.SELECTED,
              selectedRows: selectedRows({ rowSelectionState, rows })
            }) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsReviewed(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como revisado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsRejected(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(X$1, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como rechazado"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                DropdownMenuItem,
                {
                  onClick: () => batchActions.onMarkAsPending(
                    selectedRows({ rowSelectionState, rows })
                  ),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Clock, { className: "w-3.5 h-3.5 mr-2" }),
                    "Marcar como pendiente"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { className: "text-red-500", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Trash2, { className: "w-3.5 h-3.5 mr-2" }),
              "Eliminar"
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogTitle, { children: "Est\xE1s seguro?" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogDescription, { children: "Esta acci\xF3n no puede deshacerse. Esto eliminar\xE1 permanentemente el CV y sus adjuntos." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogFooter, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogCancel, { children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                className: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                onClick: () => batchActions.onDelete(
                  selectedRows({ rowSelectionState, rows })
                ),
                children: "Eliminar"
              }
            ) })
          ] })
        ] })
      ] });
    },
    cell: ({ row }) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialog, { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenu, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Button$1, { variant: "ghost", size: "icon", className: "p-0", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Open menu" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Ellipsis, { className: "h-3.5 w-3.5" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuContent, { align: "end", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuLabel, { children: "Acciones" }),
            row.original.status !== CVSStatus.REVIEWED && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              DropdownMenuItem,
              {
                onClick: () => actions.onMarkAsReviewed(row.original),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "w-3.5 h-3.5 mr-2" }),
                  "Marcar como revisado"
                ]
              }
            ),
            row.original.status !== CVSStatus.REJECTED && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              DropdownMenuItem,
              {
                onClick: () => actions.onMarkAsRejected(row.original),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(X$1, { className: "w-3.5 h-3.5 mr-2" }),
                  "Marcar como rechazado"
                ]
              }
            ),
            row.original.status !== CVSStatus.SELECTED && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              DropdownMenuItem,
              {
                onClick: () => actions.onMarkAsSelected(row.original),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckCheck, { className: "w-3.5 h-3.5 mr-2" }),
                  "Marcar como seleccionado"
                ]
              }
            ),
            row.original.status !== CVSStatus.PENDING && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              DropdownMenuItem,
              {
                onClick: () => actions.onMarkAsPending(row.original),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(Clock, { className: "w-3.5 h-3.5 mr-2" }),
                  "Marcar como pendiente"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DropdownMenuSeparator, {}),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DropdownMenuItem, { className: "text-red-500", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Trash2, { className: "w-3.5 h-3.5 mr-2" }),
              "Eliminar"
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogTitle, { children: "Est\xE1s seguro?" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogDescription, { children: "Esta acci\xF3n no puede deshacerse. Esto eliminar\xE1 permanentemente el CV y sus adjuntos." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogFooter, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogCancel, { children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogAction, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                className: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                onClick: () => actions.onDelete(row.original),
                children: "Eliminar"
              }
            ) })
          ] })
        ] })
      ] });
    }
  };
}
function hasSameStatus({ status, selectedRows: selectedRows2 }) {
  return selectedRows2.every((r5) => r5.status === status);
}
function selectedRows({
  rowSelectionState,
  rows
}) {
  const selectedIDs = Object.keys(rowSelectionState);
  const filteredRows = rows.filter((r5) => selectedIDs.includes(r5.original.id));
  return filteredRows.map((r5) => r5.original);
}
function $010c2913dbd2fe3d$export$5cae361ad82dce8b(value) {
  const ref = reactExports.useRef({
    value,
    previous: value
  });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [
    value
  ]);
}
function $e698a72e93240346$var$isIndeterminate(checked) {
  return checked === "indeterminate";
}
function $e698a72e93240346$var$getState(checked) {
  return $e698a72e93240346$var$isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function selectionRowColumnDef() {
  return {
    id: "select-col",
    header: ({ table }) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        Checkbox,
        {
          checked: table.getIsAllRowsSelected(),
          onCheckedChange: (e2) => {
            const toggler = table.getToggleAllPageRowsSelectedHandler();
            toggler({ target: { checked: e2 } });
          }
        }
      );
    },
    cell: ({ row }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Checkbox,
      {
        checked: row.getIsSelected(),
        disabled: !row.getCanSelect(),
        onCheckedChange: row.getToggleSelectedHandler()
      }
    )
  };
}
function generateColumns({
  filtering,
  dateFiltering,
  sorting,
  actions,
  batchActions,
  isActionColumnLoading
}) {
  const columns = [
    selectionRowColumnDef(),
    nameColumnDef({ sorting }),
    createdAtColumnDef({ dateFiltering }),
    placeColumnDef({ filtering }),
    positionColumnDef({ filtering }),
    statusColumnDef({ filtering }),
    attachmentsColumnDef(),
    actionsColumnDef({ actions, batchActions, isActionColumnLoading })
  ];
  return columns;
}
function $ae6933e535247d3d$export$7d15b64cf5a3a4c4(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function $6c2e24571c90391f$export$3e6543de14f8614f(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState2);
}
function $57acba87d6e25586$var$toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function $57acba87d6e25586$var$getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function $57acba87d6e25586$var$getThumbSize(sizes) {
  const ratio = $57acba87d6e25586$var$getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function $57acba87d6e25586$var$getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = $57acba87d6e25586$var$getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [
    0,
    maxScrollPos
  ] : [
    maxScrollPos * -1,
    0
  ];
  const interpolate = $57acba87d6e25586$var$linearScale([
    minPointerPos,
    maxPointerPos
  ], scrollRange);
  return interpolate(pointerPos);
}
function $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = $57acba87d6e25586$var$getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [
    0,
    maxScrollPos
  ] : [
    maxScrollPos * -1,
    0
  ];
  const scrollWithoutMomentum = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(scrollPos, scrollClampRange);
  const interpolate = $57acba87d6e25586$var$linearScale([
    0,
    maxScrollPos
  ], [
    0,
    maxThumbPos
  ]);
  return interpolate(scrollWithoutMomentum);
}
function $57acba87d6e25586$var$linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function $57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function $57acba87d6e25586$var$useDebounceCallback(callback, delay) {
  const handleCallback = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback);
  const debounceTimerRef = reactExports.useRef(0);
  reactExports.useEffect(
    () => () => window.clearTimeout(debounceTimerRef.current),
    []
  );
  return reactExports.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [
    handleCallback,
    delay
  ]);
}
function $57acba87d6e25586$var$useResizeObserver(element, onResize) {
  const handleResize = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onResize);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [
    element,
    handleResize
  ]);
}
function CVTableRows({
  table,
  isLoading
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ScrollArea, { className: "h-[800px] overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Table2, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableHeader, { children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableRow, { children: headerGroup.headers.map((header) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableHead, { className: "text-left", children: header.isPlaceholder ? null : flexRender(
        header.column.columnDef.header,
        header.getContext()
      ) }, header.id);
    }) }, headerGroup.id)) }),
    isLoading ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(LoadingTableBody, {}) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataTableBody, { table })
  ] }) });
}
function LoadingTableBody() {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableBody, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableCell, { colSpan: 8, className: "h-44", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center flex-col gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(RefreshCcw, { className: "h-4 w-4 animate-spin mx-auto" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { children: "Cargando..." })
  ] }) }) }) });
}
function DataTableBody({ table }) {
  if (table.getRowModel().rows?.length) {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableBody, { children: table.getRowModel().rows.map((row) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      TableRow,
      {
        "data-state": row.getIsSelected() ? "selected" : void 0,
        children: row.getVisibleCells().map((cell) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableCell, { className: "text-left", children: flexRender(cell.column.columnDef.cell, cell.getContext()) }, cell.id))
      },
      row.id
    )) });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableBody, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(TableCell, { colSpan: 8, className: "h-44 text-center", children: "Actualmente no hay CVs para mostrar" }) }) });
  }
}
function $cc7e05a45900e73f$var$shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function $cc7e05a45900e73f$var$useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback((key) => {
    const search = searchRef.current + key;
    handleSearchChange(search);
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(
          () => updateSearch(""),
          1e3
        );
    })(search);
  }, [
    handleSearchChange
  ]);
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [
    searchRef,
    handleTypeaheadSearch,
    resetTypeahead
  ];
}
function $cc7e05a45900e73f$var$findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every(
    (char) => char === search[0]
  );
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = $cc7e05a45900e73f$var$wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem)
    wrappedItems = wrappedItems.filter(
      (v4) => v4 !== currentItem
    );
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function $cc7e05a45900e73f$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index3) => array[(startIndex + index3) % array.length]
  );
}
function CVTableSearch({ onSearchChange }) {
  const [searchBy, setSearchBy] = reactExports.useState("nombre");
  const [search, setSearch] = reactExports.useState({ id: "name", value: "" });
  const debaunced = useDebounce(search, 500);
  reactExports.useEffect(() => {
    onSearchChange(debaunced);
  }, [debaunced]);
  const handleOnSearch = (params) => {
    setSearch(params);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "min-w-[400px] relative", children: [
    searchBy === "nombre" ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(NameInput, { onSearchChange: handleOnSearch }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(EmailInput, { onSearchChange: handleOnSearch }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(MagnifyingGlassIcon, { className: "absolute top-1/2 left-2 transform -translate-y-1/2 w-5 h-5 text-slate-400" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Select,
      {
        value: searchBy,
        onValueChange: (value) => {
          setSearchBy(value);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectTrigger, { className: "h-8 w-[100px] absolute top-1/2 right-2 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectValue, { placeholder: "Criterio" }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(SelectContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectItem, { value: "nombre", children: "Nombre" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectItem, { value: "email", children: "Email" })
          ] })
        ]
      }
    )
  ] });
}
function EmailInput({ onSearchChange }) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Input,
    {
      className: "pl-8",
      placeholder: "Buscar por email",
      "aria-label": "Buscar por email",
      onChange: (e2) => {
        onSearchChange({ id: "email", value: e2.target.value });
      }
    }
  );
}
function NameInput({ onSearchChange }) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Input,
    {
      className: "pl-8",
      placeholder: "Buscar por nombre",
      "aria-label": "Buscar por nombre",
      onChange: (e2) => {
        onSearchChange({ id: "name", value: e2.target.value });
      }
    }
  );
}
function CVTableFilters({
  filteringState,
  dateFilteringState,
  sortingState,
  setFilters,
  setDateFilters,
  setSorting
}) {
  if (filteringState.length === 0 && sortingState.length === 0 && dateFilteringState === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center gap-1 h-10 p-2 border border-border rounded-md", children: [
    sortingState.map((item, i2) => {
      let text3 = item.id;
      switch (item.id) {
        case "createdAt":
          text3 = "enviado";
          break;
        case "name":
          text3 = "nombre";
          break;
      }
      return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Badge,
        {
          variant: "outline",
          className: "flex items-center justify-center gap-1 cursor-pointer border-yellow-400",
          onClick: () => setSorting(sortingState.filter((s3) => s3.id !== item.id)),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "capitalize", children: text3 }),
            item.desc ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowDown, { className: "h-3.5 w-3.5" }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ArrowUp, { className: "h-3.5 w-3.5" })
          ]
        },
        `table-filter-${i2}`
      );
    }),
    filteringState.map((item, i2) => {
      let text3 = item.value;
      const isStatus = item.id === "status";
      if (isStatus) {
        switch (item.value) {
          case CVSStatus.PENDING:
            text3 = "Pendiente";
            break;
          case CVSStatus.REJECTED:
            text3 = "Rechazado";
            break;
          case CVSStatus.REVIEWED:
            text3 = "Revisado";
            break;
          case CVSStatus.SELECTED:
            text3 = "Seleccionado";
            break;
          default:
            throw new Error("Invalid status");
        }
      }
      return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Badge,
        {
          variant: "outline",
          className: "flex items-center justify-center gap-1 cursor-pointer border-blue-400",
          onClick: () => setFilters(filteringState.filter((f3) => f3.id !== item.id)),
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: text3 }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Filter, { className: "w-3.5 h-3.5" })
          ]
        },
        `table-sort-${i2}`
      );
    }),
    dateFilteringState && (dateFilteringState.type === "single" ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Badge,
      {
        variant: "outline",
        className: "flex items-center justify-center gap-1 cursor-pointer border-purple-400",
        onClick: () => setDateFilters(void 0),
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: format(dateFilteringState.date, "dd/MM/yyyy", { locale: es }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Calendar$1, { className: "mr-2 h-3.5 w-3.5" })
        ]
      },
      "table-filter-date-single"
    ) : dateFilteringState.type === "range" ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Badge,
      {
        variant: "outline",
        className: "flex items-center justify-center gap-1 cursor-pointer border-purple-400",
        onClick: () => setDateFilters(void 0),
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: `${format(dateFilteringState.from, "dd/MM/yyyy", {
            locale: es
          })} - ${format(dateFilteringState.to, "dd/MM/yyyy", {
            locale: es
          })}` }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Calendar$1, { className: "mr-2 h-3.5 w-3.5" })
        ]
      },
      "table-filter-date-range"
    ) : null),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Badge,
      {
        variant: "destructive",
        className: "flex items-center justify-center gap-1 cursor-pointer",
        onClick: () => {
          setFilters([]);
          setSorting([]);
          setDateFilters(void 0);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: "Limpiar" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(WandSparkles, { className: "h-3.5 w-3.5" })
        ]
      },
      `table-filter-clean-all`
    )
  ] });
}
function CVTableStorageUsed({
  storageUsed
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    "div",
    {
      className: `flex items-center justify-center space-x-2 h-10 w-32 rounded-md`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(HardDrive, { className: "h-3.5 w-3.5 text-slate-800" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-sm text-slate-600", children: "En uso:" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("span", { className: `font-semibold text-xs text-primary`, children: [
          inGB(storageUsed),
          " GB"
        ] })
      ]
    }
  );
}
function inGB(storageInKB) {
  return Math.round(storageInKB / 1024 / 1024);
}
function CVTablePagination({
  pages,
  currentPage,
  limit,
  onLimitChange,
  onPrevPage,
  onNextPage,
  onFirstPage,
  onLastPage
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center justify-end px-2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center space-x-6 lg:space-x-8", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { className: "text-sm font-medium", children: "Filas por p\xE1gina" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Select,
        {
          value: `${limit}`,
          onValueChange: (value) => {
            onLimitChange(Number(value));
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectTrigger, { className: "h-8 w-[70px]", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectValue, {}) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectContent, { side: "top", children: [10, 20, 30, 40, 50].map((pageSize) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectItem, { value: `${pageSize}`, children: pageSize }, pageSize)) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Button$1,
        {
          variant: "outline",
          className: "hidden h-8 w-8 p-0 lg:flex",
          onClick: () => onFirstPage(),
          disabled: currentPage === 1,
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Go to first page" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DoubleArrowLeftIcon, { className: "h-4 w-4" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Button$1,
        {
          variant: "outline",
          className: "h-8 w-8 p-0",
          onClick: () => onPrevPage(),
          disabled: currentPage === 1,
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Ir a la p\xE1gina anterior" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronLeftIcon, { className: "h-4 w-4" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex w-fit items-center justify-center text-sm font-medium", children: [
        "P\xE1gina ",
        currentPage,
        " de ",
        pages.length
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Button$1,
        {
          variant: "outline",
          className: "h-8 w-8 p-0",
          onClick: () => onNextPage(),
          disabled: currentPage === pages.length,
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Ir a la siguiente p\xE1gina" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronRightIcon, { className: "h-4 w-4" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
        Button$1,
        {
          variant: "outline",
          className: "hidden h-8 w-8 p-0 lg:flex",
          onClick: () => onLastPage(),
          disabled: currentPage === pages.length,
          children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "sr-only", children: "Go to last page" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(DoubleArrowRightIcon, { className: "h-4 w-4" })
          ]
        }
      )
    ] })
  ] }) });
}
function F2(r5) {
  return function(n5) {
    for (var t5 = arguments.length, a2 = new Array(t5 > 1 ? t5 - 1 : 0), g = 1; g < t5; g++)
      a2[g - 1] = arguments[g];
    return ce(r5, n5, a2);
  };
}
function nn(r5) {
  return function() {
    for (var n5 = arguments.length, t5 = new Array(n5), a2 = 0; a2 < n5; a2++)
      t5[a2] = arguments[a2];
    return de(r5, t5);
  };
}
function d(r5, n5) {
  let t5 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : te;
  Ne && Ne(r5, null);
  let a2 = n5.length;
  for (; a2--; ) {
    let g = n5[a2];
    if (typeof g == "string") {
      let E4 = t5(g);
      E4 !== g && (Ze(n5) || (n5[a2] = E4), g = E4);
    }
    r5[g] = true;
  }
  return r5;
}
function on(r5) {
  for (let n5 = 0; n5 < r5.length; n5++)
    Q(r5, n5) || (r5[n5] = null);
  return r5;
}
function Nt(r5) {
  let n5 = Be(null);
  for (let [t5, a2] of ke(r5))
    Q(r5, t5) && (Array.isArray(a2) ? n5[t5] = on(a2) : a2 && typeof a2 == "object" && a2.constructor === Object ? n5[t5] = Nt(a2) : n5[t5] = a2);
  return n5;
}
function Jt(r5, n5) {
  for (; r5 !== null; ) {
    let a2 = Qe(r5, n5);
    if (a2) {
      if (a2.get)
        return F2(a2.get);
      if (typeof a2.value == "function")
        return F2(a2.value);
    }
    r5 = Je(r5);
  }
  function t5() {
    return null;
  }
  return t5;
}
function Fe() {
  let r5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : gn(), n5 = (l4) => Fe(l4);
  if (n5.version = "3.0.10", n5.removed = [], !r5 || !r5.document || r5.document.nodeType !== 9)
    return n5.isSupported = false, n5;
  let { document: t5 } = r5, a2 = t5, g = a2.currentScript, { DocumentFragment: E4, HTMLTemplateElement: y3, Node: A4, Element: T4, NodeFilter: mt, NamedNodeMap: wt = r5.NamedNodeMap || r5.MozNamedAttrMap, HTMLFormElement: Dt, DOMParser: It, trustedTypes: f3 } = r5, st = T4.prototype, Ct = Jt(st, "cloneNode"), Bt = Jt(st, "nextSibling"), Ht = Jt(st, "childNodes"), pt = Jt(st, "parentNode");
  if (typeof y3 == "function") {
    let l4 = t5.createElement("template");
    l4.content && l4.content.ownerDocument && (t5 = l4.content.ownerDocument);
  }
  let R5, it = "", { implementation: k4, createNodeIterator: lt2, createDocumentFragment: m2, getElementsByTagName: z4 } = t5, { importNode: Ut } = a2, P5 = {};
  n5.isSupported = typeof ke == "function" && typeof pt == "function" && k4 && k4.createHTMLDocument !== void 0;
  let { MUSTACHE_EXPR: N4, ERB_EXPR: q2, TMPLIT_EXPR: gt2, DATA_ATTR: Lt, ARIA_ATTR: ct, IS_SCRIPT_OR_DATA: et, ATTR_WHITESPACE: xt, CUSTOM_ELEMENT: W4 } = Oe, { IS_ALLOWED_URI: nt } = Oe, v4 = null, b2 = d({}, [...Ce, ...re, ...se, ...ie, ...Le]), u4 = null, D5 = d({}, [...Me, ...le, ...Pe, ...Qt]), p4 = Object.seal(Be(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), C4 = null, w5 = null, ht = true, I4 = true, Y3 = false, Tt = true, bt = false, G4 = false, Ft = false, Mt = false, ot = false, Z3 = false, vt = false, dt = true, zt = false, ee2 = "user-content-", Pt = true, yt = false, Et = {}, at = null, J3 = d({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Kt = null, Wt = d({}, ["audio", "video", "img", "source", "image", "track"]), Ot = null, Yt = d({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), At = "http://www.w3.org/1998/Math/MathML", _t = "http://www.w3.org/2000/svg", j3 = "http://www.w3.org/1999/xhtml", ut = j3, kt = false, c2 = null, _3 = d({}, [At, _t, j3], ae), S4 = null, $2 = ["application/xhtml+xml", "text/html"], V3 = "text/html", h2 = null, rt = null, qt = t5.createElement("form"), pe3 = function(e2) {
    return e2 instanceof RegExp || e2 instanceof Function;
  }, ne3 = function() {
    let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(rt && rt === e2)) {
      if ((!e2 || typeof e2 != "object") && (e2 = {}), e2 = Nt(e2), S4 = $2.indexOf(e2.PARSER_MEDIA_TYPE) === -1 ? V3 : e2.PARSER_MEDIA_TYPE, h2 = S4 === "application/xhtml+xml" ? ae : te, v4 = Q(e2, "ALLOWED_TAGS") ? d({}, e2.ALLOWED_TAGS, h2) : b2, u4 = Q(e2, "ALLOWED_ATTR") ? d({}, e2.ALLOWED_ATTR, h2) : D5, c2 = Q(e2, "ALLOWED_NAMESPACES") ? d({}, e2.ALLOWED_NAMESPACES, ae) : _3, Ot = Q(e2, "ADD_URI_SAFE_ATTR") ? d(Nt(Yt), e2.ADD_URI_SAFE_ATTR, h2) : Yt, Kt = Q(e2, "ADD_DATA_URI_TAGS") ? d(Nt(Wt), e2.ADD_DATA_URI_TAGS, h2) : Wt, at = Q(e2, "FORBID_CONTENTS") ? d({}, e2.FORBID_CONTENTS, h2) : J3, C4 = Q(e2, "FORBID_TAGS") ? d({}, e2.FORBID_TAGS, h2) : {}, w5 = Q(e2, "FORBID_ATTR") ? d({}, e2.FORBID_ATTR, h2) : {}, Et = Q(e2, "USE_PROFILES") ? e2.USE_PROFILES : false, ht = e2.ALLOW_ARIA_ATTR !== false, I4 = e2.ALLOW_DATA_ATTR !== false, Y3 = e2.ALLOW_UNKNOWN_PROTOCOLS || false, Tt = e2.ALLOW_SELF_CLOSE_IN_ATTR !== false, bt = e2.SAFE_FOR_TEMPLATES || false, G4 = e2.WHOLE_DOCUMENT || false, ot = e2.RETURN_DOM || false, Z3 = e2.RETURN_DOM_FRAGMENT || false, vt = e2.RETURN_TRUSTED_TYPE || false, Mt = e2.FORCE_BODY || false, dt = e2.SANITIZE_DOM !== false, zt = e2.SANITIZE_NAMED_PROPS || false, Pt = e2.KEEP_CONTENT !== false, yt = e2.IN_PLACE || false, nt = e2.ALLOWED_URI_REGEXP || He, ut = e2.NAMESPACE || j3, p4 = e2.CUSTOM_ELEMENT_HANDLING || {}, e2.CUSTOM_ELEMENT_HANDLING && pe3(e2.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (p4.tagNameCheck = e2.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e2.CUSTOM_ELEMENT_HANDLING && pe3(e2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (p4.attributeNameCheck = e2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e2.CUSTOM_ELEMENT_HANDLING && typeof e2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (p4.allowCustomizedBuiltInElements = e2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), bt && (I4 = false), Z3 && (ot = true), Et && (v4 = d({}, Le), u4 = [], Et.html === true && (d(v4, Ce), d(u4, Me)), Et.svg === true && (d(v4, re), d(u4, le), d(u4, Qt)), Et.svgFilters === true && (d(v4, se), d(u4, le), d(u4, Qt)), Et.mathMl === true && (d(v4, ie), d(u4, Pe), d(u4, Qt))), e2.ADD_TAGS && (v4 === b2 && (v4 = Nt(v4)), d(v4, e2.ADD_TAGS, h2)), e2.ADD_ATTR && (u4 === D5 && (u4 = Nt(u4)), d(u4, e2.ADD_ATTR, h2)), e2.ADD_URI_SAFE_ATTR && d(Ot, e2.ADD_URI_SAFE_ATTR, h2), e2.FORBID_CONTENTS && (at === J3 && (at = Nt(at)), d(at, e2.FORBID_CONTENTS, h2)), Pt && (v4["#text"] = true), G4 && d(v4, ["html", "head", "body"]), v4.table && (d(v4, ["tbody"]), delete C4.tbody), e2.TRUSTED_TYPES_POLICY) {
        if (typeof e2.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Vt('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof e2.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Vt('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        R5 = e2.TRUSTED_TYPES_POLICY, it = R5.createHTML("");
      } else
        R5 === void 0 && (R5 = hn(f3, g)), R5 !== null && typeof it == "string" && (it = R5.createHTML(""));
      O2 && O2(e2), rt = e2;
    }
  }, ge2 = d({}, ["mi", "mo", "mn", "ms", "mtext"]), he2 = d({}, ["foreignobject", "desc", "title", "annotation-xml"]), Ve2 = d({}, ["title", "style", "font", "a", "script"]), Te2 = d({}, [...re, ...se, ...an]), be2 = d({}, [...ie, ...rn]), Xe2 = function(e2) {
    let o3 = pt(e2);
    (!o3 || !o3.tagName) && (o3 = { namespaceURI: ut, tagName: "template" });
    let s3 = te(e2.tagName), x4 = te(o3.tagName);
    return c2[e2.namespaceURI] ? e2.namespaceURI === _t ? o3.namespaceURI === j3 ? s3 === "svg" : o3.namespaceURI === At ? s3 === "svg" && (x4 === "annotation-xml" || ge2[x4]) : !!Te2[s3] : e2.namespaceURI === At ? o3.namespaceURI === j3 ? s3 === "math" : o3.namespaceURI === _t ? s3 === "math" && he2[x4] : !!be2[s3] : e2.namespaceURI === j3 ? o3.namespaceURI === _t && !he2[x4] || o3.namespaceURI === At && !ge2[x4] ? false : !be2[s3] && (Ve2[s3] || !Te2[s3]) : !!(S4 === "application/xhtml+xml" && c2[e2.namespaceURI]) : false;
  }, St = function(e2) {
    jt(n5.removed, { element: e2 });
    try {
      e2.parentNode.removeChild(e2);
    } catch (o3) {
      e2.remove();
    }
  }, oe2 = function(e2, o3) {
    try {
      jt(n5.removed, { attribute: o3.getAttributeNode(e2), from: o3 });
    } catch (s3) {
      jt(n5.removed, { attribute: null, from: o3 });
    }
    if (o3.removeAttribute(e2), e2 === "is" && !u4[e2])
      if (ot || Z3)
        try {
          St(o3);
        } catch (s3) {
        }
      else
        try {
          o3.setAttribute(e2, "");
        } catch (s3) {
        }
  }, ye = function(e2) {
    let o3 = null, s3 = null;
    if (Mt)
      e2 = "<remove></remove>" + e2;
    else {
      let M3 = Ie(e2, /^[\r\n\t ]+/);
      s3 = M3 && M3[0];
    }
    S4 === "application/xhtml+xml" && ut === j3 && (e2 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e2 + "</body></html>");
    let x4 = R5 ? R5.createHTML(e2) : e2;
    if (ut === j3)
      try {
        o3 = new It().parseFromString(x4, S4);
      } catch (M3) {
      }
    if (!o3 || !o3.documentElement) {
      o3 = k4.createDocument(ut, "template", null);
      try {
        o3.documentElement.innerHTML = kt ? it : x4;
      } catch (M3) {
      }
    }
    let L4 = o3.body || o3.documentElement;
    return e2 && s3 && L4.insertBefore(t5.createTextNode(s3), L4.childNodes[0] || null), ut === j3 ? z4.call(o3, G4 ? "html" : "body")[0] : G4 ? o3.documentElement : L4;
  }, Ee2 = function(e2) {
    return lt2.call(e2.ownerDocument || e2, e2, mt.SHOW_ELEMENT | mt.SHOW_COMMENT | mt.SHOW_TEXT | mt.SHOW_PROCESSING_INSTRUCTION, null);
  }, Ke2 = function(e2) {
    return e2 instanceof Dt && (typeof e2.nodeName != "string" || typeof e2.textContent != "string" || typeof e2.removeChild != "function" || !(e2.attributes instanceof wt) || typeof e2.removeAttribute != "function" || typeof e2.setAttribute != "function" || typeof e2.namespaceURI != "string" || typeof e2.insertBefore != "function" || typeof e2.hasChildNodes != "function");
  }, we2 = function(e2) {
    return typeof A4 == "function" && e2 instanceof A4;
  }, ft = function(e2, o3, s3) {
    P5[e2] && Zt(P5[e2], (x4) => {
      x4.call(n5, o3, s3, rt);
    });
  }, xe = function(e2) {
    let o3 = null;
    if (ft("beforeSanitizeElements", e2, null), Ke2(e2))
      return St(e2), true;
    let s3 = h2(e2.nodeName);
    if (ft("uponSanitizeElement", e2, { tagName: s3, allowedTags: v4 }), e2.hasChildNodes() && !we2(e2.firstElementChild) && U(/<[/\w]/g, e2.innerHTML) && U(/<[/\w]/g, e2.textContent))
      return St(e2), true;
    if (!v4[s3] || C4[s3]) {
      if (!C4[s3] && Ae2(s3) && (p4.tagNameCheck instanceof RegExp && U(p4.tagNameCheck, s3) || p4.tagNameCheck instanceof Function && p4.tagNameCheck(s3)))
        return false;
      if (Pt && !at[s3]) {
        let x4 = pt(e2) || e2.parentNode, L4 = Ht(e2) || e2.childNodes;
        if (L4 && x4) {
          let M3 = L4.length;
          for (let B4 = M3 - 1; B4 >= 0; --B4)
            x4.insertBefore(Ct(L4[B4], true), Bt(e2));
        }
      }
      return St(e2), true;
    }
    return e2 instanceof T4 && !Xe2(e2) || (s3 === "noscript" || s3 === "noembed" || s3 === "noframes") && U(/<\/no(script|embed|frames)/i, e2.innerHTML) ? (St(e2), true) : (bt && e2.nodeType === 3 && (o3 = e2.textContent, Zt([N4, q2, gt2], (x4) => {
      o3 = $t(o3, x4, " ");
    }), e2.textContent !== o3 && (jt(n5.removed, { element: e2.cloneNode() }), e2.textContent = o3)), ft("afterSanitizeElements", e2, null), false);
  }, ve2 = function(e2, o3, s3) {
    if (dt && (o3 === "id" || o3 === "name") && (s3 in t5 || s3 in qt))
      return false;
    if (!(I4 && !w5[o3] && U(Lt, o3))) {
      if (!(ht && U(ct, o3))) {
        if (!u4[o3] || w5[o3]) {
          if (!(Ae2(e2) && (p4.tagNameCheck instanceof RegExp && U(p4.tagNameCheck, e2) || p4.tagNameCheck instanceof Function && p4.tagNameCheck(e2)) && (p4.attributeNameCheck instanceof RegExp && U(p4.attributeNameCheck, o3) || p4.attributeNameCheck instanceof Function && p4.attributeNameCheck(o3)) || o3 === "is" && p4.allowCustomizedBuiltInElements && (p4.tagNameCheck instanceof RegExp && U(p4.tagNameCheck, s3) || p4.tagNameCheck instanceof Function && p4.tagNameCheck(s3))))
            return false;
        } else if (!Ot[o3]) {
          if (!U(nt, $t(s3, xt, ""))) {
            if (!((o3 === "src" || o3 === "xlink:href" || o3 === "href") && e2 !== "script" && tn(s3, "data:") === 0 && Kt[e2])) {
              if (!(Y3 && !U(et, $t(s3, xt, "")))) {
                if (s3)
                  return false;
              }
            }
          }
        }
      }
    }
    return true;
  }, Ae2 = function(e2) {
    return e2 !== "annotation-xml" && Ie(e2, W4);
  }, _e = function(e2) {
    ft("beforeSanitizeAttributes", e2, null);
    let { attributes: o3 } = e2;
    if (!o3)
      return;
    let s3 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: u4 }, x4 = o3.length;
    for (; x4--; ) {
      let L4 = o3[x4], { name: M3, namespaceURI: B4, value: Rt } = L4, Gt = h2(M3), H3 = M3 === "value" ? Rt : en(Rt);
      if (s3.attrName = Gt, s3.attrValue = H3, s3.keepAttr = true, s3.forceKeepAttr = void 0, ft("uponSanitizeAttribute", e2, s3), H3 = s3.attrValue, s3.forceKeepAttr || (oe2(M3, e2), !s3.keepAttr))
        continue;
      if (!Tt && U(/\/>/i, H3)) {
        oe2(M3, e2);
        continue;
      }
      bt && Zt([N4, q2, gt2], (Re2) => {
        H3 = $t(H3, Re2, " ");
      });
      let Se2 = h2(e2.nodeName);
      if (ve2(Se2, Gt, H3)) {
        if (zt && (Gt === "id" || Gt === "name") && (oe2(M3, e2), H3 = ee2 + H3), R5 && typeof f3 == "object" && typeof f3.getAttributeType == "function" && !B4)
          switch (f3.getAttributeType(Se2, Gt)) {
            case "TrustedHTML": {
              H3 = R5.createHTML(H3);
              break;
            }
            case "TrustedScriptURL": {
              H3 = R5.createScriptURL(H3);
              break;
            }
          }
        try {
          B4 ? e2.setAttributeNS(B4, M3, H3) : e2.setAttribute(M3, H3), De(n5.removed);
        } catch (Re2) {
        }
      }
    }
    ft("afterSanitizeAttributes", e2, null);
  }, qe2 = function l4(e2) {
    let o3 = null, s3 = Ee2(e2);
    for (ft("beforeSanitizeShadowDOM", e2, null); o3 = s3.nextNode(); )
      ft("uponSanitizeShadowNode", o3, null), !xe(o3) && (o3.content instanceof E4 && l4(o3.content), _e(o3));
    ft("afterSanitizeShadowDOM", e2, null);
  };
  return n5.sanitize = function(l4) {
    let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o3 = null, s3 = null, x4 = null, L4 = null;
    if (kt = !l4, kt && (l4 = "<!-->"), typeof l4 != "string" && !we2(l4))
      if (typeof l4.toString == "function") {
        if (l4 = l4.toString(), typeof l4 != "string")
          throw Vt("dirty is not a string, aborting");
      } else
        throw Vt("toString is not a function");
    if (!n5.isSupported)
      return l4;
    if (Ft || ne3(e2), n5.removed = [], typeof l4 == "string" && (yt = false), yt) {
      if (l4.nodeName) {
        let Rt = h2(l4.nodeName);
        if (!v4[Rt] || C4[Rt])
          throw Vt("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (l4 instanceof A4)
      o3 = ye("<!---->"), s3 = o3.ownerDocument.importNode(l4, true), s3.nodeType === 1 && s3.nodeName === "BODY" || s3.nodeName === "HTML" ? o3 = s3 : o3.appendChild(s3);
    else {
      if (!ot && !bt && !G4 && l4.indexOf("<") === -1)
        return R5 && vt ? R5.createHTML(l4) : l4;
      if (o3 = ye(l4), !o3)
        return ot ? null : vt ? it : "";
    }
    o3 && Mt && St(o3.firstChild);
    let M3 = Ee2(yt ? l4 : o3);
    for (; x4 = M3.nextNode(); )
      xe(x4) || (x4.content instanceof E4 && qe2(x4.content), _e(x4));
    if (yt)
      return l4;
    if (ot) {
      if (Z3)
        for (L4 = m2.call(o3.ownerDocument); o3.firstChild; )
          L4.appendChild(o3.firstChild);
      else
        L4 = o3;
      return (u4.shadowroot || u4.shadowrootmode) && (L4 = Ut.call(a2, L4, true)), L4;
    }
    let B4 = G4 ? o3.outerHTML : o3.innerHTML;
    return G4 && v4["!doctype"] && o3.ownerDocument && o3.ownerDocument.doctype && o3.ownerDocument.doctype.name && U(Ue, o3.ownerDocument.doctype.name) && (B4 = "<!DOCTYPE " + o3.ownerDocument.doctype.name + `>
` + B4), bt && Zt([N4, q2, gt2], (Rt) => {
      B4 = $t(B4, Rt, " ");
    }), R5 && vt ? R5.createHTML(B4) : B4;
  }, n5.setConfig = function() {
    let l4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ne3(l4), Ft = true;
  }, n5.clearConfig = function() {
    rt = null, Ft = false;
  }, n5.isValidAttribute = function(l4, e2, o3) {
    rt || ne3({});
    let s3 = h2(l4), x4 = h2(e2);
    return ve2(s3, x4, o3);
  }, n5.addHook = function(l4, e2) {
    typeof e2 == "function" && (P5[l4] = P5[l4] || [], jt(P5[l4], e2));
  }, n5.removeHook = function(l4) {
    if (P5[l4])
      return De(P5[l4]);
  }, n5.removeHooks = function(l4) {
    P5[l4] && (P5[l4] = []);
  }, n5.removeAllHooks = function() {
    P5 = {};
  }, n5;
}
function me(r5, { insertAt: n5 } = {}) {
  if (!r5 || typeof document == "undefined")
    return;
  let t5 = document.head || document.getElementsByTagName("head")[0], a2 = document.createElement("style");
  a2.type = "text/css", n5 === "top" && t5.firstChild ? t5.insertBefore(a2, t5.firstChild) : t5.appendChild(a2), a2.styleSheet ? a2.styleSheet.cssText = r5 : a2.appendChild(document.createTextNode(r5));
}
function Xt(r5) {
  return r5.label !== void 0 && typeof r5.onClick == "function";
}
function Mn(...r5) {
  return r5.filter(Boolean).join(" ");
}
function $e() {
  if (typeof window == "undefined" || typeof document == "undefined")
    return "ltr";
  let r5 = document.documentElement.getAttribute("dir");
  return r5 === "auto" || !r5 ? window.getComputedStyle(document.documentElement).direction : r5;
}
function CVTable() {
  const [limit, setLimit] = reactExports.useState(10);
  const [page6, setPage] = reactExports.useState(1);
  const [rowSelection, setRowSelection] = reactExports.useState({});
  const [search, setSearch] = reactExports.useState();
  const [sortingState, setSortingState] = reactExports.useState([]);
  const [filteringState, setFilteringState] = reactExports.useState([]);
  const [dateFilteringState, setDateFilteringState] = reactExports.useState();
  const utils = trpcReact.useUtils();
  const queryInput = {
    pagination: {
      page: page6,
      limit
    },
    filters: filteringState,
    dateFilters: dateFilteringState,
    sorting: sortingState,
    search
  };
  const {
    data: cvsData,
    isLoading,
    isError: getAllCVSError
  } = trpcReact.getAllCVS.useQuery(queryInput);
  const { data: storageInUseData, isError: getStorageInUseError } = trpcReact.getStorageInUse.useQuery();
  const {
    mutate: changeStatus,
    isLoading: changeStatusLoading,
    isError: changeStatusError
  } = trpcReact.changeStatus.useMutation({
    onSuccess: (input) => {
      utils.getAllCVS.invalidate(queryInput);
      if (Array.isArray(input)) {
        const status = statusMap(input[0].newStatus);
        const affectedRows = input.length;
        const message2 = `Has marcado ${affectedRows} ${affectedRows > 1 ? "CVs" : "CV"} como '${status}'`;
        An.success(message2);
      } else {
        const { name, newStatus } = input;
        const status = statusMap(newStatus);
        const message2 = `Has marcado el CV de '${name}' como '${status}'`;
        An.success(message2);
      }
    }
  });
  const {
    mutate: deleteCV,
    isLoading: deleteCVLoading,
    isError: deleteCVError
  } = trpcReact.delete.useMutation({
    onSuccess: (input) => {
      utils.getAllCVS.invalidate(queryInput);
      if (Array.isArray(input)) {
        const affectedRows = input.length;
        const message2 = `Has eliminado ${affectedRows} ${affectedRows > 1 ? "CVs" : "CV"} y todos sus adjuntos`;
        An.success(message2);
        setRowSelection({});
      } else {
        const { name } = input;
        const message2 = `Has eliminado el CV de '${name}' y todos sus adjuntos`;
        An.success(message2);
      }
    }
  });
  const filtering = {
    filteringState,
    onFilteringChange: ({ id: id3, value }) => {
      setFilteringState((prevFilters) => {
        const newFilters = prevFilters.filter((f3) => f3.id !== id3);
        if (value) {
          newFilters.push({ id: id3, value });
        }
        return newFilters;
      });
    },
    onClearFilter: (id3) => {
      setFilteringState((prevFilters) => {
        return prevFilters.filter((f3) => f3.id !== id3);
      });
    }
  };
  const dateFiltering = {
    onDateFilter: (dateFilter) => {
      if (dateFilter.type === "single") {
        setDateFilteringState({
          type: "single",
          date: dateFilter.value.toISOString()
        });
      } else {
        const val = dateFilter.value;
        setDateFilteringState({
          type: "range",
          from: val.from.toISOString(),
          to: val.to.toISOString()
        });
      }
    },
    onSort: (sort) => setSortingState([sort])
  };
  const sorting = {
    sortingState,
    onSort: (sort) => {
      setSortingState([sort]);
    },
    onCleanSort: () => {
      setSortingState([]);
    }
  };
  const actions = {
    onMarkAsPending: (cv) => {
      changeStatus({ id: cv.id, name: cv.name, newStatus: CVSStatus.PENDING });
    },
    onMarkAsRejected: (cv) => {
      changeStatus({ id: cv.id, name: cv.name, newStatus: CVSStatus.REJECTED });
    },
    onMarkAsReviewed: (cv) => {
      changeStatus({ id: cv.id, name: cv.name, newStatus: CVSStatus.REVIEWED });
    },
    onMarkAsSelected: (cv) => {
      changeStatus({ id: cv.id, name: cv.name, newStatus: CVSStatus.SELECTED });
    },
    onDelete: (cv) => {
      deleteCV({ id: cv.id, name: cv.name });
    }
  };
  const batchActions = {
    onMarkAsPending: (cvs2) => changeStatus(
      cvs2.map((c2) => ({
        id: c2.id,
        name: c2.name,
        newStatus: CVSStatus.PENDING
      }))
    ),
    onMarkAsRejected: (cvs2) => changeStatus(
      cvs2.map((c2) => ({
        id: c2.id,
        name: c2.name,
        newStatus: CVSStatus.REJECTED
      }))
    ),
    onMarkAsReviewed: (cvs2) => changeStatus(
      cvs2.map((c2) => ({
        id: c2.id,
        name: c2.name,
        newStatus: CVSStatus.REVIEWED
      }))
    ),
    onMarkAsSelected: (cvs2) => changeStatus(
      cvs2.map((c2) => ({
        id: c2.id,
        name: c2.name,
        newStatus: CVSStatus.SELECTED
      }))
    ),
    onDelete: (cvs2) => deleteCV(cvs2.map((c2) => ({ id: c2.id, name: c2.name })))
  };
  const columns = generateColumns({
    sorting,
    filtering,
    actions,
    batchActions,
    dateFiltering,
    isActionColumnLoading: changeStatusLoading || deleteCVLoading
  });
  const handleOnSearch = (params) => {
    if (params.value === "") {
      setSearch(void 0);
    } else {
      setSearch(params);
    }
  };
  const handleOnLimitChange = (newLimit) => setLimit(newLimit);
  const handleOnNextPage = () => setPage((currentPage) => currentPage + 1);
  const handleOnPrevPage = () => setPage((currentPage) => currentPage - 1);
  const handleOnFirstPage = () => setPage(1);
  const handleOnLastPage = () => setPage(cvsData?.pages.length);
  const table = useReactTable({
    columns,
    data: cvsData?.cvs ?? [],
    getCoreRowModel: getCoreRowModel(),
    onRowSelectionChange: setRowSelection,
    enableRowSelection: true,
    enableMultiRowSelection: true,
    getRowId: (row) => row.id,
    state: {
      rowSelection
    }
  });
  if (getAllCVSError || changeStatusError || getStorageInUseError || deleteCVError) {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: "Error" });
  }
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "space-y-2 mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(CVTableSearch, { onSearchChange: handleOnSearch }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CVTableFilters,
          {
            filteringState,
            dateFilteringState,
            sortingState,
            setFilters: setFilteringState,
            setDateFilters: setDateFilteringState,
            setSorting: setSortingState
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CVTableStorageUsed,
          {
            storageUsed: storageInUseData?.storageInUse ?? 0
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(CVTableRows, { table, isLoading }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center justify-end px-2", children: !isLoading && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      CVTablePagination,
      {
        limit,
        currentPage: page6,
        onLimitChange: handleOnLimitChange,
        onPrevPage: handleOnPrevPage,
        onNextPage: handleOnNextPage,
        onFirstPage: handleOnFirstPage,
        onLastPage: handleOnLastPage,
        pages: cvsData.pages
      }
    ) })
  ] });
}
function statusMap(status) {
  switch (status) {
    case CVSStatus.PENDING:
      return "Pendiente";
    case CVSStatus.REJECTED:
      return "Reachazado";
    case CVSStatus.REVIEWED:
      return "Revisado";
    case CVSStatus.SELECTED:
      return "Seleccionado";
    default:
      throw new Error("Invalid status");
  }
}
function CVTableIsland() {
  const [queryClient] = reactExports.useState(() => new QueryClient());
  const [trpcClient] = reactExports.useState(
    () => trpcReact.createClient({
      links: [
        httpBatchLink({
          url: "http://localhost:4321/api/trpc"
        })
      ]
    })
  );
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(trpcReact.Provider, { client: trpcClient, queryClient, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(QueryClientProvider, { client: queryClient, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(CVTable, {}),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Toaster, {})
  ] }) });
}
var react, react_production_min, l$2, n$2, p$3, q$2, r$2, t$12, u$1, v$1, w2, x, y, z$1, B$1, C$1, D$2, H$1, I$1, J, K$2, L$2, P$2, U$2, V$1, W$1, reactExports, React, $2AODx$react, $$Astro$1, $$Base, jsxRuntime$1, reactJsxRuntime_production_min$1, f, k$1, l$1, m$1, n$1, p$2, jsxRuntimeExports$1, ObservableAbortError, TransformResultError, TRPCClientError, isFunction$1, METHOD, getUrl, getBody, jsonHttpRequester, throwFatalError, batchRequester, httpBatchLink, TRPCUntypedClient, clientCallTypeMap, clientCallTypeToProcedureType, Subscribable, isServer, FocusManager, focusManager, onlineEvents, OnlineManager, onlineManager, CancelledError, defaultLogger, notifyManager, Removable, Query, QueryCache, Mutation, MutationCache, QueryClient, QueryObserver, QueriesObserver, InfiniteQueryObserver, MutationObserver$1, reactDom, reactDom_production_min, scheduler, scheduler_production_min, schedulerExports, aa, ca2, da, ea, ia, ja, ka, la, ma, z2, ra, ua, va, wa, ya, za, Aa, Ba, Ca, Da, Ea, Fa, Ga, Ha, Ia, Ja, A2, La, Na, eb, mb, nb, pb, qb, tb, wb, yb, zb, Ab, Ib, Lb, Mb2, Ob, Pb, Qb, Rb, Sb, ac, bc, cc, dc, B2, ec, fc, gc, hc, ic, jc, kc, lc, oc, pc, qc, rc, sc, C2, Ec, Fc, Gc, Hc, Ic, Jc, Kc, Lc, Mc, Nc, Oc, Pc, Qc, Rc, cd, dd, id$1, kd, ld, md, sd, td, ud, vd, wd, xd, yd, Ad, Bd, Cd, Dd, Ed, Fd, Gd, Hd, Id, Jd, Kd, Ld, Md, Nd, Od, Qd, Rd, Sd, Td, Ud, Vd, Wd, Xd, Yd, Zd, $d, ae$1, be, ce$1, de$1, ee, fe$1, ie$1, le$1, pe2, qe, we, xe, ye, ze$1, He$1, Pe$1, Qe$1, Re, Se, Te, We$1, Xe, Ye$1, $e$1, af, bf, cf, df, ef, hf, jf, kf, gf, lf, mf, rf, xf, yf, Cf, Df, Ff, Gf, Hf, Jf, Nf, Of, Pf, uf, of, Qf, Rf, Sf, Tf, Vf, H, Wf, Xf, eg, fg, gg, kg, lg, mg, ng, og, pg, qg, rg, sg, xg, yg, I2, zg, Kg, Mg, Ng, Og, Pg, Wg, $g, jh, nh, Bh, Ch, Dh, Eh, Fh, Gh, M, Nh, Ph, Qh, Rh, N2, O$1, P$1, Sh, Th, Uh, Vh, ai, Yh, Zh, $h, Ni, Xi, Ug, nj, Aj, Bj, Cj, Dj, Kj, U$1, Lj, V, Oj, X$2, Yj, mk, nk, ok, pk, K$1, R2, Y, Z, gj, fj, T2, qk, hh, rk, sk, tk, uk, gk, Hj, vk, Pi, Qi, Si, wk, xk, yk, zk, Ak, Bk, Ck, Wk, ll, tl, ul, vl, wl, reactDomExports, _n, shim, useSyncExternalStoreShim_production_min, e, k, l2, m, n2, p2, u2, shimExports, useSyncExternalStore, defaultContext, QueryClientSharingContext, useQueryClient, QueryClientProvider, IsRestoringContext, useIsRestoring, QueryErrorResetBoundaryContext, useQueryErrorResetBoundary, ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError, ensureStaleTime, willFetch, shouldSuspend, fetchOptimistic, contextProps, TRPCContext, trpcReact, debug, Headers2, createRow, ColumnFaceting, includesString, includesStringSensitive, equalsString, arrIncludes, arrIncludesAll, arrIncludesSome, equals, weakEquals, inNumberRange, filterFns, ColumnFiltering, sum2, min$2, max$2, extent, mean, median, unique, uniqueCount, count2, aggregationFns, ColumnGrouping, ColumnOrdering, getDefaultColumnPinningState, ColumnPinning, defaultColumnSizing, getDefaultColumnSizingInfoState, ColumnSizing, passiveSupported$1, ColumnVisibility, GlobalFaceting, GlobalFiltering, RowExpanding, defaultPageIndex, defaultPageSize, getDefaultPaginationState, RowPagination, getDefaultRowPinningState, RowPinning, RowSelection, mutateRowIsSelected, reSplitAlphaNumeric, alphanumeric, alphanumericCaseSensitive, text2, textCaseSensitive, datetime, basic, sortingFns, RowSorting, builtInFeatures, $5e63c961fc1ce211$export$8c6ed5c666ac1360, $5e63c961fc1ce211$var$SlotClone, $5e63c961fc1ce211$export$d9f1ccf0bdb05d45, $8927f6f2acc4f386$var$NODES, $8927f6f2acc4f386$export$250ffa63cdc0d034, $f631663db3294ace$var$DirectionContext, $5cb92bef7577960e$var$CONTEXT_UPDATE, $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, $5cb92bef7577960e$var$FOCUS_OUTSIDE, $5cb92bef7577960e$var$originalBodyPointerEvents, $5cb92bef7577960e$var$DismissableLayerContext, $5cb92bef7577960e$export$177fb62ff3ec1f22, $3db38b7d1fb3fe6a$var$count, $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS, $d3863c46a17e8a28$export$20e40289641fbbb6, $d3863c46a17e8a28$var$focusScopesStack, $9f79659886946c16$export$e5c5a5f917a5871c, $1746a345f3d73bb7$var$useReactId, $1746a345f3d73bb7$var$count, sides, min$1, max$1, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap, computePosition$1, arrow$2, flip$1, hide$1, offset, shift$1, limitShift$1, size$1, noOffsets, topLayerSelectors, getElementRects, platform, shift, flip, size, hide, arrow$1, limitShift, computePosition, arrow, index2, $cf1ac5d9fe0e8206$var$POPPER_NAME, $cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923, $cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext, $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9, $cf1ac5d9fe0e8206$var$ANCHOR_NAME, $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d, $cf1ac5d9fe0e8206$var$CONTENT_NAME, $cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext, $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc, $cf1ac5d9fe0e8206$var$transformOrigin, $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, $cf1ac5d9fe0e8206$export$b688253958b8dfe7, $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, $f1701beae083dbae$export$602eac185826482c, $921a889cee6df7e8$export$99c2b779aa4e8b8b, $d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS, $d7bdfb9eb0fdf311$var$GROUP_NAME, $d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope, $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4, $d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext, $d7bdfb9eb0fdf311$export$8699f7c8af148338, $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, $d7bdfb9eb0fdf311$var$ITEM_NAME, $d7bdfb9eb0fdf311$export$ab9df7c53fe8454, $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT, $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, getDefaultParent, counterMap, uncontrolledNodes, markerMap, lockCount, unwrapHost, correctTargets, applyAttributeToOthers, hideOthers, __assign$1, zeroRightClassName, fullWidthClassName, noScrollbarsClassName, removedBarSizeVariable, useIsomorphicLayoutEffect$1, currentValues, SideCar$1, effectCar, nothing, RemoveScroll, getNonce, stylesheetSingleton, styleHookSingleton, styleSingleton, zeroGap, parse, getOffset, getGapWidth, Style, lockAttribute, getStyles, getCurrentUseCounter, useLockAttribute, RemoveScrollBar, passiveSupported, options, nonPassive, alwaysContainsScroll, elementCanBeScrolled, elementCouldBeVScrolled, elementCouldBeHScrolled, locationCouldBeScrolled, getVScrollVariables, getHScrollVariables, elementCouldBeScrolled, getScrollVariables, getDirectionFactor, handleScroll, getTouchXY, getDeltaXY, extractRef, deltaCompare, generateStyle, idCounter, lockStack, SideCar, ReactRemoveScroll, $01b9c$RemoveScroll, $6cc32821e9371a1c$var$SELECTION_KEYS, $6cc32821e9371a1c$var$FIRST_KEYS, $6cc32821e9371a1c$var$LAST_KEYS, $6cc32821e9371a1c$var$FIRST_LAST_KEYS, $6cc32821e9371a1c$var$SUB_OPEN_KEYS, $6cc32821e9371a1c$var$SUB_CLOSE_KEYS, $6cc32821e9371a1c$var$MENU_NAME, $6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope, $6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb, $6cc32821e9371a1c$var$usePopperScope, $6cc32821e9371a1c$var$useRovingFocusGroupScope, $6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext, $6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext, $6cc32821e9371a1c$export$d9b273488cd8ce6f, $6cc32821e9371a1c$export$9fa5ebd18bee4d43, $6cc32821e9371a1c$var$PORTAL_NAME, $6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext, $6cc32821e9371a1c$export$793392f970497feb, $6cc32821e9371a1c$var$CONTENT_NAME, $6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext, $6cc32821e9371a1c$export$479f0f2f71193efe, $6cc32821e9371a1c$var$MenuRootContentModal, $6cc32821e9371a1c$var$MenuRootContentNonModal, $6cc32821e9371a1c$var$MenuContentImpl, $6cc32821e9371a1c$export$dd37bec0e8a99143, $6cc32821e9371a1c$var$ITEM_NAME, $6cc32821e9371a1c$var$ITEM_SELECT, $6cc32821e9371a1c$export$2ce376c2cc3355c8, $6cc32821e9371a1c$var$MenuItemImpl, $6cc32821e9371a1c$export$f6f243521332502d, $6cc32821e9371a1c$var$RADIO_GROUP_NAME, $6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext, $6cc32821e9371a1c$var$RADIO_ITEM_NAME, $6cc32821e9371a1c$export$69bd225e9817f6d0, $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, $6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext, $6cc32821e9371a1c$export$a2593e23056970a3, $6cc32821e9371a1c$export$1cec7dcdd713e220, $6cc32821e9371a1c$var$SUB_NAME, $6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext, $6cc32821e9371a1c$var$SUB_TRIGGER_NAME, $6cc32821e9371a1c$export$5fbbb3ba7297405f, $6cc32821e9371a1c$var$SUB_CONTENT_NAME, $6cc32821e9371a1c$export$e7142ab31822bde6, $6cc32821e9371a1c$export$be92b6f5f03c0fe9, $6cc32821e9371a1c$export$b688253958b8dfe7, $6cc32821e9371a1c$export$602eac185826482c, $6cc32821e9371a1c$export$7c6e2c02157bb7d2, $6cc32821e9371a1c$export$b04be29aa201d4f5, $6cc32821e9371a1c$export$6d08773d2e66f8f2, $6cc32821e9371a1c$export$16ce288f89fa631c, $6cc32821e9371a1c$export$371ab307eab489c0, $6cc32821e9371a1c$export$c3468e2714d175fa, $6cc32821e9371a1c$export$1ff3c3f08ae963c0, $6cc32821e9371a1c$export$2ea8a7a591ac5eac, $6cc32821e9371a1c$export$6d4de93b380beddf, $d08ef79370b62062$var$DROPDOWN_MENU_NAME, $d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687, $d08ef79370b62062$var$useMenuScope, $d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext, $d08ef79370b62062$export$e44a253a59704894, $d08ef79370b62062$var$TRIGGER_NAME, $d08ef79370b62062$export$d2469213b3befba9, $d08ef79370b62062$export$cd369b4d4d54efc9, $d08ef79370b62062$var$CONTENT_NAME, $d08ef79370b62062$export$6e76d93a37c01248, $d08ef79370b62062$export$76e48c5b57f24495, $d08ef79370b62062$export$ed97964d1871885d, $d08ef79370b62062$export$53a69729da201fa9, $d08ef79370b62062$export$e4f69b41b1637536, $d08ef79370b62062$export$42355ae145153fb6, $d08ef79370b62062$export$da160178fd3bc7e9, $d08ef79370b62062$export$21dcb7ec56f874cf, $d08ef79370b62062$export$f34ec8bc2482cc5f, $d08ef79370b62062$export$be92b6f5f03c0fe9, $d08ef79370b62062$export$41fb9f06171c75f4, $d08ef79370b62062$export$602eac185826482c, $d08ef79370b62062$export$7c6e2c02157bb7d2, $d08ef79370b62062$export$b04be29aa201d4f5, $d08ef79370b62062$export$6d08773d2e66f8f2, $d08ef79370b62062$export$16ce288f89fa631c, $d08ef79370b62062$export$371ab307eab489c0, $d08ef79370b62062$export$c3468e2714d175fa, $d08ef79370b62062$export$1ff3c3f08ae963c0, $d08ef79370b62062$export$2ea8a7a591ac5eac, $d08ef79370b62062$export$6d4de93b380beddf, defaultAttributes, toKebabCase, createLucideIcon, ArrowDown, ArrowUp, CalendarDays, Calendar$1, CheckCheck, Check, ChevronDown, ChevronLeft, ChevronRight, ChevronUp, Circle, Clock, Dot, Download, Ellipsis, FileText, Filter, HardDrive, ListFilter, Pause, Plus, RefreshCcw, Square, SwitchCamera, Trash2, Video, WandSparkles, X$1, CLASS_PART_SEPARATOR, arbitraryPropertyRegex, IMPORTANT_MODIFIER, SPLIT_CLASSES_REGEX, arbitraryValueRegex, fractionRegex, stringLengths, tshirtUnitRegex, lengthUnitRegex, colorFunctionRegex, shadowRegex, imageRegex, sizeLabels, imageLabels, twMerge, DropdownMenu, DropdownMenuTrigger, DropdownMenuSubTrigger, DropdownMenuSubContent, DropdownMenuContent, DropdownMenuItem, DropdownMenuCheckboxItem, DropdownMenuRadioItem, DropdownMenuLabel, DropdownMenuSeparator, _excluded$Q, CaretSortIcon, _excluded$X, ChevronLeftIcon, _excluded$Y, ChevronRightIcon, _excluded$1M, DoubleArrowLeftIcon, _excluded$1N, DoubleArrowRightIcon, _excluded$33, MagnifyingGlassIcon, _excluded$3E, ReloadIcon, falsyToString, cx, cva, buttonVariants, Button$1, millisecondsInWeek, millisecondsInDay, minutesInMonth, minutesInDay, defaultOptions, formatDistanceLocale$1, formatDistance$2, dateFormats$1, timeFormats$1, dateTimeFormats$1, formatLong$1, formatRelativeLocale$1, formatRelative$1, eraValues$1, quarterValues$1, monthValues$1, dayValues$1, dayPeriodValues$1, formattingDayPeriodValues$1, ordinalNumber$1, localize$1, matchOrdinalNumberPattern$1, parseOrdinalNumberPattern$1, matchEraPatterns$1, parseEraPatterns$1, matchQuarterPatterns$1, parseQuarterPatterns$1, matchMonthPatterns$1, parseMonthPatterns$1, matchDayPatterns$1, parseDayPatterns$1, matchDayPeriodPatterns$1, parseDayPeriodPatterns$1, match$1, enUS, lightFormatters, dayPeriodEnum, formatters$1, dateLongFormatter, timeLongFormatter, dateTimeLongFormatter, longFormatters, dayOfYearTokenRE, weekYearTokenRE, throwTokens, formattingTokensRegExp, longFormattingTokensRegExp, escapedStringRegExp, doubleQuoteRegExp, unescapedLatinCharacterRegExp, formatDistanceLocale, formatDistance, dateFormats, timeFormats, dateTimeFormats, formatLong, formatRelativeLocale, formatRelativeLocalePlural, formatRelative, eraValues, quarterValues, monthValues, dayValues, dayPeriodValues, formattingDayPeriodValues, ordinalNumber, localize, matchOrdinalNumberPattern, parseOrdinalNumberPattern, matchEraPatterns, parseEraPatterns, matchQuarterPatterns, parseQuarterPatterns, matchMonthPatterns, parseMonthPatterns, matchDayPatterns, parseDayPatterns, matchDayPeriodPatterns, parseDayPeriodPatterns, match, es, __assign, jsxRuntime, reactJsxRuntime_production_min, hasRequiredReactJsxRuntime_production_min, jsxRuntimeExports, defaultClassNames, formatters, labelDay, labelMonthDropdown, labelNext, labelPrevious, labelWeekday, labelWeekNumber, labelYearDropdown, labels, DayPickerContext, NavigationContext, Button, SelectMultipleContext, SelectRangeContext, InternalModifier, Selected, Disabled, Hidden, Today, RangeEnd, RangeMiddle, RangeStart, Outside, ModifiersContext, MAX_RETRY, FocusContext, SelectSingleContext, useIsomorphicLayoutEffect, serverHandoffComplete, id, $69cb30bb0017df05$var$TABS_NAME, $69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a, $69cb30bb0017df05$var$useRovingFocusGroupScope, $69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext, $69cb30bb0017df05$export$b2539bed5023c21c, $69cb30bb0017df05$var$TAB_LIST_NAME, $69cb30bb0017df05$export$9712d22edc0d78c1, $69cb30bb0017df05$var$TRIGGER_NAME, $69cb30bb0017df05$export$8114b9fdfdf9f3ba, $69cb30bb0017df05$var$CONTENT_NAME, $69cb30bb0017df05$export$bd905d70e8fd2ebb, $69cb30bb0017df05$export$be92b6f5f03c0fe9, $69cb30bb0017df05$export$54c2e3dc7acea9f5, $69cb30bb0017df05$export$41fb9f06171c75f4, $69cb30bb0017df05$export$7c6e2c02157bb7d2, Tabs, TabsList, TabsTrigger, TabsContent, CVSStatus, places, positions, badgeVariants, $5d3850c4d0b4e6c7$var$DIALOG_NAME, $5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41, $5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext, $5d3850c4d0b4e6c7$export$3ddf2d174ce01153, $5d3850c4d0b4e6c7$var$TRIGGER_NAME, $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88, $5d3850c4d0b4e6c7$var$PORTAL_NAME, $5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext, $5d3850c4d0b4e6c7$export$dad7c95542bacce0, $5d3850c4d0b4e6c7$var$OVERLAY_NAME, $5d3850c4d0b4e6c7$export$bd1d06c79be19e17, $5d3850c4d0b4e6c7$var$DialogOverlayImpl, $5d3850c4d0b4e6c7$var$CONTENT_NAME, $5d3850c4d0b4e6c7$export$b6d9565de1e068cf, $5d3850c4d0b4e6c7$var$DialogContentModal, $5d3850c4d0b4e6c7$var$DialogContentNonModal, $5d3850c4d0b4e6c7$var$DialogContentImpl, $5d3850c4d0b4e6c7$var$TITLE_NAME, $5d3850c4d0b4e6c7$export$16f7638e4a34b909, $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5, $5d3850c4d0b4e6c7$var$CLOSE_NAME, $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac, $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, $5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext, $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, $5d3850c4d0b4e6c7$export$41fb9f06171c75f4, $5d3850c4d0b4e6c7$export$602eac185826482c, $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, $5d3850c4d0b4e6c7$export$f99233281efd08a0, $5d3850c4d0b4e6c7$export$393edc798c47379d, $5d3850c4d0b4e6c7$export$f39c2d165cd861fe, $905f4ae918aab1aa$var$ROOT_NAME, $905f4ae918aab1aa$var$createAlertDialogContext, $905f4ae918aab1aa$export$b8891880751c2c5b, $905f4ae918aab1aa$var$useDialogScope, $905f4ae918aab1aa$export$de466dd8317b0b75, $905f4ae918aab1aa$export$6edd7a623ef0f40b, $905f4ae918aab1aa$export$660f2bfdb986706c, $905f4ae918aab1aa$export$a707a4895ce23256, $905f4ae918aab1aa$var$CONTENT_NAME, $905f4ae918aab1aa$var$AlertDialogContentProvider, $905f4ae918aab1aa$var$useAlertDialogContentContext, $905f4ae918aab1aa$export$94e6af45f0af4efd, $905f4ae918aab1aa$var$TITLE_NAME, $905f4ae918aab1aa$export$225e0da62d314b7, $905f4ae918aab1aa$export$a23b55cde55ad9a5, $905f4ae918aab1aa$export$b454f818c58ee85d, $905f4ae918aab1aa$var$CANCEL_NAME, $905f4ae918aab1aa$export$2f67a923571aaea0, $905f4ae918aab1aa$export$be92b6f5f03c0fe9, $905f4ae918aab1aa$export$41fb9f06171c75f4, $905f4ae918aab1aa$export$602eac185826482c, $905f4ae918aab1aa$export$c6fdb837b070b4ff, $905f4ae918aab1aa$export$7c6e2c02157bb7d2, $905f4ae918aab1aa$export$e19cd5f9376f8cee, $905f4ae918aab1aa$export$848c9b7ead0df967, $905f4ae918aab1aa$export$f99233281efd08a0, $905f4ae918aab1aa$export$393edc798c47379d, AlertDialog, AlertDialogTrigger, AlertDialogPortal, AlertDialogOverlay, AlertDialogContent, AlertDialogHeader, AlertDialogFooter, AlertDialogTitle, AlertDialogDescription, AlertDialogAction, AlertDialogCancel, $e698a72e93240346$var$CHECKBOX_NAME, $e698a72e93240346$var$createCheckboxContext, $e698a72e93240346$export$b566c4ff5488ea01, $e698a72e93240346$var$CheckboxProvider, $e698a72e93240346$var$useCheckboxContext, $e698a72e93240346$export$48513f6b9f8ce62d, $e698a72e93240346$var$INDICATOR_NAME, $e698a72e93240346$export$59aad738f51d1c05, $e698a72e93240346$var$BubbleInput, $e698a72e93240346$export$be92b6f5f03c0fe9, $e698a72e93240346$export$adb584737d712b70, Checkbox, Table2, TableHeader, TableBody, TableFooter, TableRow, TableHead, TableCell, TableCaption, $57acba87d6e25586$var$SCROLL_AREA_NAME, $57acba87d6e25586$var$createScrollAreaContext, $57acba87d6e25586$export$488468afe3a6f2b1, $57acba87d6e25586$var$ScrollAreaProvider, $57acba87d6e25586$var$useScrollAreaContext, $57acba87d6e25586$export$ccf8d8d7bbf3c2cc, $57acba87d6e25586$var$VIEWPORT_NAME, $57acba87d6e25586$export$a21cbf9f11fca853, $57acba87d6e25586$var$SCROLLBAR_NAME, $57acba87d6e25586$export$2fabd85d0eba3c57, $57acba87d6e25586$var$ScrollAreaScrollbarHover, $57acba87d6e25586$var$ScrollAreaScrollbarScroll, $57acba87d6e25586$var$ScrollAreaScrollbarAuto, $57acba87d6e25586$var$ScrollAreaScrollbarVisible, $57acba87d6e25586$var$ScrollAreaScrollbarX, $57acba87d6e25586$var$ScrollAreaScrollbarY, $57acba87d6e25586$var$ScrollbarProvider, $57acba87d6e25586$var$useScrollbarContext, $57acba87d6e25586$var$ScrollAreaScrollbarImpl, $57acba87d6e25586$var$THUMB_NAME, $57acba87d6e25586$export$9fba1154677d7cd2, $57acba87d6e25586$var$ScrollAreaThumbImpl, $57acba87d6e25586$var$CORNER_NAME, $57acba87d6e25586$export$56969d565df7cc4b, $57acba87d6e25586$var$ScrollAreaCornerImpl, $57acba87d6e25586$var$addUnlinkedScrollListener, $57acba87d6e25586$export$be92b6f5f03c0fe9, $57acba87d6e25586$export$d5c6c08dc2d3ca7, $57acba87d6e25586$export$ac61190d9fc311a9, ScrollArea, ScrollBar, Input, $ea1ef594cf570d83$export$439d29a4e110a164, $ea1ef594cf570d83$export$be92b6f5f03c0fe9, $cc7e05a45900e73f$var$OPEN_KEYS, $cc7e05a45900e73f$var$SELECTION_KEYS, $cc7e05a45900e73f$var$SELECT_NAME, $cc7e05a45900e73f$var$Collection, $cc7e05a45900e73f$var$useCollection, $cc7e05a45900e73f$var$createCollectionScope, $cc7e05a45900e73f$var$createSelectContext, $cc7e05a45900e73f$export$286727a75dc039bd, $cc7e05a45900e73f$var$usePopperScope, $cc7e05a45900e73f$var$SelectProvider, $cc7e05a45900e73f$var$useSelectContext, $cc7e05a45900e73f$var$SelectNativeOptionsProvider, $cc7e05a45900e73f$var$useSelectNativeOptionsContext, $cc7e05a45900e73f$export$ef9b1a59e592288f, $cc7e05a45900e73f$var$TRIGGER_NAME, $cc7e05a45900e73f$export$3ac1e88a1c0b9f1, $cc7e05a45900e73f$var$VALUE_NAME, $cc7e05a45900e73f$export$e288731fd71264f0, $cc7e05a45900e73f$export$99b400cabb58c515, $cc7e05a45900e73f$export$b2af6c9944296213, $cc7e05a45900e73f$var$CONTENT_NAME, $cc7e05a45900e73f$export$c973a4b3cb86a03d, $cc7e05a45900e73f$var$CONTENT_MARGIN, $cc7e05a45900e73f$var$SelectContentProvider, $cc7e05a45900e73f$var$useSelectContentContext, $cc7e05a45900e73f$var$SelectContentImpl, $cc7e05a45900e73f$var$SelectItemAlignedPosition, $cc7e05a45900e73f$var$SelectPopperPosition, $cc7e05a45900e73f$var$SelectViewportProvider, $cc7e05a45900e73f$var$useSelectViewportContext, $cc7e05a45900e73f$var$VIEWPORT_NAME, $cc7e05a45900e73f$export$9ed6e7b40248d36d, $cc7e05a45900e73f$var$GROUP_NAME, $cc7e05a45900e73f$var$SelectGroupContextProvider, $cc7e05a45900e73f$var$useSelectGroupContext, $cc7e05a45900e73f$var$LABEL_NAME, $cc7e05a45900e73f$export$f67338d29bd972f8, $cc7e05a45900e73f$var$ITEM_NAME, $cc7e05a45900e73f$var$SelectItemContextProvider, $cc7e05a45900e73f$var$useSelectItemContext, $cc7e05a45900e73f$export$13ef48a934230896, $cc7e05a45900e73f$var$ITEM_TEXT_NAME, $cc7e05a45900e73f$export$3572fb0fb821ff49, $cc7e05a45900e73f$var$ITEM_INDICATOR_NAME, $cc7e05a45900e73f$export$6b9198de19accfe6, $cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME, $cc7e05a45900e73f$export$d8117927658af6d7, $cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME, $cc7e05a45900e73f$export$ff951e476c12189, $cc7e05a45900e73f$var$SelectScrollButtonImpl, $cc7e05a45900e73f$export$eba4b1df07cb1d3, $cc7e05a45900e73f$var$BubbleSelect, $cc7e05a45900e73f$export$be92b6f5f03c0fe9, $cc7e05a45900e73f$export$41fb9f06171c75f4, $cc7e05a45900e73f$export$4c8d1a57a761ef94, $cc7e05a45900e73f$export$f04a61298a47a40f, $cc7e05a45900e73f$export$602eac185826482c, $cc7e05a45900e73f$export$7c6e2c02157bb7d2, $cc7e05a45900e73f$export$d5c6c08dc2d3ca7, $cc7e05a45900e73f$export$b04be29aa201d4f5, $cc7e05a45900e73f$export$6d08773d2e66f8f2, $cc7e05a45900e73f$export$d6e5bf9c43ea9319, $cc7e05a45900e73f$export$c3468e2714d175fa, $cc7e05a45900e73f$export$2f60d3ec9ad468f2, $cc7e05a45900e73f$export$bf1aedc3039c8d63, $cc7e05a45900e73f$export$1ff3c3f08ae963c0, Select, SelectValue, SelectTrigger, SelectScrollUpButton, SelectScrollDownButton, SelectContent, SelectLabel, SelectItem, SelectSeparator, useDebounce, ke, Ne, Ze, Je, Qe, O2, X, Be, ce, de, Zt, De, jt, te, ae, Ie, $t, tn, en, Q, U, Vt, Ce, re, se, an, ie, rn, Le, Me, le, Pe, Qt, sn, ln, cn, dn, un, He, fn, mn, Ue, pn, Oe, gn, hn, ze, We, Tn, Ye, bn, yn, En, wn, je, ue, fe, K, xn, vn, An, Sn, Rn, Nn, Dn, In, Cn, Ln, Pn, Jn, P2, E2, L2, D2, j, Toaster, $$Astro, $$Cvs, $$file, $$url, cvs;
var init_cvs_qudRXU8T = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/pages/cvs_qudRXU8T.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_trpc_GIzfMcGy();
    init_astro_BO0wYrHs();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    react = { exports: {} };
    react_production_min = {};
    l$2 = Symbol.for("react.element");
    n$2 = Symbol.for("react.portal");
    p$3 = Symbol.for("react.fragment");
    q$2 = Symbol.for("react.strict_mode");
    r$2 = Symbol.for("react.profiler");
    t$12 = Symbol.for("react.provider");
    u$1 = Symbol.for("react.context");
    v$1 = Symbol.for("react.forward_ref");
    w2 = Symbol.for("react.suspense");
    x = Symbol.for("react.memo");
    y = Symbol.for("react.lazy");
    z$1 = Symbol.iterator;
    B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    C$1 = Object.assign;
    D$2 = {};
    E$2.prototype.isReactComponent = {};
    E$2.prototype.setState = function(a2, b2) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a2, b2, "setState");
    };
    E$2.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    F$1.prototype = E$2.prototype;
    H$1 = G$1.prototype = new F$1();
    H$1.constructor = G$1;
    C$1(H$1, E$2.prototype);
    H$1.isPureReactComponent = true;
    I$1 = Array.isArray;
    J = Object.prototype.hasOwnProperty;
    K$2 = { current: null };
    L$2 = { key: true, ref: true, __self: true, __source: true };
    P$2 = /\/+/g;
    U$2 = { current: null };
    V$1 = { transition: null };
    W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$2 };
    react_production_min.Children = { map: S$1, forEach: function(a2, b2, e2) {
      S$1(a2, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a2) {
      var b2 = 0;
      S$1(a2, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a2) {
      return S$1(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!O$2(a2))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a2;
    } };
    react_production_min.Component = E$2;
    react_production_min.Fragment = p$3;
    react_production_min.Profiler = r$2;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$2;
    react_production_min.Suspense = w2;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a2, b2, e2) {
      if (null === a2 || void 0 === a2)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
      var d2 = C$1({}, a2.props), c2 = a2.key, k4 = a2.ref, h2 = a2._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k4 = b2.ref, h2 = K$2.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a2.type && a2.type.defaultProps)
          var g = a2.type.defaultProps;
        for (f3 in b2)
          J.call(b2, f3) && !L$2.hasOwnProperty(f3) && (d2[f3] = void 0 === b2[f3] && void 0 !== g ? g[f3] : b2[f3]);
      }
      var f3 = arguments.length - 2;
      if (1 === f3)
        d2.children = e2;
      else if (1 < f3) {
        g = Array(f3);
        for (var m2 = 0; m2 < f3; m2++)
          g[m2] = arguments[m2 + 2];
        d2.children = g;
      }
      return { $$typeof: l$2, type: a2.type, key: c2, ref: k4, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a2) {
      a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a2.Provider = { $$typeof: t$12, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a2) {
      var b2 = M$1.bind(null, a2);
      b2.type = a2;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: v$1, render: a2 };
    };
    react_production_min.isValidElement = O$2;
    react_production_min.lazy = function(a2) {
      return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$1 };
    };
    react_production_min.memo = function(a2, b2) {
      return { $$typeof: x, type: a2, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a2) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a2();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a2, b2) {
      return U$2.current.useCallback(a2, b2);
    };
    react_production_min.useContext = function(a2) {
      return U$2.current.useContext(a2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a2) {
      return U$2.current.useDeferredValue(a2);
    };
    react_production_min.useEffect = function(a2, b2) {
      return U$2.current.useEffect(a2, b2);
    };
    react_production_min.useId = function() {
      return U$2.current.useId();
    };
    react_production_min.useImperativeHandle = function(a2, b2, e2) {
      return U$2.current.useImperativeHandle(a2, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a2, b2) {
      return U$2.current.useInsertionEffect(a2, b2);
    };
    react_production_min.useLayoutEffect = function(a2, b2) {
      return U$2.current.useLayoutEffect(a2, b2);
    };
    react_production_min.useMemo = function(a2, b2) {
      return U$2.current.useMemo(a2, b2);
    };
    react_production_min.useReducer = function(a2, b2, e2) {
      return U$2.current.useReducer(a2, b2, e2);
    };
    react_production_min.useRef = function(a2) {
      return U$2.current.useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return U$2.current.useState(a2);
    };
    react_production_min.useSyncExternalStore = function(a2, b2, e2) {
      return U$2.current.useSyncExternalStore(a2, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$2.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    {
      react.exports = react_production_min;
    }
    reactExports = react.exports;
    React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    $2AODx$react = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    $$Astro$1 = createAstro();
    $$Base = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
      Astro2.self = $$Base;
      const { title } = Astro2.props;
      const { classNames } = Astro2.props;
      return renderTemplate`<html lang="en"> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator"${addAttribute(Astro2.generator, "content")}><title>${title}</title>${renderHead()}</head> <body${addAttribute(classNames, "class")}> ${renderSlot($$result, $$slots["default"])} </body></html>`;
    }, "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/layouts/base.astro", void 0);
    jsxRuntime$1 = { exports: {} };
    reactJsxRuntime_production_min$1 = {};
    f = reactExports;
    k$1 = Symbol.for("react.element");
    l$1 = Symbol.for("react.fragment");
    m$1 = Object.prototype.hasOwnProperty;
    n$1 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
    p$2 = { key: true, ref: true, __self: true, __source: true };
    reactJsxRuntime_production_min$1.Fragment = l$1;
    reactJsxRuntime_production_min$1.jsx = q$1;
    reactJsxRuntime_production_min$1.jsxs = q$1;
    {
      jsxRuntime$1.exports = reactJsxRuntime_production_min$1;
    }
    jsxRuntimeExports$1 = jsxRuntime$1.exports;
    ObservableAbortError = class extends Error {
      constructor(message2) {
        super(message2);
        this.name = "ObservableAbortError";
        Object.setPrototypeOf(this, ObservableAbortError.prototype);
      }
    };
    TransformResultError = class extends Error {
      constructor() {
        super("Unable to transform response from server");
      }
    };
    TRPCClientError = class extends Error {
      static from(_cause, opts2 = {}) {
        const cause = _cause;
        if (isTRPCClientError(cause)) {
          if (opts2.meta) {
            cause.meta = {
              ...cause.meta,
              ...opts2.meta
            };
          }
          return cause;
        }
        if (isTRPCErrorResponse(cause)) {
          return new TRPCClientError(cause.error.message, {
            ...opts2,
            result: cause
          });
        }
        if (!(cause instanceof Error)) {
          return new TRPCClientError("Unknown error", {
            ...opts2,
            cause
          });
        }
        return new TRPCClientError(cause.message, {
          ...opts2,
          cause: getCauseFromUnknown(cause)
        });
      }
      constructor(message2, opts2) {
        const cause = opts2?.cause;
        super(message2, {
          cause
        });
        this.meta = opts2?.meta;
        this.cause = cause;
        this.shape = opts2?.result?.error;
        this.data = opts2?.result?.error.data;
        this.name = "TRPCClientError";
        Object.setPrototypeOf(this, TRPCClientError.prototype);
      }
    };
    isFunction$1 = (fn2) => typeof fn2 === "function";
    METHOD = {
      query: "GET",
      mutation: "POST"
    };
    getUrl = (opts2) => {
      let url = opts2.url + "/" + opts2.path;
      const queryParts = [];
      if ("inputs" in opts2) {
        queryParts.push("batch=1");
      }
      if (opts2.type === "query") {
        const input = getInput(opts2);
        if (input !== void 0) {
          queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
        }
      }
      if (queryParts.length) {
        url += "?" + queryParts.join("&");
      }
      return url;
    };
    getBody = (opts2) => {
      if (opts2.type === "query") {
        return void 0;
      }
      const input = getInput(opts2);
      return input !== void 0 ? JSON.stringify(input) : void 0;
    };
    jsonHttpRequester = (opts2) => {
      return httpRequest({
        ...opts2,
        contentTypeHeader: "application/json",
        getUrl,
        getBody
      });
    };
    throwFatalError = () => {
      throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
    };
    batchRequester = (requesterOpts) => {
      return (batchOps) => {
        const path = batchOps.map((op) => op.path).join(",");
        const inputs = batchOps.map((op) => op.input);
        const { promise, cancel } = jsonHttpRequester({
          ...requesterOpts,
          path,
          inputs,
          headers() {
            if (!requesterOpts.opts.headers) {
              return {};
            }
            if (typeof requesterOpts.opts.headers === "function") {
              return requesterOpts.opts.headers({
                opList: batchOps
              });
            }
            return requesterOpts.opts.headers;
          }
        });
        return {
          promise: promise.then((res) => {
            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
            const result = resJSON.map((item) => ({
              meta: res.meta,
              json: item
            }));
            return result;
          }),
          cancel
        };
      };
    };
    httpBatchLink = createHTTPBatchLink(batchRequester);
    TRPCUntypedClient = class {
      $request({ type, input, path, context = {} }) {
        const chain$ = createChain({
          links: this.links,
          op: {
            id: ++this.requestId,
            type,
            path,
            input,
            context
          }
        });
        return chain$.pipe(share());
      }
      requestAsPromise(opts2) {
        const req$ = this.$request(opts2);
        const { promise, abort } = observableToPromise(req$);
        const abortablePromise = new Promise((resolve, reject) => {
          opts2.signal?.addEventListener("abort", abort);
          promise.then((envelope) => {
            resolve(envelope.result.data);
          }).catch((err) => {
            reject(TRPCClientError.from(err));
          });
        });
        return abortablePromise;
      }
      query(path, input, opts2) {
        return this.requestAsPromise({
          type: "query",
          path,
          input,
          context: opts2?.context,
          signal: opts2?.signal
        });
      }
      mutation(path, input, opts2) {
        return this.requestAsPromise({
          type: "mutation",
          path,
          input,
          context: opts2?.context,
          signal: opts2?.signal
        });
      }
      subscription(path, input, opts2) {
        const observable$ = this.$request({
          type: "subscription",
          path,
          input,
          context: opts2?.context
        });
        return observable$.subscribe({
          next(envelope) {
            if (envelope.result.type === "started") {
              opts2.onStarted?.();
            } else if (envelope.result.type === "stopped") {
              opts2.onStopped?.();
            } else {
              opts2.onData?.(envelope.result.data);
            }
          },
          error(err) {
            opts2.onError?.(err);
          },
          complete() {
            opts2.onComplete?.();
          }
        });
      }
      constructor(opts2) {
        this.requestId = 0;
        const combinedTransformer = (() => {
          const transformer = opts2.transformer;
          if (!transformer) {
            return {
              input: {
                serialize: (data) => data,
                deserialize: (data) => data
              },
              output: {
                serialize: (data) => data,
                deserialize: (data) => data
              }
            };
          }
          if ("input" in transformer) {
            return opts2.transformer;
          }
          return {
            input: transformer,
            output: transformer
          };
        })();
        this.runtime = {
          transformer: {
            serialize: (data) => combinedTransformer.input.serialize(data),
            deserialize: (data) => combinedTransformer.output.deserialize(data)
          },
          combinedTransformer
        };
        this.links = opts2.links.map((link) => link(this.runtime));
      }
    };
    clientCallTypeMap = {
      query: "query",
      mutate: "mutation",
      subscribe: "subscription"
    };
    clientCallTypeToProcedureType = (clientCallType) => {
      return clientCallTypeMap[clientCallType];
    };
    Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        const identity2 = {
          listener
        };
        this.listeners.add(identity2);
        this.onSubscribe();
        return () => {
          this.listeners.delete(identity2);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };
    isServer = typeof window === "undefined" || "Deno" in window;
    FocusManager = class extends Subscribable {
      constructor() {
        super();
        this.setup = (onFocus) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            window.addEventListener("focus", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
              window.removeEventListener("focus", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.focused !== focused;
        if (changed) {
          this.focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isFocused() {
        if (typeof this.focused === "boolean") {
          return this.focused;
        }
        if (typeof document === "undefined") {
          return true;
        }
        return [void 0, "visible", "prerender"].includes(document.visibilityState);
      }
    };
    focusManager = new FocusManager();
    onlineEvents = ["online", "offline"];
    OnlineManager = class extends Subscribable {
      constructor() {
        super();
        this.setup = (onOnline) => {
          if (!isServer && window.addEventListener) {
            const listener = () => onOnline();
            onlineEvents.forEach((event) => {
              window.addEventListener(event, listener, false);
            });
            return () => {
              onlineEvents.forEach((event) => {
                window.removeEventListener(event, listener);
              });
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((online) => {
          if (typeof online === "boolean") {
            this.setOnline(online);
          } else {
            this.onOnline();
          }
        });
      }
      setOnline(online) {
        const changed = this.online !== online;
        if (changed) {
          this.online = online;
          this.onOnline();
        }
      }
      onOnline() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isOnline() {
        if (typeof this.online === "boolean") {
          return this.online;
        }
        if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
          return true;
        }
        return navigator.onLine;
      }
    };
    onlineManager = new OnlineManager();
    CancelledError = class {
      constructor(options) {
        this.revert = options == null ? void 0 : options.revert;
        this.silent = options == null ? void 0 : options.silent;
      }
    };
    defaultLogger = console;
    notifyManager = createNotifyManager();
    Removable = class {
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (isValidTimeout(this.cacheTime)) {
          this.gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.cacheTime);
        }
      }
      updateCacheTime(newCacheTime) {
        this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
      }
      clearGcTimeout() {
        if (this.gcTimeout) {
          clearTimeout(this.gcTimeout);
          this.gcTimeout = void 0;
        }
      }
    };
    Query = class extends Removable {
      constructor(config) {
        super();
        this.abortSignalConsumed = false;
        this.defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.cache = config.cache;
        this.logger = config.logger || defaultLogger;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.initialState = config.state || getDefaultState$1(this.options);
        this.state = this.initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.cache.remove(this);
        }
      }
      setData(newData, options) {
        const data = replaceData(this.state.data, newData, this.options);
        this.dispatch({
          data,
          type: "success",
          dataUpdatedAt: options == null ? void 0 : options.updatedAt,
          manual: options == null ? void 0 : options.manual
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.dispatch({
          type: "setState",
          state,
          setStateOptions
        });
      }
      cancel(options) {
        var _this$retryer;
        const promise = this.promise;
        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
        return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({
          silent: true
        });
      }
      reset() {
        this.destroy();
        this.setState(this.initialState);
      }
      isActive() {
        return this.observers.some((observer) => observer.options.enabled !== false);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        var _this$retryer2;
        const observer = this.observers.find((x4) => x4.shouldFetchOnWindowFocus());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
      }
      onOnline() {
        var _this$retryer3;
        const observer = this.observers.find((x4) => x4.shouldFetchOnReconnect());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.cache.notify({
            type: "observerAdded",
            query: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x4) => x4 !== observer);
          if (!this.observers.length) {
            if (this.retryer) {
              if (this.abortSignalConsumed) {
                this.retryer.cancel({
                  revert: true
                });
              } else {
                this.retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.cache.notify({
            type: "observerRemoved",
            query: this,
            observer
          });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.dispatch({
            type: "invalidate"
          });
        }
      }
      fetch(options, fetchOptions) {
        var _this$options$behavio, _context$fetchOptions;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
            this.cancel({
              silent: true
            });
          } else if (this.promise) {
            var _this$retryer4;
            (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
            return this.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x4) => x4.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        const abortController = getAbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          pageParam: void 0,
          meta: this.meta
        };
        const addSignalProperty = (object2) => {
          Object.defineProperty(object2, "signal", {
            enumerable: true,
            get: () => {
              if (abortController) {
                this.abortSignalConsumed = true;
                return abortController.signal;
              }
              return void 0;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (!this.options.queryFn) {
            return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
          }
          this.abortSignalConsumed = false;
          return this.options.queryFn(queryFnContext);
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
        this.revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
          var _context$fetchOptions2;
          this.dispatch({
            type: "fetch",
            meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
          });
        }
        const onError = (error2) => {
          if (!(isCancelledError(error2) && error2.silent)) {
            this.dispatch({
              type: "error",
              error: error2
            });
          }
          if (!isCancelledError(error2)) {
            var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
            (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error2, this);
            (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error2, this);
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.retryer = createRetryer({
          fn: context.fetchFn,
          abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
          onSuccess: (data) => {
            var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
            if (typeof data === "undefined") {
              onError(new Error(this.queryHash + " data is undefined"));
              return;
            }
            this.setData(data);
            (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
            (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error2) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error: error2
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode
        });
        this.promise = this.retryer.promise;
        return this.promise;
      }
      dispatch(action) {
        const reducer2 = (state) => {
          var _action$meta, _action$dataUpdatedAt;
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
                fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!state.dataUpdatedAt && {
                  error: null,
                  status: "loading"
                }
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error2 = action.error;
              if (isCancelledError(error2) && error2.revert && this.revertState) {
                return {
                  ...this.revertState,
                  fetchStatus: "idle"
                };
              }
              return {
                ...state,
                error: error2,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error2,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer2(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate(action);
          });
          this.cache.notify({
            query: this,
            type: "updated",
            action
          });
        });
      }
    };
    QueryCache = class extends Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.queries = [];
        this.queriesMap = {};
      }
      build(client, options, state) {
        var _options$queryHash;
        const queryKey = options.queryKey;
        const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
        let query = this.get(queryHash);
        if (!query) {
          query = new Query({
            cache: this,
            logger: client.getLogger(),
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query);
        }
        return query;
      }
      add(query) {
        if (!this.queriesMap[query.queryHash]) {
          this.queriesMap[query.queryHash] = query;
          this.queries.push(query);
          this.notify({
            type: "added",
            query
          });
        }
      }
      remove(query) {
        const queryInMap = this.queriesMap[query.queryHash];
        if (queryInMap) {
          query.destroy();
          this.queries = this.queries.filter((x4) => x4 !== query);
          if (queryInMap === query) {
            delete this.queriesMap[query.queryHash];
          }
          this.notify({
            type: "removed",
            query
          });
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            this.remove(query);
          });
        });
      }
      get(queryHash) {
        return this.queriesMap[queryHash];
      }
      getAll() {
        return this.queries;
      }
      find(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.queries.find((query) => matchQuery(filters, query));
      }
      findAll(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            query.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.batch(() => {
          this.queries.forEach((query) => {
            query.onOnline();
          });
        });
      }
    };
    Mutation = class extends Removable {
      constructor(config) {
        super();
        this.defaultOptions = config.defaultOptions;
        this.mutationId = config.mutationId;
        this.mutationCache = config.mutationCache;
        this.logger = config.logger || defaultLogger;
        this.observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      get meta() {
        return this.options.meta;
      }
      setState(state) {
        this.dispatch({
          type: "setState",
          state
        });
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.observers = this.observers.filter((x4) => x4 !== observer);
        this.scheduleGc();
        this.mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.observers.length) {
          if (this.state.status === "loading") {
            this.scheduleGc();
          } else {
            this.mutationCache.remove(this);
          }
        }
      }
      continue() {
        var _this$retryer$continu, _this$retryer;
        return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
      }
      async execute() {
        const executeMutation = () => {
          var _this$options$retry;
          this.retryer = createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject("No mutationFn found");
              }
              return this.options.mutationFn(this.state.variables);
            },
            onFail: (failureCount, error2) => {
              this.dispatch({
                type: "failed",
                failureCount,
                error: error2
              });
            },
            onPause: () => {
              this.dispatch({
                type: "pause"
              });
            },
            onContinue: () => {
              this.dispatch({
                type: "continue"
              });
            },
            retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
          });
          return this.retryer.promise;
        };
        const restored = this.state.status === "loading";
        try {
          var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
          if (!restored) {
            var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
            this.dispatch({
              type: "loading",
              variables: this.options.variables
            });
            await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
            const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
            if (context !== this.state.context) {
              this.dispatch({
                type: "loading",
                context,
                variables: this.state.variables
              });
            }
          }
          const data = await executeMutation();
          await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
          await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
          await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
          this.dispatch({
            type: "success",
            data
          });
          return data;
        } catch (error2) {
          try {
            var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
            await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error2, this.state.variables, this.state.context, this));
            if (false)
              ;
            await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error2, this.state.variables, this.state.context));
            await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error2, this.state.variables, this.state.context, this));
            await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error2, this.state.variables, this.state.context));
            throw error2;
          } finally {
            this.dispatch({
              type: "error",
              error: error2
            });
          }
        }
      }
      dispatch(action) {
        const reducer2 = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "loading":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !canFetch(this.options.networkMode),
                status: "loading",
                variables: action.variables
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer2(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    MutationCache = class extends Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.mutations = [];
        this.mutationId = 0;
      }
      build(client, options, state) {
        const mutation = new Mutation({
          mutationCache: this,
          logger: client.getLogger(),
          mutationId: ++this.mutationId,
          options: client.defaultMutationOptions(options),
          state,
          defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
        });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        this.mutations.push(mutation);
        this.notify({
          type: "added",
          mutation
        });
      }
      remove(mutation) {
        this.mutations = this.mutations.filter((x4) => x4 !== mutation);
        this.notify({
          type: "removed",
          mutation
        });
      }
      clear() {
        notifyManager.batch(() => {
          this.mutations.forEach((mutation) => {
            this.remove(mutation);
          });
        });
      }
      getAll() {
        return this.mutations;
      }
      find(filters) {
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.mutations.find((mutation) => matchMutation(filters, mutation));
      }
      findAll(filters) {
        return this.mutations.filter((mutation) => matchMutation(filters, mutation));
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        var _this$resuming;
        this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
          const pausedMutations = this.mutations.filter((x4) => x4.state.isPaused);
          return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$1)), Promise.resolve()));
        }).then(() => {
          this.resuming = void 0;
        });
        return this.resuming;
      }
    };
    QueryClient = class {
      constructor(config = {}) {
        this.queryCache = config.queryCache || new QueryCache();
        this.mutationCache = config.mutationCache || new MutationCache();
        this.logger = config.logger || defaultLogger;
        this.defaultOptions = config.defaultOptions || {};
        this.queryDefaults = [];
        this.mutationDefaults = [];
        this.mountCount = 0;
      }
      mount() {
        this.mountCount++;
        if (this.mountCount !== 1)
          return;
        this.unsubscribeFocus = focusManager.subscribe(() => {
          if (focusManager.isFocused()) {
            this.resumePausedMutations();
            this.queryCache.onFocus();
          }
        });
        this.unsubscribeOnline = onlineManager.subscribe(() => {
          if (onlineManager.isOnline()) {
            this.resumePausedMutations();
            this.queryCache.onOnline();
          }
        });
      }
      unmount() {
        var _this$unsubscribeFocu, _this$unsubscribeOnli;
        this.mountCount--;
        if (this.mountCount !== 0)
          return;
        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
        this.unsubscribeFocus = void 0;
        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
        this.unsubscribeOnline = void 0;
      }
      isFetching(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        filters.fetchStatus = "fetching";
        return this.queryCache.findAll(filters).length;
      }
      isMutating(filters) {
        return this.mutationCache.findAll({
          ...filters,
          fetching: true
        }).length;
      }
      getQueryData(queryKey, filters) {
        var _this$queryCache$find;
        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
      }
      ensureQueryData(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        const cachedData = this.getQueryData(parsedOptions.queryKey);
        return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
      }
      getQueriesData(queryKeyOrFilters) {
        return this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey,
          state
        }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options) {
        const query = this.queryCache.find(queryKey);
        const prevData = query == null ? void 0 : query.state.data;
        const data = functionalUpdate$1(updater, prevData);
        if (typeof data === "undefined") {
          return void 0;
        }
        const parsedOptions = parseQueryArgs(queryKey);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        return this.queryCache.build(this, defaultedOptions).setData(data, {
          ...options,
          manual: true
        });
      }
      setQueriesData(queryKeyOrFilters, updater, options) {
        return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey
        }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
      }
      getQueryState(queryKey, filters) {
        var _this$queryCache$find2;
        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
      }
      removeQueries(arg1, arg2) {
        const [filters] = parseFilterArgs(arg1, arg2);
        const queryCache = this.queryCache;
        notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            queryCache.remove(query);
          });
        });
      }
      resetQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        const queryCache = this.queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options);
        });
      }
      cancelQueries(arg1, arg2, arg3) {
        const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
        if (typeof cancelOptions.revert === "undefined") {
          cancelOptions.revert = true;
        }
        const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
        return Promise.all(promises).then(noop$1).catch(noop$1);
      }
      invalidateQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        return notifyManager.batch(() => {
          var _ref, _filters$refetchType;
          this.queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
          };
          return this.refetchQueries(refetchFilters, options);
        });
      }
      refetchQueries(arg1, arg2, arg3) {
        const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
        const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          var _options$cancelRefetc;
          return query.fetch(void 0, {
            ...options,
            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
            meta: {
              refetchPage: filters.refetchPage
            }
          });
        }));
        let promise = Promise.all(promises).then(noop$1);
        if (!(options != null && options.throwOnError)) {
          promise = promise.catch(noop$1);
        }
        return promise;
      }
      fetchQuery(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        const query = this.queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(arg1, arg2, arg3) {
        return this.fetchQuery(arg1, arg2, arg3).then(noop$1).catch(noop$1);
      }
      fetchInfiniteQuery(arg1, arg2, arg3) {
        const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        parsedOptions.behavior = infiniteQueryBehavior();
        return this.fetchQuery(parsedOptions);
      }
      prefetchInfiniteQuery(arg1, arg2, arg3) {
        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$1).catch(noop$1);
      }
      resumePausedMutations() {
        return this.mutationCache.resumePausedMutations();
      }
      getQueryCache() {
        return this.queryCache;
      }
      getMutationCache() {
        return this.mutationCache;
      }
      getLogger() {
        return this.logger;
      }
      getDefaultOptions() {
        return this.defaultOptions;
      }
      setDefaultOptions(options) {
        this.defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        const result = this.queryDefaults.find((x4) => hashQueryKey(queryKey) === hashQueryKey(x4.queryKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.queryDefaults.push({
            queryKey,
            defaultOptions: options
          });
        }
      }
      getQueryDefaults(queryKey) {
        if (!queryKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.queryDefaults.find((x4) => partialMatchKey(queryKey, x4.queryKey));
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      setMutationDefaults(mutationKey, options) {
        const result = this.mutationDefaults.find((x4) => hashQueryKey(mutationKey) === hashQueryKey(x4.mutationKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.mutationDefaults.push({
            mutationKey,
            defaultOptions: options
          });
        }
      }
      getMutationDefaults(mutationKey) {
        if (!mutationKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.mutationDefaults.find((x4) => partialMatchKey(mutationKey, x4.mutationKey));
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      defaultQueryOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.defaultOptions.queries,
          ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
        }
        if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (typeof defaultedOptions.useErrorBoundary === "undefined") {
          defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        return {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.queryCache.clear();
        this.mutationCache.clear();
      }
    };
    QueryObserver = class extends Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.options = options;
        this.trackedProps = /* @__PURE__ */ new Set();
        this.selectError = null;
        this.bindMethods();
        this.setOptions(options);
      }
      bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.currentQuery, this.options)) {
            this.executeFetch();
          }
          this.updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.clearStaleTimeout();
        this.clearRefetchInterval();
        this.currentQuery.removeObserver(this);
      }
      setOptions(options, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryOptions(options);
        if (!shallowEqualObjects(prevOptions, this.options)) {
          this.client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this
          });
        }
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
          this.executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.updateStaleTimeout();
        }
        const nextRefetchInterval = this.computeRefetchInterval();
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
          this.updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query = this.client.getQueryCache().build(this.client, options);
        const result = this.createResult(query, options);
        if (shouldAssignObserverCurrentProperties(this, result, options)) {
          this.currentResult = result;
          this.currentResultOptions = this.options;
          this.currentResultState = this.currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.currentResult;
      }
      trackResult(result) {
        const trackedResult = {};
        Object.keys(result).forEach((key) => {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.trackedProps.add(key);
              return result[key];
            }
          });
        });
        return trackedResult;
      }
      getCurrentQuery() {
        return this.currentQuery;
      }
      remove() {
        this.client.getQueryCache().remove(this.currentQuery);
      }
      refetch({
        refetchPage,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            refetchPage
          }
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.client.defaultQueryOptions(options);
        const query = this.client.getQueryCache().build(this.client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        var _fetchOptions$cancelR;
        return this.executeFetch({
          ...fetchOptions,
          cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
        }).then(() => {
          this.updateResult();
          return this.currentResult;
        });
      }
      executeFetch(fetchOptions) {
        this.updateQuery();
        let promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions != null && fetchOptions.throwOnError)) {
          promise = promise.catch(noop$1);
        }
        return promise;
      }
      updateStaleTimeout() {
        this.clearStaleTimeout();
        if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
        const timeout = time + 1;
        this.staleTimeoutId = setTimeout(() => {
          if (!this.currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
      }
      updateRefetchInterval(nextInterval) {
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
          return;
        }
        this.refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
            this.executeFetch();
          }
        }, this.currentRefetchInterval);
      }
      updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
      }
      clearStaleTimeout() {
        if (this.staleTimeoutId) {
          clearTimeout(this.staleTimeoutId);
          this.staleTimeoutId = void 0;
        }
      }
      clearRefetchInterval() {
        if (this.refetchIntervalId) {
          clearInterval(this.refetchIntervalId);
          this.refetchIntervalId = void 0;
        }
      }
      createResult(query, options) {
        const prevQuery = this.currentQuery;
        const prevOptions = this.options;
        const prevResult = this.currentResult;
        const prevResultState = this.currentResultState;
        const prevResultOptions = this.currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        const {
          state
        } = query;
        let {
          dataUpdatedAt,
          error: error2,
          errorUpdatedAt,
          fetchStatus,
          status
        } = state;
        let isPreviousData = false;
        let isPlaceholderData = false;
        let data;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
            if (!dataUpdatedAt) {
              status = "loading";
            }
          }
          if (options._optimisticResults === "isRestoring") {
            fetchStatus = "idle";
          }
        }
        if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
          data = prevQueryResult.data;
          dataUpdatedAt = prevQueryResult.dataUpdatedAt;
          status = prevQueryResult.status;
          isPreviousData = true;
        } else if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
            data = this.selectResult;
          } else {
            try {
              this.selectFn = options.select;
              data = options.select(state.data);
              data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
              this.selectResult = data;
              this.selectError = null;
            } catch (selectError) {
              this.selectError = selectError;
            }
          }
        } else {
          data = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
          let placeholderData;
          if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                this.selectError = null;
              } catch (selectError) {
                this.selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
            isPlaceholderData = true;
          }
        }
        if (this.selectError) {
          error2 = this.selectError;
          data = this.selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = fetchStatus === "fetching";
        const isLoading = status === "loading";
        const isError = status === "error";
        const result = {
          status,
          fetchStatus,
          isLoading,
          isSuccess: status === "success",
          isError,
          isInitialLoading: isLoading && isFetching,
          data,
          dataUpdatedAt,
          error: error2,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          failureReason: state.fetchFailureReason,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isLoading,
          isLoadingError: isError && state.dataUpdatedAt === 0,
          isPaused: fetchStatus === "paused",
          isPlaceholderData,
          isPreviousData,
          isRefetchError: isError && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch,
          remove: this.remove
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.currentResult;
        const nextResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options;
        if (shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.currentResult = nextResult;
        const defaultNotifyOptions = {
          cache: true
        };
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const {
            notifyOnChangeProps
          } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
            return true;
          }
          const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
          if (this.options.useErrorBoundary) {
            includedProps.add("error");
          }
          return Object.keys(this.currentResult).some((key) => {
            const typedKey = key;
            const changed = this.currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.notify({
          ...defaultNotifyOptions,
          ...notifyOptions
        });
      }
      updateQuery() {
        const query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
          return;
        }
        const prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
          prevQuery == null ? void 0 : prevQuery.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate(action) {
        const notifyOptions = {};
        if (action.type === "success") {
          notifyOptions.onSuccess = !action.manual;
        } else if (action.type === "error" && !isCancelledError(action.error)) {
          notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
          this.updateTimers();
        }
      }
      notify(notifyOptions) {
        notifyManager.batch(() => {
          if (notifyOptions.onSuccess) {
            var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
            (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
            (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
          } else if (notifyOptions.onError) {
            var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
            (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
            (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
          }
          if (notifyOptions.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
          if (notifyOptions.cache) {
            this.client.getQueryCache().notify({
              query: this.currentQuery,
              type: "observerResultsUpdated"
            });
          }
        });
      }
    };
    QueriesObserver = class extends Subscribable {
      constructor(client, queries) {
        super();
        this.client = client;
        this.queries = [];
        this.result = [];
        this.observers = [];
        this.observersMap = {};
        if (queries) {
          this.setQueries(queries);
        }
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.observers.forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
        }
      }
      onUnsubscribe() {
        if (!this.listeners.size) {
          this.destroy();
        }
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.observers.forEach((observer) => {
          observer.destroy();
        });
      }
      setQueries(queries, notifyOptions) {
        this.queries = queries;
        notifyManager.batch(() => {
          const prevObservers = this.observers;
          const newObserverMatches = this.findMatchingObservers(this.queries);
          newObserverMatches.forEach((match2) => match2.observer.setOptions(match2.defaultedQueryOptions, notifyOptions));
          const newObservers = newObserverMatches.map((match2) => match2.observer);
          const newObserversMap = Object.fromEntries(newObservers.map((observer) => [observer.options.queryHash, observer]));
          const newResult = newObservers.map((observer) => observer.getCurrentResult());
          const hasIndexChange = newObservers.some((observer, index3) => observer !== prevObservers[index3]);
          if (prevObservers.length === newObservers.length && !hasIndexChange) {
            return;
          }
          this.observers = newObservers;
          this.observersMap = newObserversMap;
          this.result = newResult;
          if (!this.hasListeners()) {
            return;
          }
          difference(prevObservers, newObservers).forEach((observer) => {
            observer.destroy();
          });
          difference(newObservers, prevObservers).forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
          this.notify();
        });
      }
      getCurrentResult() {
        return this.result;
      }
      getQueries() {
        return this.observers.map((observer) => observer.getCurrentQuery());
      }
      getObservers() {
        return this.observers;
      }
      getOptimisticResult(queries) {
        return this.findMatchingObservers(queries).map((match2) => match2.observer.getOptimisticResult(match2.defaultedQueryOptions));
      }
      findMatchingObservers(queries) {
        const prevObservers = this.observers;
        const prevObserversMap = new Map(prevObservers.map((observer) => [observer.options.queryHash, observer]));
        const defaultedQueryOptions = queries.map((options) => this.client.defaultQueryOptions(options));
        const matchingObservers = defaultedQueryOptions.flatMap((defaultedOptions) => {
          const match2 = prevObserversMap.get(defaultedOptions.queryHash);
          if (match2 != null) {
            return [{
              defaultedQueryOptions: defaultedOptions,
              observer: match2
            }];
          }
          return [];
        });
        const matchedQueryHashes = new Set(matchingObservers.map((match2) => match2.defaultedQueryOptions.queryHash));
        const unmatchedQueries = defaultedQueryOptions.filter((defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash));
        const matchingObserversSet = new Set(matchingObservers.map((match2) => match2.observer));
        const unmatchedObservers = prevObservers.filter((prevObserver) => !matchingObserversSet.has(prevObserver));
        const getObserver = (options) => {
          const defaultedOptions = this.client.defaultQueryOptions(options);
          const currentObserver = this.observersMap[defaultedOptions.queryHash];
          return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);
        };
        const newOrReusedObservers = unmatchedQueries.map((options, index3) => {
          if (options.keepPreviousData) {
            const previouslyUsedObserver = unmatchedObservers[index3];
            if (previouslyUsedObserver !== void 0) {
              return {
                defaultedQueryOptions: options,
                observer: previouslyUsedObserver
              };
            }
          }
          return {
            defaultedQueryOptions: options,
            observer: getObserver(options)
          };
        });
        const sortMatchesByOrderOfQueries = (a2, b2) => defaultedQueryOptions.indexOf(a2.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b2.defaultedQueryOptions);
        return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
      }
      onUpdate(observer, result) {
        const index3 = this.observers.indexOf(observer);
        if (index3 !== -1) {
          this.result = replaceAt(this.result, index3, result);
          this.notify();
        }
      }
      notify() {
        notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.result);
          });
        });
      }
    };
    InfiniteQueryObserver = class extends QueryObserver {
      // Type override
      // Type override
      // Type override
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(client, options) {
        super(client, options);
      }
      bindMethods() {
        super.bindMethods();
        this.fetchNextPage = this.fetchNextPage.bind(this);
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
      }
      setOptions(options, notifyOptions) {
        super.setOptions({
          ...options,
          behavior: infiniteQueryBehavior()
        }, notifyOptions);
      }
      getOptimisticResult(options) {
        options.behavior = infiniteQueryBehavior();
        return super.getOptimisticResult(options);
      }
      fetchNextPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "forward",
              pageParam
            }
          }
        });
      }
      fetchPreviousPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "backward",
              pageParam
            }
          }
        });
      }
      createResult(query, options) {
        var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;
        const {
          state
        } = query;
        const result = super.createResult(query, options);
        const {
          isFetching,
          isRefetching
        } = result;
        const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === "forward";
        const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === "backward";
        return {
          ...result,
          fetchNextPage: this.fetchNextPage,
          fetchPreviousPage: this.fetchPreviousPage,
          hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
          hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
          isFetchingNextPage,
          isFetchingPreviousPage,
          isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
        };
      }
    };
    MutationObserver$1 = class MutationObserver2 extends Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.setOptions(options);
        this.bindMethods();
        this.updateResult();
      }
      bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
      }
      setOptions(options) {
        var _this$currentMutation;
        const prevOptions = this.options;
        this.options = this.client.defaultMutationOptions(options);
        if (!shallowEqualObjects(prevOptions, this.options)) {
          this.client.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.currentMutation,
            observer: this
          });
        }
        (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$currentMutation2;
          (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
        }
      }
      onMutationUpdate(action) {
        this.updateResult();
        const notifyOptions = {
          listeners: true
        };
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error") {
          notifyOptions.onError = true;
        }
        this.notify(notifyOptions);
      }
      getCurrentResult() {
        return this.currentResult;
      }
      reset() {
        this.currentMutation = void 0;
        this.updateResult();
        this.notify({
          listeners: true
        });
      }
      mutate(variables, options) {
        this.mutateOptions = options;
        if (this.currentMutation) {
          this.currentMutation.removeObserver(this);
        }
        this.currentMutation = this.client.getMutationCache().build(this.client, {
          ...this.options,
          variables: typeof variables !== "undefined" ? variables : this.options.variables
        });
        this.currentMutation.addObserver(this);
        return this.currentMutation.execute();
      }
      updateResult() {
        const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
        const result = {
          ...state,
          isLoading: state.status === "loading",
          isSuccess: state.status === "success",
          isError: state.status === "error",
          isIdle: state.status === "idle",
          mutate: this.mutate,
          reset: this.reset
        };
        this.currentResult = result;
      }
      notify(options) {
        notifyManager.batch(() => {
          if (this.mutateOptions && this.hasListeners()) {
            if (options.onSuccess) {
              var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
              (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
            } else if (options.onError) {
              var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
              (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            }
          }
          if (options.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
        });
      }
    };
    reactDom = { exports: {} };
    reactDom_production_min = {};
    scheduler = { exports: {} };
    scheduler_production_min = {};
    (function(exports) {
      function f3(a2, b2) {
        var c2 = a2.length;
        a2.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a2[d2];
            if (0 < g(e2, b2))
              a2[d2] = b2, a2[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k4(a2) {
        if (0 === a2.length)
          return null;
        var b2 = a2[0], c2 = a2.pop();
        if (c2 !== b2) {
          a2[0] = c2;
          a:
            for (var d2 = 0, e2 = a2.length, w5 = e2 >>> 1; d2 < w5; ) {
              var m2 = 2 * (d2 + 1) - 1, C4 = a2[m2], n5 = m2 + 1, x4 = a2[n5];
              if (0 > g(C4, c2))
                n5 < e2 && 0 > g(x4, C4) ? (a2[d2] = x4, a2[n5] = c2, d2 = n5) : (a2[d2] = C4, a2[m2] = c2, d2 = m2);
              else if (n5 < e2 && 0 > g(x4, c2))
                a2[d2] = x4, a2[n5] = c2, d2 = n5;
              else
                break a;
            }
        }
        return b2;
      }
      function g(a2, b2) {
        var c2 = a2.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l4 = performance;
        exports.unstable_now = function() {
          return l4.now();
        };
      } else {
        var p4 = Date, q2 = p4.now();
        exports.unstable_now = function() {
          return p4.now() - q2;
        };
      }
      var r5 = [], t5 = [], u4 = 1, v4 = null, y3 = 3, z4 = false, A4 = false, B4 = false, D5 = "function" === typeof setTimeout ? setTimeout : null, E4 = "function" === typeof clearTimeout ? clearTimeout : null, F4 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G4(a2) {
        for (var b2 = h2(t5); null !== b2; ) {
          if (null === b2.callback)
            k4(t5);
          else if (b2.startTime <= a2)
            k4(t5), b2.sortIndex = b2.expirationTime, f3(r5, b2);
          else
            break;
          b2 = h2(t5);
        }
      }
      function H3(a2) {
        B4 = false;
        G4(a2);
        if (!A4)
          if (null !== h2(r5))
            A4 = true, I4(J3);
          else {
            var b2 = h2(t5);
            null !== b2 && K3(H3, b2.startTime - a2);
          }
      }
      function J3(a2, b2) {
        A4 = false;
        B4 && (B4 = false, E4(L4), L4 = -1);
        z4 = true;
        var c2 = y3;
        try {
          G4(b2);
          for (v4 = h2(r5); null !== v4 && (!(v4.expirationTime > b2) || a2 && !M3()); ) {
            var d2 = v4.callback;
            if ("function" === typeof d2) {
              v4.callback = null;
              y3 = v4.priorityLevel;
              var e2 = d2(v4.expirationTime <= b2);
              b2 = exports.unstable_now();
              "function" === typeof e2 ? v4.callback = e2 : v4 === h2(r5) && k4(r5);
              G4(b2);
            } else
              k4(r5);
            v4 = h2(r5);
          }
          if (null !== v4)
            var w5 = true;
          else {
            var m2 = h2(t5);
            null !== m2 && K3(H3, m2.startTime - b2);
            w5 = false;
          }
          return w5;
        } finally {
          v4 = null, y3 = c2, z4 = false;
        }
      }
      var N4 = false, O4 = null, L4 = -1, P5 = 5, Q3 = -1;
      function M3() {
        return exports.unstable_now() - Q3 < P5 ? false : true;
      }
      function R5() {
        if (null !== O4) {
          var a2 = exports.unstable_now();
          Q3 = a2;
          var b2 = true;
          try {
            b2 = O4(true, a2);
          } finally {
            b2 ? S4() : (N4 = false, O4 = null);
          }
        } else
          N4 = false;
      }
      var S4;
      if ("function" === typeof F4)
        S4 = function() {
          F4(R5);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T4 = new MessageChannel(), U3 = T4.port2;
        T4.port1.onmessage = R5;
        S4 = function() {
          U3.postMessage(null);
        };
      } else
        S4 = function() {
          D5(R5, 0);
        };
      function I4(a2) {
        O4 = a2;
        N4 || (N4 = true, S4());
      }
      function K3(a2, b2) {
        L4 = D5(function() {
          a2(exports.unstable_now());
        }, b2);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A4 || z4 || (A4 = true, I4(J3));
      };
      exports.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P5 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y3;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h2(r5);
      };
      exports.unstable_next = function(a2) {
        switch (y3) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y3;
        }
        var c2 = y3;
        y3 = b2;
        try {
          return a2();
        } finally {
          y3 = c2;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y3;
        y3 = a2;
        try {
          return b2();
        } finally {
          y3 = c2;
        }
      };
      exports.unstable_scheduleCallback = function(a2, b2, c2) {
        var d2 = exports.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: u4++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a2.sortIndex = c2, f3(t5, a2), null === h2(r5) && a2 === h2(t5) && (B4 ? (E4(L4), L4 = -1) : B4 = true, K3(H3, c2 - d2))) : (a2.sortIndex = e2, f3(r5, a2), A4 || z4 || (A4 = true, I4(J3)));
        return a2;
      };
      exports.unstable_shouldYield = M3;
      exports.unstable_wrapCallback = function(a2) {
        var b2 = y3;
        return function() {
          var c2 = y3;
          y3 = b2;
          try {
            return a2.apply(this, arguments);
          } finally {
            y3 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    schedulerExports = scheduler.exports;
    aa = reactExports;
    ca2 = schedulerExports;
    da = /* @__PURE__ */ new Set();
    ea = {};
    ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    ja = Object.prototype.hasOwnProperty;
    ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    la = {};
    ma = {};
    z2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z2[a2] = new v2(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      z2[b2] = new v2(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z2[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z2[a2] = new v2(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z2[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z2[a2] = new v2(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z2[a2] = new v2(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z2[a2] = new v2(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z2[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    ra = /[\-:]([a-z])/g;
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        ra,
        sa
      );
      z2[b2] = new v2(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z2[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z2.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z2[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    va = Symbol.for("react.element");
    wa = Symbol.for("react.portal");
    ya = Symbol.for("react.fragment");
    za = Symbol.for("react.strict_mode");
    Aa = Symbol.for("react.profiler");
    Ba = Symbol.for("react.provider");
    Ca = Symbol.for("react.context");
    Da = Symbol.for("react.forward_ref");
    Ea = Symbol.for("react.suspense");
    Fa = Symbol.for("react.suspense_list");
    Ga = Symbol.for("react.memo");
    Ha = Symbol.for("react.lazy");
    Ia = Symbol.for("react.offscreen");
    Ja = Symbol.iterator;
    A2 = Object.assign;
    Na = false;
    eb = Array.isArray;
    nb = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b2, c2, d2, e2);
        });
      } : a2;
    }(function(a2, b2) {
      if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
        a2.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b2.firstChild; )
          a2.appendChild(b2.firstChild);
      }
    });
    pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a2) {
      qb.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        pb[b2] = pb[a2];
      });
    });
    tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    wb = null;
    yb = null;
    zb = null;
    Ab = null;
    Ib = false;
    Lb = false;
    if (ia)
      try {
        Mb2 = {};
        Object.defineProperty(Mb2, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb2, Mb2);
        window.removeEventListener("test", Mb2, Mb2);
      } catch (a2) {
        Lb = false;
      }
    Ob = false;
    Pb = null;
    Qb = false;
    Rb = null;
    Sb = { onError: function(a2) {
      Ob = true;
      Pb = a2;
    } };
    ac = ca2.unstable_scheduleCallback;
    bc = ca2.unstable_cancelCallback;
    cc = ca2.unstable_shouldYield;
    dc = ca2.unstable_requestPaint;
    B2 = ca2.unstable_now;
    ec = ca2.unstable_getCurrentPriorityLevel;
    fc = ca2.unstable_ImmediatePriority;
    gc = ca2.unstable_UserBlockingPriority;
    hc = ca2.unstable_NormalPriority;
    ic = ca2.unstable_LowPriority;
    jc = ca2.unstable_IdlePriority;
    kc = null;
    lc = null;
    oc = Math.clz32 ? Math.clz32 : nc;
    pc = Math.log;
    qc = Math.LN2;
    rc = 64;
    sc = 4194304;
    C2 = 0;
    Jc = false;
    Kc = [];
    Lc = null;
    Mc = null;
    Nc = null;
    Oc = /* @__PURE__ */ new Map();
    Pc = /* @__PURE__ */ new Map();
    Qc = [];
    Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    cd = ua.ReactCurrentBatchConfig;
    dd = true;
    id$1 = null;
    kd = null;
    ld = null;
    md = null;
    sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 };
    td = rd(sd);
    ud = A2({}, sd, { view: 0, detail: 0 });
    vd = rd(ud);
    Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } });
    Bd = rd(Ad);
    Cd = A2({}, Ad, { dataTransfer: 0 });
    Dd = rd(Cd);
    Ed = A2({}, ud, { relatedTarget: 0 });
    Fd = rd(Ed);
    Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    Hd = rd(Gd);
    Id = A2({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } });
    Jd = rd(Id);
    Kd = A2({}, sd, { data: 0 });
    Ld = rd(Kd);
    Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    Qd = A2({}, ud, { key: function(a2) {
      if (a2.key) {
        var b2 = Md[a2.key] || a2.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } });
    Rd = rd(Qd);
    Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    Td = rd(Sd);
    Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    Vd = rd(Ud);
    Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    Xd = rd(Wd);
    Yd = A2({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    Zd = rd(Yd);
    $d = [9, 13, 27, 32];
    ae$1 = ia && "CompositionEvent" in window;
    be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    ce$1 = ia && "TextEvent" in window && !be;
    de$1 = ia && (!ae$1 || be && 8 < be && 11 >= be);
    ee = String.fromCharCode(32);
    fe$1 = false;
    ie$1 = false;
    le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    pe2 = null;
    qe = null;
    we = false;
    if (ia) {
      if (ia) {
        ye = "oninput" in document;
        if (!ye) {
          ze$1 = document.createElement("div");
          ze$1.setAttribute("oninput", "return;");
          ye = "function" === typeof ze$1.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    He$1 = "function" === typeof Object.is ? Object.is : Ge;
    Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode;
    Qe$1 = null;
    Re = null;
    Se = null;
    Te = false;
    We$1 = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
    Xe = {};
    Ye$1 = {};
    ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
    $e$1 = Ze$1("animationend");
    af = Ze$1("animationiteration");
    bf = Ze$1("animationstart");
    cf = Ze$1("transitionend");
    df = /* @__PURE__ */ new Map();
    ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    for (gf = 0; gf < ef.length; gf++) {
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e$1, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    rf = "_reactListening" + Math.random().toString(36).slice(2);
    xf = /\r\n?/g;
    yf = /\u0000|\uFFFD/g;
    Cf = null;
    Df = null;
    Ff = "function" === typeof setTimeout ? setTimeout : void 0;
    Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    Hf = "function" === typeof Promise ? Promise : void 0;
    Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
      return Hf.resolve(null).then(a2).catch(If);
    } : Ff;
    Nf = Math.random().toString(36).slice(2);
    Of = "__reactFiber$" + Nf;
    Pf = "__reactProps$" + Nf;
    uf = "__reactContainer$" + Nf;
    of = "__reactEvents$" + Nf;
    Qf = "__reactListeners$" + Nf;
    Rf = "__reactHandles$" + Nf;
    Sf = [];
    Tf = -1;
    Vf = {};
    H = Uf(Vf);
    Wf = Uf(false);
    Xf = Vf;
    eg = null;
    fg = false;
    gg = false;
    kg = [];
    lg = 0;
    mg = null;
    ng = 0;
    og = [];
    pg = 0;
    qg = null;
    rg = 1;
    sg = "";
    xg = null;
    yg = null;
    I2 = false;
    zg = null;
    Kg = ua.ReactCurrentBatchConfig;
    Mg = Uf(null);
    Ng = null;
    Og = null;
    Pg = null;
    Wg = null;
    $g = false;
    jh = new aa.Component().refs;
    nh = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$1(), e2 = lh(a2), f3 = ch(d2, e2);
      f3.payload = b2;
      void 0 !== c2 && null !== c2 && (f3.callback = c2);
      b2 = dh(a2, f3, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueReplaceState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$1(), e2 = lh(a2), f3 = ch(d2, e2);
      f3.tag = 1;
      f3.payload = b2;
      void 0 !== c2 && null !== c2 && (f3.callback = c2);
      b2 = dh(a2, f3, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueForceUpdate: function(a2, b2) {
      a2 = a2._reactInternals;
      var c2 = L$1(), d2 = lh(a2), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a2, e2, d2);
      null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
    } };
    Bh = vh(true);
    Ch = vh(false);
    Dh = {};
    Eh = Uf(Dh);
    Fh = Uf(Dh);
    Gh = Uf(Dh);
    M = Uf(0);
    Nh = [];
    Ph = ua.ReactCurrentDispatcher;
    Qh = ua.ReactCurrentBatchConfig;
    Rh = 0;
    N2 = null;
    O$1 = null;
    P$1 = null;
    Sh = false;
    Th = false;
    Uh = 0;
    Vh = 0;
    ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false };
    Yh = { readContext: Vg, useCallback: function(a2, b2) {
      ci().memoizedState = [a2, void 0 === b2 ? null : b2];
      return a2;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a2),
        c2
      );
    }, useLayoutEffect: function(a2, b2) {
      return ti(4194308, 4, a2, b2);
    }, useInsertionEffect: function(a2, b2) {
      return ti(4, 2, a2, b2);
    }, useMemo: function(a2, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }, useReducer: function(a2, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
      d2.queue = a2;
      a2 = a2.dispatch = Gi.bind(null, N2, a2);
      return [d2.memoizedState, a2];
    }, useRef: function(a2) {
      var b2 = ci();
      a2 = { current: a2 };
      return b2.memoizedState = a2;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
      return ci().memoizedState = a2;
    }, useTransition: function() {
      var a2 = qi(false), b2 = a2[0];
      a2 = Ei.bind(null, a2[1]);
      ci().memoizedState = a2;
      return [b2, a2];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a2, b2, c2) {
      var d2 = N2, e2 = ci();
      if (I2) {
        if (void 0 === c2)
          throw Error(p$1(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R2)
          throw Error(p$1(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f3 = { value: c2, getSnapshot: b2 };
      e2.queue = f3;
      vi(ki.bind(
        null,
        d2,
        f3,
        a2
      ), [a2]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f3, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a2 = ci(), b2 = R2.identifierPrefix;
      if (I2) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a2.memoizedState = b2;
    }, unstable_isNewReconciler: false };
    Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a2) {
        var b2 = di();
        return Di(b2, O$1.memoizedState, a2);
      },
      useTransition: function() {
        var a2 = fi(ei)[0], b2 = di().memoizedState;
        return [a2, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    };
    $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a2) {
      var b2 = di();
      return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
    }, useTransition: function() {
      var a2 = gi(ei)[0], b2 = di().memoizedState;
      return [a2, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    Ni = "function" === typeof WeakMap ? WeakMap : Map;
    Xi = ua.ReactCurrentOwner;
    Ug = false;
    nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    Aj = function(a2, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a2, b2, c2, d2) {
      var e2 = a2.memoizedProps;
      if (e2 !== d2) {
        a2 = b2.stateNode;
        Hh(Eh.current);
        var f3 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a2, e2);
            d2 = Ya(a2, d2);
            f3 = [];
            break;
          case "select":
            e2 = A2({}, e2, { value: void 0 });
            d2 = A2({}, d2, { value: void 0 });
            f3 = [];
            break;
          case "textarea":
            e2 = gb(a2, e2);
            d2 = gb(a2, d2);
            f3 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
        }
        ub(c2, d2);
        var g;
        c2 = null;
        for (l4 in e2)
          if (!d2.hasOwnProperty(l4) && e2.hasOwnProperty(l4) && null != e2[l4])
            if ("style" === l4) {
              var h2 = e2[l4];
              for (g in h2)
                h2.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
            } else
              "dangerouslySetInnerHTML" !== l4 && "children" !== l4 && "suppressContentEditableWarning" !== l4 && "suppressHydrationWarning" !== l4 && "autoFocus" !== l4 && (ea.hasOwnProperty(l4) ? f3 || (f3 = []) : (f3 = f3 || []).push(l4, null));
        for (l4 in d2) {
          var k4 = d2[l4];
          h2 = null != e2 ? e2[l4] : void 0;
          if (d2.hasOwnProperty(l4) && k4 !== h2 && (null != k4 || null != h2))
            if ("style" === l4)
              if (h2) {
                for (g in h2)
                  !h2.hasOwnProperty(g) || k4 && k4.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
                for (g in k4)
                  k4.hasOwnProperty(g) && h2[g] !== k4[g] && (c2 || (c2 = {}), c2[g] = k4[g]);
              } else
                c2 || (f3 || (f3 = []), f3.push(
                  l4,
                  c2
                )), c2 = k4;
            else
              "dangerouslySetInnerHTML" === l4 ? (k4 = k4 ? k4.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k4 && h2 !== k4 && (f3 = f3 || []).push(l4, k4)) : "children" === l4 ? "string" !== typeof k4 && "number" !== typeof k4 || (f3 = f3 || []).push(l4, "" + k4) : "suppressContentEditableWarning" !== l4 && "suppressHydrationWarning" !== l4 && (ea.hasOwnProperty(l4) ? (null != k4 && "onScroll" === l4 && D$1("scroll", a2), f3 || h2 === k4 || (f3 = [])) : (f3 = f3 || []).push(l4, k4));
        }
        c2 && (f3 = f3 || []).push("style", c2);
        var l4 = f3;
        if (b2.updateQueue = l4)
          b2.flags |= 4;
      }
    };
    Dj = function(a2, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    Kj = false;
    U$1 = false;
    Lj = "function" === typeof WeakSet ? WeakSet : Set;
    V = null;
    Oj = false;
    X$2 = null;
    Yj = false;
    mk = Math.ceil;
    nk = ua.ReactCurrentDispatcher;
    ok = ua.ReactCurrentOwner;
    pk = ua.ReactCurrentBatchConfig;
    K$1 = 0;
    R2 = null;
    Y = null;
    Z = 0;
    gj = 0;
    fj = Uf(0);
    T2 = 0;
    qk = null;
    hh = 0;
    rk = 0;
    sk = 0;
    tk = null;
    uk = null;
    gk = 0;
    Hj = Infinity;
    vk = null;
    Pi = false;
    Qi = null;
    Si = null;
    wk = false;
    xk = null;
    yk = 0;
    zk = 0;
    Ak = null;
    Bk = -1;
    Ck = 0;
    Wk = function(a2, b2, c2) {
      if (null !== a2)
        if (a2.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a2, b2, c2);
          Ug = 0 !== (a2.flags & 131072) ? true : false;
        }
      else
        Ug = false, I2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a2, b2);
          a2 = b2.pendingProps;
          var e2 = Yf(b2, H.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a2, e2, c2);
          var f3 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f3 = true, cg(b2)) : f3 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f3, c2)) : (b2.tag = 0, I2 && f3 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a2, b2);
            a2 = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a2 = Lg(d2, a2);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a2, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a2, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a2, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
                break a;
            }
            throw Error(p$1(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a2)
              throw Error(p$1(387));
            d2 = b2.pendingProps;
            f3 = b2.memoizedState;
            e2 = f3.element;
            bh(a2, b2);
            gh(b2, d2, null, c2);
            var g = b2.memoizedState;
            d2 = g.element;
            if (f3.isDehydrated)
              if (f3 = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b2.updateQueue.baseState = f3, b2.memoizedState = f3, b2.flags & 256) {
                e2 = Ki(Error(p$1(423)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$1(424)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I2 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a2, b2, c2);
                break a;
              }
              Yi(a2, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f3 = null !== a2 ? a2.memoizedProps : null, g = e2.children, Ef(d2, e2) ? g = null : null !== f3 && Ef(d2, f3) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g, c2), b2.child;
        case 6:
          return null === a2 && Eg(b2), null;
        case 13:
          return pj(a2, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
        case 7:
          return Yi(a2, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f3 = b2.memoizedProps;
            g = e2.value;
            G2(Mg, d2._currentValue);
            d2._currentValue = g;
            if (null !== f3)
              if (He$1(f3.value, g)) {
                if (f3.children === e2.children && !Wf.current) {
                  b2 = $i(a2, b2, c2);
                  break a;
                }
              } else
                for (f3 = b2.child, null !== f3 && (f3.return = b2); null !== f3; ) {
                  var h2 = f3.dependencies;
                  if (null !== h2) {
                    g = f3.child;
                    for (var k4 = h2.firstContext; null !== k4; ) {
                      if (k4.context === d2) {
                        if (1 === f3.tag) {
                          k4 = ch(-1, c2 & -c2);
                          k4.tag = 2;
                          var l4 = f3.updateQueue;
                          if (null !== l4) {
                            l4 = l4.shared;
                            var m2 = l4.pending;
                            null === m2 ? k4.next = k4 : (k4.next = m2.next, m2.next = k4);
                            l4.pending = k4;
                          }
                        }
                        f3.lanes |= c2;
                        k4 = f3.alternate;
                        null !== k4 && (k4.lanes |= c2);
                        Sg(
                          f3.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k4 = k4.next;
                    }
                  } else if (10 === f3.tag)
                    g = f3.type === b2.type ? null : f3.child;
                  else if (18 === f3.tag) {
                    g = f3.return;
                    if (null === g)
                      throw Error(p$1(341));
                    g.lanes |= c2;
                    h2 = g.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g, c2, b2);
                    g = f3.sibling;
                  } else
                    g = f3.child;
                  if (null !== g)
                    g.return = f3;
                  else
                    for (g = f3; null !== g; ) {
                      if (g === b2) {
                        g = null;
                        break;
                      }
                      f3 = g.sibling;
                      if (null !== f3) {
                        f3.return = g.return;
                        g = f3;
                        break;
                      }
                      g = g.return;
                    }
                  f3 = g;
                }
            Yi(a2, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
        case 15:
          return cj(a2, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
        case 19:
          return yj(a2, b2, c2);
        case 22:
          return ej(a2, b2, c2);
      }
      throw Error(p$1(156, b2.tag));
    };
    ll = "function" === typeof reportError ? reportError : function(a2) {
      console.error(a2);
    };
    nl.prototype.render = ml.prototype.render = function(a2) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$1(409));
      gl(a2, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a2 = this._internalRoot;
      if (null !== a2) {
        this._internalRoot = null;
        var b2 = a2.containerInfo;
        Sk(function() {
          gl(null, a2, null, null);
        });
        b2[uf] = null;
      }
    };
    nl.prototype.unstable_scheduleHydration = function(a2) {
      if (a2) {
        var b2 = Hc();
        a2 = { blockedOn: null, target: a2, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a2);
        0 === c2 && Vc(a2);
      }
    };
    Ec = function(a2) {
      switch (a2.tag) {
        case 3:
          var b2 = a2.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B2()), 0 === (K$1 & 6) && (Hj = B2() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a2, 1);
            if (null !== b3) {
              var c3 = L$1();
              mh(b3, a2, 1, c3);
            }
          }), jl(a2, 1);
      }
    };
    Fc = function(a2) {
      if (13 === a2.tag) {
        var b2 = Zg(a2, 134217728);
        if (null !== b2) {
          var c2 = L$1();
          mh(b2, a2, 134217728, c2);
        }
        jl(a2, 134217728);
      }
    };
    Gc = function(a2) {
      if (13 === a2.tag) {
        var b2 = lh(a2), c2 = Zg(a2, b2);
        if (null !== c2) {
          var d2 = L$1();
          mh(c2, a2, b2, d2);
        }
        jl(a2, b2);
      }
    };
    Hc = function() {
      return C2;
    };
    Ic = function(a2, b2) {
      var c2 = C2;
      try {
        return C2 = a2, b2();
      } finally {
        C2 = c2;
      }
    };
    yb = function(a2, b2, c2) {
      switch (b2) {
        case "input":
          bb(a2, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a2; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a2 && d2.form === a2.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$1(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] };
    ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = Zb(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a2, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$1(200));
      return dl(a2, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a2, b2) {
      if (!ol(a2))
        throw Error(p$1(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
      a2[uf] = b2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b2 = a2._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a2.render)
          throw Error(p$1(188));
        a2 = Object.keys(a2).join(",");
        throw Error(p$1(268, a2));
      }
      a2 = Zb(b2);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2) {
      return Sk(a2);
    };
    reactDom_production_min.hydrate = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a2, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
      if (!ol(a2))
        throw Error(p$1(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f3 = "", g = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f3 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
      b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f3, g);
      a2[uf] = b2.current;
      sf(a2);
      if (d2)
        for (a2 = 0; a2 < d2.length; a2++)
          c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a2, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!pl(a2))
        throw Error(p$1(40));
      return a2._reactRootContainer ? (Sk(function() {
        sl(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$1(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(p$1(38));
      return sl(a2, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    reactDomExports = reactDom.exports;
    _n = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    shim = { exports: {} };
    useSyncExternalStoreShim_production_min = {};
    e = reactExports;
    k = "function" === typeof Object.is ? Object.is : h;
    l2 = e.useState;
    m = e.useEffect;
    n2 = e.useLayoutEffect;
    p2 = e.useDebugValue;
    u2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t2 : q;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u2;
    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }
    shimExports = shim.exports;
    useSyncExternalStore = shimExports.useSyncExternalStore;
    defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
    QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
    useQueryClient = ({
      context
    } = {}) => {
      const queryClient = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
      if (!queryClient) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return queryClient;
    };
    QueryClientProvider = ({
      client,
      children,
      context,
      contextSharing = false
    }) => {
      reactExports.useEffect(() => {
        client.mount();
        return () => {
          client.unmount();
        };
      }, [client]);
      const Context = getQueryClientContext(context, contextSharing);
      return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
      }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: client
      }, children));
    };
    IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
    useIsRestoring = () => reactExports.useContext(IsRestoringContext);
    IsRestoringContext.Provider;
    QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
    useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
    ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
      if (options.suspense || options.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    };
    useClearResetErrorBoundary = (errorResetBoundary) => {
      reactExports.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    };
    getHasError = ({
      result,
      errorResetBoundary,
      useErrorBoundary,
      query
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
    };
    ensureStaleTime = (defaultedOptions) => {
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
    };
    willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
    shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
    fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
      data
    }) => {
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error2) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error2);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error2);
    });
    contextProps = [
      "client",
      "ssrContext",
      "ssrState",
      "abortOnUnmount"
    ];
    TRPCContext = /* @__PURE__ */ reactExports.createContext(null);
    trpcReact = createTRPCReact();
    createTRPCProxyClient({
      links: [
        httpBatchLink({
          url: "http://localhost:4321/api/trpc"
        })
      ]
    });
    debug = "debugHeaders";
    Headers2 = {
      createTable: (table) => {
        table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
          var _left$map$filter, _right$map$filter;
          const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
          const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
          const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
          const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
          return headerGroups;
        }, getMemoOptions(table.options, debug));
        table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
          leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
          return buildHeaderGroups(allColumns, leafColumns, table, "center");
        }, getMemoOptions(table.options, debug));
        table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
          var _left$map$filter2;
          const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
          return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
        }, getMemoOptions(table.options, debug));
        table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
          var _right$map$filter2;
          const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
          return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
        }, getMemoOptions(table.options, debug));
        table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
          return [...headerGroups].reverse();
        }, getMemoOptions(table.options, debug));
        table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
          return [...headerGroups].reverse();
        }, getMemoOptions(table.options, debug));
        table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
          return [...headerGroups].reverse();
        }, getMemoOptions(table.options, debug));
        table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
          return [...headerGroups].reverse();
        }, getMemoOptions(table.options, debug));
        table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
          return headerGroups.map((headerGroup) => {
            return headerGroup.headers;
          }).flat();
        }, getMemoOptions(table.options, debug));
        table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
          return left.map((headerGroup) => {
            return headerGroup.headers;
          }).flat();
        }, getMemoOptions(table.options, debug));
        table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
          return left.map((headerGroup) => {
            return headerGroup.headers;
          }).flat();
        }, getMemoOptions(table.options, debug));
        table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
          return left.map((headerGroup) => {
            return headerGroup.headers;
          }).flat();
        }, getMemoOptions(table.options, debug));
        table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
          return flatHeaders.filter((header) => {
            var _header$subHeaders;
            return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
          });
        }, getMemoOptions(table.options, debug));
        table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
          return flatHeaders.filter((header) => {
            var _header$subHeaders2;
            return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
          });
        }, getMemoOptions(table.options, debug));
        table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
          return flatHeaders.filter((header) => {
            var _header$subHeaders3;
            return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
          });
        }, getMemoOptions(table.options, debug));
        table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
          var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
          return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
            return header.getLeafHeaders();
          }).flat();
        }, getMemoOptions(table.options, debug));
      }
    };
    createRow = (table, id3, original, rowIndex, depth, subRows, parentId) => {
      let row = {
        id: id3,
        index: rowIndex,
        original,
        depth,
        parentId,
        _valuesCache: {},
        _uniqueValuesCache: {},
        getValue: (columnId) => {
          if (row._valuesCache.hasOwnProperty(columnId)) {
            return row._valuesCache[columnId];
          }
          const column = table.getColumn(columnId);
          if (!(column != null && column.accessorFn)) {
            return void 0;
          }
          row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
          return row._valuesCache[columnId];
        },
        getUniqueValues: (columnId) => {
          if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
            return row._uniqueValuesCache[columnId];
          }
          const column = table.getColumn(columnId);
          if (!(column != null && column.accessorFn)) {
            return void 0;
          }
          if (!column.columnDef.getUniqueValues) {
            row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
            return row._uniqueValuesCache[columnId];
          }
          row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
          return row._uniqueValuesCache[columnId];
        },
        renderValue: (columnId) => {
          var _row$getValue;
          return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
        },
        subRows: subRows != null ? subRows : [],
        getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
        getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
        getParentRows: () => {
          let parentRows = [];
          let currentRow = row;
          while (true) {
            const parentRow = currentRow.getParentRow();
            if (!parentRow)
              break;
            parentRows.push(parentRow);
            currentRow = parentRow;
          }
          return parentRows.reverse();
        },
        getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
          return leafColumns.map((column) => {
            return createCell(table, row, column, column.id);
          });
        }, getMemoOptions(table.options, "debugRows")),
        _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
          return allCells.reduce((acc, cell) => {
            acc[cell.column.id] = cell;
            return acc;
          }, {});
        }, getMemoOptions(table.options, "debugRows"))
      };
      for (let i2 = 0; i2 < table._features.length; i2++) {
        const feature = table._features[i2];
        feature == null || feature.createRow == null || feature.createRow(row, table);
      }
      return row;
    };
    ColumnFaceting = {
      createColumn: (column, table) => {
        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
        column.getFacetedRowModel = () => {
          if (!column._getFacetedRowModel) {
            return table.getPreFilteredRowModel();
          }
          return column._getFacetedRowModel();
        };
        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
        column.getFacetedUniqueValues = () => {
          if (!column._getFacetedUniqueValues) {
            return /* @__PURE__ */ new Map();
          }
          return column._getFacetedUniqueValues();
        };
        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
        column.getFacetedMinMaxValues = () => {
          if (!column._getFacetedMinMaxValues) {
            return void 0;
          }
          return column._getFacetedMinMaxValues();
        };
      }
    };
    includesString = (row, columnId, filterValue) => {
      var _row$getValue;
      const search = filterValue.toLowerCase();
      return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
    };
    includesString.autoRemove = (val) => testFalsey(val);
    includesStringSensitive = (row, columnId, filterValue) => {
      var _row$getValue2;
      return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
    };
    includesStringSensitive.autoRemove = (val) => testFalsey(val);
    equalsString = (row, columnId, filterValue) => {
      var _row$getValue3;
      return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
    };
    equalsString.autoRemove = (val) => testFalsey(val);
    arrIncludes = (row, columnId, filterValue) => {
      var _row$getValue4;
      return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
    };
    arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
    arrIncludesAll = (row, columnId, filterValue) => {
      return !filterValue.some((val) => {
        var _row$getValue5;
        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
      });
    };
    arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
    arrIncludesSome = (row, columnId, filterValue) => {
      return filterValue.some((val) => {
        var _row$getValue6;
        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
      });
    };
    arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
    equals = (row, columnId, filterValue) => {
      return row.getValue(columnId) === filterValue;
    };
    equals.autoRemove = (val) => testFalsey(val);
    weakEquals = (row, columnId, filterValue) => {
      return row.getValue(columnId) == filterValue;
    };
    weakEquals.autoRemove = (val) => testFalsey(val);
    inNumberRange = (row, columnId, filterValue) => {
      let [min2, max2] = filterValue;
      const rowValue = row.getValue(columnId);
      return rowValue >= min2 && rowValue <= max2;
    };
    inNumberRange.resolveFilterValue = (val) => {
      let [unsafeMin, unsafeMax] = val;
      let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
      let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
      let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
      let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
      if (min2 > max2) {
        const temp = min2;
        min2 = max2;
        max2 = temp;
      }
      return [min2, max2];
    };
    inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
    filterFns = {
      includesString,
      includesStringSensitive,
      equalsString,
      arrIncludes,
      arrIncludesAll,
      arrIncludesSome,
      equals,
      weakEquals,
      inNumberRange
    };
    ColumnFiltering = {
      getDefaultColumnDef: () => {
        return {
          filterFn: "auto"
        };
      },
      getInitialState: (state) => {
        return {
          columnFilters: [],
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onColumnFiltersChange: makeStateUpdater("columnFilters", table),
          filterFromLeafRows: false,
          maxLeafRowFilterDepth: 100
        };
      },
      createColumn: (column, table) => {
        column.getAutoFilterFn = () => {
          const firstRow = table.getCoreRowModel().flatRows[0];
          const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
          if (typeof value === "string") {
            return filterFns.includesString;
          }
          if (typeof value === "number") {
            return filterFns.inNumberRange;
          }
          if (typeof value === "boolean") {
            return filterFns.equals;
          }
          if (value !== null && typeof value === "object") {
            return filterFns.equals;
          }
          if (Array.isArray(value)) {
            return filterFns.arrIncludes;
          }
          return filterFns.weakEquals;
        };
        column.getFilterFn = () => {
          var _table$options$filter, _table$options$filter2;
          return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
            // @ts-ignore
            (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
          );
        };
        column.getCanFilter = () => {
          var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
          return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
        };
        column.getIsFiltered = () => column.getFilterIndex() > -1;
        column.getFilterValue = () => {
          var _table$getState$colum;
          return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? void 0 : _table$getState$colum.value;
        };
        column.getFilterIndex = () => {
          var _table$getState$colum2, _table$getState$colum3;
          return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$colum2 : -1;
        };
        column.setFilterValue = (value) => {
          table.setColumnFilters((old) => {
            const filterFn = column.getFilterFn();
            const previousFilter = old == null ? void 0 : old.find((d2) => d2.id === column.id);
            const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
            if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
              var _old$filter;
              return (_old$filter = old == null ? void 0 : old.filter((d2) => d2.id !== column.id)) != null ? _old$filter : [];
            }
            const newFilterObj = {
              id: column.id,
              value: newFilter
            };
            if (previousFilter) {
              var _old$map;
              return (_old$map = old == null ? void 0 : old.map((d2) => {
                if (d2.id === column.id) {
                  return newFilterObj;
                }
                return d2;
              })) != null ? _old$map : [];
            }
            if (old != null && old.length) {
              return [...old, newFilterObj];
            }
            return [newFilterObj];
          });
        };
      },
      createRow: (row, _table) => {
        row.columnFilters = {};
        row.columnFiltersMeta = {};
      },
      createTable: (table) => {
        table.setColumnFilters = (updater) => {
          const leafColumns = table.getAllLeafColumns();
          const updateFn = (old) => {
            var _functionalUpdate;
            return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
              const column = leafColumns.find((d2) => d2.id === filter.id);
              if (column) {
                const filterFn = column.getFilterFn();
                if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
                  return false;
                }
              }
              return true;
            });
          };
          table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
        };
        table.resetColumnFilters = (defaultState) => {
          var _table$initialState$c, _table$initialState;
          table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
        };
        table.getPreFilteredRowModel = () => table.getCoreRowModel();
        table.getFilteredRowModel = () => {
          if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
            table._getFilteredRowModel = table.options.getFilteredRowModel(table);
          }
          if (table.options.manualFiltering || !table._getFilteredRowModel) {
            return table.getPreFilteredRowModel();
          }
          return table._getFilteredRowModel();
        };
      }
    };
    sum2 = (columnId, _leafRows, childRows) => {
      return childRows.reduce((sum22, next) => {
        const nextValue = next.getValue(columnId);
        return sum22 + (typeof nextValue === "number" ? nextValue : 0);
      }, 0);
    };
    min$2 = (columnId, _leafRows, childRows) => {
      let min2;
      childRows.forEach((row) => {
        const value = row.getValue(columnId);
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      });
      return min2;
    };
    max$2 = (columnId, _leafRows, childRows) => {
      let max2;
      childRows.forEach((row) => {
        const value = row.getValue(columnId);
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      });
      return max2;
    };
    extent = (columnId, _leafRows, childRows) => {
      let min2;
      let max2;
      childRows.forEach((row) => {
        const value = row.getValue(columnId);
        if (value != null) {
          if (min2 === void 0) {
            if (value >= value)
              min2 = max2 = value;
          } else {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      });
      return [min2, max2];
    };
    mean = (columnId, leafRows) => {
      let count22 = 0;
      let sum22 = 0;
      leafRows.forEach((row) => {
        let value = row.getValue(columnId);
        if (value != null && (value = +value) >= value) {
          ++count22, sum22 += value;
        }
      });
      if (count22)
        return sum22 / count22;
      return;
    };
    median = (columnId, leafRows) => {
      if (!leafRows.length) {
        return;
      }
      const values = leafRows.map((row) => row.getValue(columnId));
      if (!isNumberArray(values)) {
        return;
      }
      if (values.length === 1) {
        return values[0];
      }
      const mid = Math.floor(values.length / 2);
      const nums = values.sort((a2, b2) => a2 - b2);
      return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
    };
    unique = (columnId, leafRows) => {
      return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
    };
    uniqueCount = (columnId, leafRows) => {
      return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
    };
    count2 = (_columnId, leafRows) => {
      return leafRows.length;
    };
    aggregationFns = {
      sum: sum2,
      min: min$2,
      max: max$2,
      extent,
      mean,
      median,
      unique,
      uniqueCount,
      count: count2
    };
    ColumnGrouping = {
      getDefaultColumnDef: () => {
        return {
          aggregatedCell: (props) => {
            var _toString, _props$getValue;
            return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
          },
          aggregationFn: "auto"
        };
      },
      getInitialState: (state) => {
        return {
          grouping: [],
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onGroupingChange: makeStateUpdater("grouping", table),
          groupedColumnMode: "reorder"
        };
      },
      createColumn: (column, table) => {
        column.toggleGrouping = () => {
          table.setGrouping((old) => {
            if (old != null && old.includes(column.id)) {
              return old.filter((d2) => d2 !== column.id);
            }
            return [...old != null ? old : [], column.id];
          });
        };
        column.getCanGroup = () => {
          var _column$columnDef$ena, _table$options$enable;
          return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
        };
        column.getIsGrouped = () => {
          var _table$getState$group;
          return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
        };
        column.getGroupedIndex = () => {
          var _table$getState$group2;
          return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
        };
        column.getToggleGroupingHandler = () => {
          const canGroup = column.getCanGroup();
          return () => {
            if (!canGroup)
              return;
            column.toggleGrouping();
          };
        };
        column.getAutoAggregationFn = () => {
          const firstRow = table.getCoreRowModel().flatRows[0];
          const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
          if (typeof value === "number") {
            return aggregationFns.sum;
          }
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return aggregationFns.extent;
          }
        };
        column.getAggregationFn = () => {
          var _table$options$aggreg, _table$options$aggreg2;
          if (!column) {
            throw new Error();
          }
          return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
        };
      },
      createTable: (table) => {
        table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
        table.resetGrouping = (defaultState) => {
          var _table$initialState$g, _table$initialState;
          table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
        };
        table.getPreGroupedRowModel = () => table.getFilteredRowModel();
        table.getGroupedRowModel = () => {
          if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
            table._getGroupedRowModel = table.options.getGroupedRowModel(table);
          }
          if (table.options.manualGrouping || !table._getGroupedRowModel) {
            return table.getPreGroupedRowModel();
          }
          return table._getGroupedRowModel();
        };
      },
      createRow: (row, table) => {
        row.getIsGrouped = () => !!row.groupingColumnId;
        row.getGroupingValue = (columnId) => {
          if (row._groupingValuesCache.hasOwnProperty(columnId)) {
            return row._groupingValuesCache[columnId];
          }
          const column = table.getColumn(columnId);
          if (!(column != null && column.columnDef.getGroupingValue)) {
            return row.getValue(columnId);
          }
          row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
          return row._groupingValuesCache[columnId];
        };
        row._groupingValuesCache = {};
      },
      createCell: (cell, column, row, table) => {
        cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
        cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
        cell.getIsAggregated = () => {
          var _row$subRows;
          return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
        };
      }
    };
    ColumnOrdering = {
      getInitialState: (state) => {
        return {
          columnOrder: [],
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onColumnOrderChange: makeStateUpdater("columnOrder", table)
        };
      },
      createColumn: (column, table) => {
        column.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d2) => d2.id === column.id), getMemoOptions(table.options, "debugColumns"));
        column.getIsFirstColumn = (position) => {
          var _columns$;
          const columns = _getVisibleLeafColumns(table, position);
          return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
        };
        column.getIsLastColumn = (position) => {
          var _columns;
          const columns = _getVisibleLeafColumns(table, position);
          return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
        };
      },
      createTable: (table) => {
        table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
        table.resetColumnOrder = (defaultState) => {
          var _table$initialState$c;
          table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
        };
        table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
          let orderedColumns = [];
          if (!(columnOrder != null && columnOrder.length)) {
            orderedColumns = columns;
          } else {
            const columnOrderCopy = [...columnOrder];
            const columnsCopy = [...columns];
            while (columnsCopy.length && columnOrderCopy.length) {
              const targetColumnId = columnOrderCopy.shift();
              const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
              if (foundIndex > -1) {
                orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
              }
            }
            orderedColumns = [...orderedColumns, ...columnsCopy];
          }
          return orderColumns(orderedColumns, grouping, groupedColumnMode);
        }, getMemoOptions(table.options, "debugTable"));
      }
    };
    getDefaultColumnPinningState = () => ({
      left: [],
      right: []
    });
    ColumnPinning = {
      getInitialState: (state) => {
        return {
          columnPinning: getDefaultColumnPinningState(),
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onColumnPinningChange: makeStateUpdater("columnPinning", table)
        };
      },
      createColumn: (column, table) => {
        column.pin = (position) => {
          const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
          table.setColumnPinning((old) => {
            var _old$left3, _old$right3;
            if (position === "right") {
              var _old$left, _old$right;
              return {
                left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
                right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
              };
            }
            if (position === "left") {
              var _old$left2, _old$right2;
              return {
                left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
                right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
              };
            }
            return {
              left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
              right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
            };
          });
        };
        column.getCanPin = () => {
          const leafColumns = column.getLeafColumns();
          return leafColumns.some((d2) => {
            var _d$columnDef$enablePi, _ref, _table$options$enable;
            return ((_d$columnDef$enablePi = d2.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
          });
        };
        column.getIsPinned = () => {
          const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
          const {
            left,
            right
          } = table.getState().columnPinning;
          const isLeft = leafColumnIds.some((d2) => left == null ? void 0 : left.includes(d2));
          const isRight = leafColumnIds.some((d2) => right == null ? void 0 : right.includes(d2));
          return isLeft ? "left" : isRight ? "right" : false;
        };
        column.getPinnedIndex = () => {
          var _table$getState$colum, _table$getState$colum2;
          const position = column.getIsPinned();
          return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
        };
      },
      createRow: (row, table) => {
        row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
          const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
          return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
        }, getMemoOptions(table.options, "debugRows"));
        row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
          const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
            ...d2,
            position: "left"
          }));
          return cells;
        }, getMemoOptions(table.options, "debugRows"));
        row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
          const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
            ...d2,
            position: "right"
          }));
          return cells;
        }, getMemoOptions(table.options, "debugRows"));
      },
      createTable: (table) => {
        table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
        table.resetColumnPinning = (defaultState) => {
          var _table$initialState$c, _table$initialState;
          return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
        };
        table.getIsSomeColumnsPinned = (position) => {
          var _pinningState$positio;
          const pinningState = table.getState().columnPinning;
          if (!position) {
            var _pinningState$left, _pinningState$right;
            return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
          }
          return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
        };
        table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
          return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
        }, getMemoOptions(table.options, "debugColumns"));
        table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
          return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
        }, getMemoOptions(table.options, "debugColumns"));
        table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
          const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
          return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
        }, getMemoOptions(table.options, "debugColumns"));
      }
    };
    defaultColumnSizing = {
      size: 150,
      minSize: 20,
      maxSize: Number.MAX_SAFE_INTEGER
    };
    getDefaultColumnSizingInfoState = () => ({
      startOffset: null,
      startSize: null,
      deltaOffset: null,
      deltaPercentage: null,
      isResizingColumn: false,
      columnSizingStart: []
    });
    ColumnSizing = {
      getDefaultColumnDef: () => {
        return defaultColumnSizing;
      },
      getInitialState: (state) => {
        return {
          columnSizing: {},
          columnSizingInfo: getDefaultColumnSizingInfoState(),
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          columnResizeMode: "onEnd",
          columnResizeDirection: "ltr",
          onColumnSizingChange: makeStateUpdater("columnSizing", table),
          onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
        };
      },
      createColumn: (column, table) => {
        column.getSize = () => {
          var _column$columnDef$min, _ref, _column$columnDef$max;
          const columnSize = table.getState().columnSizing[column.id];
          return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
        };
        column.getStart = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum22, column2) => sum22 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns"));
        column.getAfter = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum22, column2) => sum22 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns"));
        column.resetSize = () => {
          table.setColumnSizing((_ref2) => {
            let {
              [column.id]: _3,
              ...rest
            } = _ref2;
            return rest;
          });
        };
        column.getCanResize = () => {
          var _column$columnDef$ena, _table$options$enable;
          return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
        };
        column.getIsResizing = () => {
          return table.getState().columnSizingInfo.isResizingColumn === column.id;
        };
      },
      createHeader: (header, table) => {
        header.getSize = () => {
          let sum22 = 0;
          const recurse = (header2) => {
            if (header2.subHeaders.length) {
              header2.subHeaders.forEach(recurse);
            } else {
              var _header$column$getSiz;
              sum22 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
            }
          };
          recurse(header);
          return sum22;
        };
        header.getStart = () => {
          if (header.index > 0) {
            const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
            return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
          }
          return 0;
        };
        header.getResizeHandler = (_contextDocument) => {
          const column = table.getColumn(header.column.id);
          const canResize = column == null ? void 0 : column.getCanResize();
          return (e2) => {
            if (!column || !canResize) {
              return;
            }
            e2.persist == null || e2.persist();
            if (isTouchStartEvent(e2)) {
              if (e2.touches && e2.touches.length > 1) {
                return;
              }
            }
            const startSize = header.getSize();
            const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
            const clientX = isTouchStartEvent(e2) ? Math.round(e2.touches[0].clientX) : e2.clientX;
            const newColumnSizing = {};
            const updateOffset = (eventType, clientXPos) => {
              if (typeof clientXPos !== "number") {
                return;
              }
              table.setColumnSizingInfo((old) => {
                var _old$startOffset, _old$startSize;
                const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
                const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
                const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
                old.columnSizingStart.forEach((_ref3) => {
                  let [columnId, headerSize] = _ref3;
                  newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
                });
                return {
                  ...old,
                  deltaOffset,
                  deltaPercentage
                };
              });
              if (table.options.columnResizeMode === "onChange" || eventType === "end") {
                table.setColumnSizing((old) => ({
                  ...old,
                  ...newColumnSizing
                }));
              }
            };
            const onMove = (clientXPos) => updateOffset("move", clientXPos);
            const onEnd = (clientXPos) => {
              updateOffset("end", clientXPos);
              table.setColumnSizingInfo((old) => ({
                ...old,
                isResizingColumn: false,
                startOffset: null,
                startSize: null,
                deltaOffset: null,
                deltaPercentage: null,
                columnSizingStart: []
              }));
            };
            const contextDocument = _contextDocument || typeof document !== "undefined" ? document : null;
            const mouseEvents = {
              moveHandler: (e22) => onMove(e22.clientX),
              upHandler: (e22) => {
                contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
                contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
                onEnd(e22.clientX);
              }
            };
            const touchEvents = {
              moveHandler: (e22) => {
                if (e22.cancelable) {
                  e22.preventDefault();
                  e22.stopPropagation();
                }
                onMove(e22.touches[0].clientX);
                return false;
              },
              upHandler: (e22) => {
                var _e$touches$;
                contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
                contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
                if (e22.cancelable) {
                  e22.preventDefault();
                  e22.stopPropagation();
                }
                onEnd((_e$touches$ = e22.touches[0]) == null ? void 0 : _e$touches$.clientX);
              }
            };
            const passiveIfSupported = passiveEventSupported() ? {
              passive: false
            } : false;
            if (isTouchStartEvent(e2)) {
              contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
              contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
            } else {
              contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
              contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
            }
            table.setColumnSizingInfo((old) => ({
              ...old,
              startOffset: clientX,
              startSize,
              deltaOffset: 0,
              deltaPercentage: 0,
              columnSizingStart,
              isResizingColumn: column.id
            }));
          };
        };
      },
      createTable: (table) => {
        table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
        table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
        table.resetColumnSizing = (defaultState) => {
          var _table$initialState$c;
          table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
        };
        table.resetHeaderSizeInfo = (defaultState) => {
          var _table$initialState$c2;
          table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
        };
        table.getTotalSize = () => {
          var _table$getHeaderGroup, _table$getHeaderGroup2;
          return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum22, header) => {
            return sum22 + header.getSize();
          }, 0)) != null ? _table$getHeaderGroup : 0;
        };
        table.getLeftTotalSize = () => {
          var _table$getLeftHeaderG, _table$getLeftHeaderG2;
          return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum22, header) => {
            return sum22 + header.getSize();
          }, 0)) != null ? _table$getLeftHeaderG : 0;
        };
        table.getCenterTotalSize = () => {
          var _table$getCenterHeade, _table$getCenterHeade2;
          return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum22, header) => {
            return sum22 + header.getSize();
          }, 0)) != null ? _table$getCenterHeade : 0;
        };
        table.getRightTotalSize = () => {
          var _table$getRightHeader, _table$getRightHeader2;
          return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum22, header) => {
            return sum22 + header.getSize();
          }, 0)) != null ? _table$getRightHeader : 0;
        };
      }
    };
    passiveSupported$1 = null;
    ColumnVisibility = {
      getInitialState: (state) => {
        return {
          columnVisibility: {},
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
        };
      },
      createColumn: (column, table) => {
        column.toggleVisibility = (value) => {
          if (column.getCanHide()) {
            table.setColumnVisibility((old) => ({
              ...old,
              [column.id]: value != null ? value : !column.getIsVisible()
            }));
          }
        };
        column.getIsVisible = () => {
          var _ref, _table$getState$colum;
          const childColumns = column.columns;
          return (_ref = childColumns.length ? childColumns.some((c2) => c2.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
        };
        column.getCanHide = () => {
          var _column$columnDef$ena, _table$options$enable;
          return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
        };
        column.getToggleVisibilityHandler = () => {
          return (e2) => {
            column.toggleVisibility == null || column.toggleVisibility(e2.target.checked);
          };
        };
      },
      createRow: (row, table) => {
        row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
          return cells.filter((cell) => cell.column.getIsVisible());
        }, getMemoOptions(table.options, "debugRows"));
        row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows"));
      },
      createTable: (table) => {
        const makeVisibleColumnsMethod = (key, getColumns) => {
          return memo(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns) => {
            return columns.filter((d2) => d2.getIsVisible == null ? void 0 : d2.getIsVisible());
          }, getMemoOptions(table.options, "debugColumns"));
        };
        table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
        table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
        table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
        table.resetColumnVisibility = (defaultState) => {
          var _table$initialState$c;
          table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
        };
        table.toggleAllColumnsVisible = (value) => {
          var _value;
          value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
          table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
            ...obj,
            [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
          }), {}));
        };
        table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
        table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
        table.getToggleAllColumnsVisibilityHandler = () => {
          return (e2) => {
            var _target;
            table.toggleAllColumnsVisible((_target = e2.target) == null ? void 0 : _target.checked);
          };
        };
      }
    };
    GlobalFaceting = {
      createTable: (table) => {
        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
        table.getGlobalFacetedRowModel = () => {
          if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
            return table.getPreFilteredRowModel();
          }
          return table._getGlobalFacetedRowModel();
        };
        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
        table.getGlobalFacetedUniqueValues = () => {
          if (!table._getGlobalFacetedUniqueValues) {
            return /* @__PURE__ */ new Map();
          }
          return table._getGlobalFacetedUniqueValues();
        };
        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
        table.getGlobalFacetedMinMaxValues = () => {
          if (!table._getGlobalFacetedMinMaxValues) {
            return;
          }
          return table._getGlobalFacetedMinMaxValues();
        };
      }
    };
    GlobalFiltering = {
      getInitialState: (state) => {
        return {
          globalFilter: void 0,
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onGlobalFilterChange: makeStateUpdater("globalFilter", table),
          globalFilterFn: "auto",
          getColumnCanGlobalFilter: (column) => {
            var _table$getCoreRowMode;
            const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
            return typeof value === "string" || typeof value === "number";
          }
        };
      },
      createColumn: (column, table) => {
        column.getCanGlobalFilter = () => {
          var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
          return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
        };
      },
      createTable: (table) => {
        table.getGlobalAutoFilterFn = () => {
          return filterFns.includesString;
        };
        table.getGlobalFilterFn = () => {
          var _table$options$filter, _table$options$filter2;
          const {
            globalFilterFn
          } = table.options;
          return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
        };
        table.setGlobalFilter = (updater) => {
          table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
        };
        table.resetGlobalFilter = (defaultState) => {
          table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
        };
      }
    };
    RowExpanding = {
      getInitialState: (state) => {
        return {
          expanded: {},
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onExpandedChange: makeStateUpdater("expanded", table),
          paginateExpandedRows: true
        };
      },
      createTable: (table) => {
        let registered = false;
        let queued = false;
        table._autoResetExpanded = () => {
          var _ref, _table$options$autoRe;
          if (!registered) {
            table._queue(() => {
              registered = true;
            });
            return;
          }
          if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
            if (queued)
              return;
            queued = true;
            table._queue(() => {
              table.resetExpanded();
              queued = false;
            });
          }
        };
        table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
        table.toggleAllRowsExpanded = (expanded) => {
          if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
            table.setExpanded(true);
          } else {
            table.setExpanded({});
          }
        };
        table.resetExpanded = (defaultState) => {
          var _table$initialState$e, _table$initialState;
          table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
        };
        table.getCanSomeRowsExpand = () => {
          return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
        };
        table.getToggleAllRowsExpandedHandler = () => {
          return (e2) => {
            e2.persist == null || e2.persist();
            table.toggleAllRowsExpanded();
          };
        };
        table.getIsSomeRowsExpanded = () => {
          const expanded = table.getState().expanded;
          return expanded === true || Object.values(expanded).some(Boolean);
        };
        table.getIsAllRowsExpanded = () => {
          const expanded = table.getState().expanded;
          if (typeof expanded === "boolean") {
            return expanded === true;
          }
          if (!Object.keys(expanded).length) {
            return false;
          }
          if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
            return false;
          }
          return true;
        };
        table.getExpandedDepth = () => {
          let maxDepth = 0;
          const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
          rowIds.forEach((id3) => {
            const splitId = id3.split(".");
            maxDepth = Math.max(maxDepth, splitId.length);
          });
          return maxDepth;
        };
        table.getPreExpandedRowModel = () => table.getSortedRowModel();
        table.getExpandedRowModel = () => {
          if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
            table._getExpandedRowModel = table.options.getExpandedRowModel(table);
          }
          if (table.options.manualExpanding || !table._getExpandedRowModel) {
            return table.getPreExpandedRowModel();
          }
          return table._getExpandedRowModel();
        };
      },
      createRow: (row, table) => {
        row.toggleExpanded = (expanded) => {
          table.setExpanded((old) => {
            var _expanded;
            const exists2 = old === true ? true : !!(old != null && old[row.id]);
            let oldExpanded = {};
            if (old === true) {
              Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
                oldExpanded[rowId] = true;
              });
            } else {
              oldExpanded = old;
            }
            expanded = (_expanded = expanded) != null ? _expanded : !exists2;
            if (!exists2 && expanded) {
              return {
                ...oldExpanded,
                [row.id]: true
              };
            }
            if (exists2 && !expanded) {
              const {
                [row.id]: _3,
                ...rest
              } = oldExpanded;
              return rest;
            }
            return old;
          });
        };
        row.getIsExpanded = () => {
          var _table$options$getIsR;
          const expanded = table.getState().expanded;
          return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
        };
        row.getCanExpand = () => {
          var _table$options$getRow, _table$options$enable, _row$subRows;
          return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
        };
        row.getIsAllParentsExpanded = () => {
          let isFullyExpanded = true;
          let currentRow = row;
          while (isFullyExpanded && currentRow.parentId) {
            currentRow = table.getRow(currentRow.parentId, true);
            isFullyExpanded = currentRow.getIsExpanded();
          }
          return isFullyExpanded;
        };
        row.getToggleExpandedHandler = () => {
          const canExpand = row.getCanExpand();
          return () => {
            if (!canExpand)
              return;
            row.toggleExpanded();
          };
        };
      }
    };
    defaultPageIndex = 0;
    defaultPageSize = 10;
    getDefaultPaginationState = () => ({
      pageIndex: defaultPageIndex,
      pageSize: defaultPageSize
    });
    RowPagination = {
      getInitialState: (state) => {
        return {
          ...state,
          pagination: {
            ...getDefaultPaginationState(),
            ...state == null ? void 0 : state.pagination
          }
        };
      },
      getDefaultOptions: (table) => {
        return {
          onPaginationChange: makeStateUpdater("pagination", table)
        };
      },
      createTable: (table) => {
        let registered = false;
        let queued = false;
        table._autoResetPageIndex = () => {
          var _ref, _table$options$autoRe;
          if (!registered) {
            table._queue(() => {
              registered = true;
            });
            return;
          }
          if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
            if (queued)
              return;
            queued = true;
            table._queue(() => {
              table.resetPageIndex();
              queued = false;
            });
          }
        };
        table.setPagination = (updater) => {
          const safeUpdater = (old) => {
            let newState = functionalUpdate(updater, old);
            return newState;
          };
          return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
        };
        table.resetPagination = (defaultState) => {
          var _table$initialState$p;
          table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
        };
        table.setPageIndex = (updater) => {
          table.setPagination((old) => {
            let pageIndex = functionalUpdate(updater, old.pageIndex);
            const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
            pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
            return {
              ...old,
              pageIndex
            };
          });
        };
        table.resetPageIndex = (defaultState) => {
          var _table$initialState$p2, _table$initialState;
          table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
        };
        table.resetPageSize = (defaultState) => {
          var _table$initialState$p3, _table$initialState2;
          table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
        };
        table.setPageSize = (updater) => {
          table.setPagination((old) => {
            const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
            const topRowIndex = old.pageSize * old.pageIndex;
            const pageIndex = Math.floor(topRowIndex / pageSize);
            return {
              ...old,
              pageIndex,
              pageSize
            };
          });
        };
        table.setPageCount = (updater) => table.setPagination((old) => {
          var _table$options$pageCo;
          let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
          if (typeof newPageCount === "number") {
            newPageCount = Math.max(-1, newPageCount);
          }
          return {
            ...old,
            pageCount: newPageCount
          };
        });
        table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
          let pageOptions = [];
          if (pageCount && pageCount > 0) {
            pageOptions = [...new Array(pageCount)].fill(null).map((_3, i2) => i2);
          }
          return pageOptions;
        }, getMemoOptions(table.options, "debugTable"));
        table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
        table.getCanNextPage = () => {
          const {
            pageIndex
          } = table.getState().pagination;
          const pageCount = table.getPageCount();
          if (pageCount === -1) {
            return true;
          }
          if (pageCount === 0) {
            return false;
          }
          return pageIndex < pageCount - 1;
        };
        table.previousPage = () => {
          return table.setPageIndex((old) => old - 1);
        };
        table.nextPage = () => {
          return table.setPageIndex((old) => {
            return old + 1;
          });
        };
        table.firstPage = () => {
          return table.setPageIndex(0);
        };
        table.lastPage = () => {
          return table.setPageIndex(table.getPageCount() - 1);
        };
        table.getPrePaginationRowModel = () => table.getExpandedRowModel();
        table.getPaginationRowModel = () => {
          if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
            table._getPaginationRowModel = table.options.getPaginationRowModel(table);
          }
          if (table.options.manualPagination || !table._getPaginationRowModel) {
            return table.getPrePaginationRowModel();
          }
          return table._getPaginationRowModel();
        };
        table.getPageCount = () => {
          var _table$options$pageCo2;
          return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
        };
        table.getRowCount = () => {
          var _table$options$rowCou;
          return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
        };
      }
    };
    getDefaultRowPinningState = () => ({
      top: [],
      bottom: []
    });
    RowPinning = {
      getInitialState: (state) => {
        return {
          rowPinning: getDefaultRowPinningState(),
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onRowPinningChange: makeStateUpdater("rowPinning", table)
        };
      },
      createRow: (row, table) => {
        row.pin = (position, includeLeafRows, includeParentRows) => {
          const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
            let {
              id: id3
            } = _ref;
            return id3;
          }) : [];
          const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
            let {
              id: id3
            } = _ref2;
            return id3;
          }) : [];
          const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
          table.setRowPinning((old) => {
            var _old$top3, _old$bottom3;
            if (position === "bottom") {
              var _old$top, _old$bottom;
              return {
                top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
                bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)]
              };
            }
            if (position === "top") {
              var _old$top2, _old$bottom2;
              return {
                top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)],
                bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
              };
            }
            return {
              top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
              bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
            };
          });
        };
        row.getCanPin = () => {
          var _ref3;
          const {
            enableRowPinning,
            enablePinning
          } = table.options;
          if (typeof enableRowPinning === "function") {
            return enableRowPinning(row);
          }
          return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
        };
        row.getIsPinned = () => {
          const rowIds = [row.id];
          const {
            top,
            bottom
          } = table.getState().rowPinning;
          const isTop = rowIds.some((d2) => top == null ? void 0 : top.includes(d2));
          const isBottom = rowIds.some((d2) => bottom == null ? void 0 : bottom.includes(d2));
          return isTop ? "top" : isBottom ? "bottom" : false;
        };
        row.getPinnedIndex = () => {
          var _table$_getPinnedRows, _visiblePinnedRowIds$;
          const position = row.getIsPinned();
          if (!position)
            return -1;
          const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref4) => {
            let {
              id: id3
            } = _ref4;
            return id3;
          });
          return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
        };
      },
      createTable: (table) => {
        table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
        table.resetRowPinning = (defaultState) => {
          var _table$initialState$r, _table$initialState;
          return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
        };
        table.getIsSomeRowsPinned = (position) => {
          var _pinningState$positio;
          const pinningState = table.getState().rowPinning;
          if (!position) {
            var _pinningState$top, _pinningState$bottom;
            return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
          }
          return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
        };
        table._getPinnedRows = memo((position) => [table.getRowModel().rows, table.getState().rowPinning[position], position], (visibleRows, pinnedRowIds, position) => {
          var _table$options$keepPi;
          const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
            //get all rows that are pinned even if they would not be otherwise visible
            //account for expanded parent rows, but not pagination or filtering
            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
              const row = table.getRow(rowId, true);
              return row.getIsAllParentsExpanded() ? row : null;
            })
          ) : (
            //else get only visible rows that are pinned
            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
          );
          return rows.filter(Boolean).map((d2) => ({
            ...d2,
            position
          }));
        }, getMemoOptions(table.options, "debugRows"));
        table.getTopRows = () => table._getPinnedRows("top");
        table.getBottomRows = () => table._getPinnedRows("bottom");
        table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
          const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
          return allRows.filter((d2) => !topAndBottom.has(d2.id));
        }, getMemoOptions(table.options, "debugRows"));
      }
    };
    RowSelection = {
      getInitialState: (state) => {
        return {
          rowSelection: {},
          ...state
        };
      },
      getDefaultOptions: (table) => {
        return {
          onRowSelectionChange: makeStateUpdater("rowSelection", table),
          enableRowSelection: true,
          enableMultiRowSelection: true,
          enableSubRowSelection: true
          // enableGroupingRowSelection: false,
          // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
          // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
        };
      },
      createTable: (table) => {
        table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
        table.resetRowSelection = (defaultState) => {
          var _table$initialState$r;
          return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
        };
        table.toggleAllRowsSelected = (value) => {
          table.setRowSelection((old) => {
            value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
            const rowSelection = {
              ...old
            };
            const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
            if (value) {
              preGroupedFlatRows.forEach((row) => {
                if (!row.getCanSelect()) {
                  return;
                }
                rowSelection[row.id] = true;
              });
            } else {
              preGroupedFlatRows.forEach((row) => {
                delete rowSelection[row.id];
              });
            }
            return rowSelection;
          });
        };
        table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
          const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
          const rowSelection = {
            ...old
          };
          table.getRowModel().rows.forEach((row) => {
            mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
          });
          return rowSelection;
        });
        table.getPreSelectedRowModel = () => table.getCoreRowModel();
        table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
          if (!Object.keys(rowSelection).length) {
            return {
              rows: [],
              flatRows: [],
              rowsById: {}
            };
          }
          return selectRowsFn(table, rowModel);
        }, getMemoOptions(table.options, "debugTable"));
        table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
          if (!Object.keys(rowSelection).length) {
            return {
              rows: [],
              flatRows: [],
              rowsById: {}
            };
          }
          return selectRowsFn(table, rowModel);
        }, getMemoOptions(table.options, "debugTable"));
        table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
          if (!Object.keys(rowSelection).length) {
            return {
              rows: [],
              flatRows: [],
              rowsById: {}
            };
          }
          return selectRowsFn(table, rowModel);
        }, getMemoOptions(table.options, "debugTable"));
        table.getIsAllRowsSelected = () => {
          const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
          const {
            rowSelection
          } = table.getState();
          let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
          if (isAllRowsSelected) {
            if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
              isAllRowsSelected = false;
            }
          }
          return isAllRowsSelected;
        };
        table.getIsAllPageRowsSelected = () => {
          const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
          const {
            rowSelection
          } = table.getState();
          let isAllPageRowsSelected = !!paginationFlatRows.length;
          if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
            isAllPageRowsSelected = false;
          }
          return isAllPageRowsSelected;
        };
        table.getIsSomeRowsSelected = () => {
          var _table$getState$rowSe;
          const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
          return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
        };
        table.getIsSomePageRowsSelected = () => {
          const paginationFlatRows = table.getPaginationRowModel().flatRows;
          return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
        };
        table.getToggleAllRowsSelectedHandler = () => {
          return (e2) => {
            table.toggleAllRowsSelected(e2.target.checked);
          };
        };
        table.getToggleAllPageRowsSelectedHandler = () => {
          return (e2) => {
            table.toggleAllPageRowsSelected(e2.target.checked);
          };
        };
      },
      createRow: (row, table) => {
        row.toggleSelected = (value, opts2) => {
          const isSelected = row.getIsSelected();
          table.setRowSelection((old) => {
            var _opts$selectChildren;
            value = typeof value !== "undefined" ? value : !isSelected;
            if (row.getCanSelect() && isSelected === value) {
              return old;
            }
            const selectedRowIds = {
              ...old
            };
            mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts2 == null ? void 0 : opts2.selectChildren) != null ? _opts$selectChildren : true, table);
            return selectedRowIds;
          });
        };
        row.getIsSelected = () => {
          const {
            rowSelection
          } = table.getState();
          return isRowSelected(row, rowSelection);
        };
        row.getIsSomeSelected = () => {
          const {
            rowSelection
          } = table.getState();
          return isSubRowSelected(row, rowSelection) === "some";
        };
        row.getIsAllSubRowsSelected = () => {
          const {
            rowSelection
          } = table.getState();
          return isSubRowSelected(row, rowSelection) === "all";
        };
        row.getCanSelect = () => {
          var _table$options$enable;
          if (typeof table.options.enableRowSelection === "function") {
            return table.options.enableRowSelection(row);
          }
          return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
        };
        row.getCanSelectSubRows = () => {
          var _table$options$enable2;
          if (typeof table.options.enableSubRowSelection === "function") {
            return table.options.enableSubRowSelection(row);
          }
          return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
        };
        row.getCanMultiSelect = () => {
          var _table$options$enable3;
          if (typeof table.options.enableMultiRowSelection === "function") {
            return table.options.enableMultiRowSelection(row);
          }
          return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
        };
        row.getToggleSelectedHandler = () => {
          const canSelect = row.getCanSelect();
          return (e2) => {
            var _target;
            if (!canSelect)
              return;
            row.toggleSelected((_target = e2.target) == null ? void 0 : _target.checked);
          };
        };
      }
    };
    mutateRowIsSelected = (selectedRowIds, id3, value, includeChildren, table) => {
      var _row$subRows;
      const row = table.getRow(id3, true);
      if (value) {
        if (!row.getCanMultiSelect()) {
          Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
        }
        if (row.getCanSelect()) {
          selectedRowIds[id3] = true;
        }
      } else {
        delete selectedRowIds[id3];
      }
      if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
        row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
      }
    };
    reSplitAlphaNumeric = /([0-9]+)/gm;
    alphanumeric = (rowA, rowB, columnId) => {
      return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
    };
    alphanumericCaseSensitive = (rowA, rowB, columnId) => {
      return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
    };
    text2 = (rowA, rowB, columnId) => {
      return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
    };
    textCaseSensitive = (rowA, rowB, columnId) => {
      return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
    };
    datetime = (rowA, rowB, columnId) => {
      const a2 = rowA.getValue(columnId);
      const b2 = rowB.getValue(columnId);
      return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
    };
    basic = (rowA, rowB, columnId) => {
      return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
    };
    sortingFns = {
      alphanumeric,
      alphanumericCaseSensitive,
      text: text2,
      textCaseSensitive,
      datetime,
      basic
    };
    RowSorting = {
      getInitialState: (state) => {
        return {
          sorting: [],
          ...state
        };
      },
      getDefaultColumnDef: () => {
        return {
          sortingFn: "auto",
          sortUndefined: 1
        };
      },
      getDefaultOptions: (table) => {
        return {
          onSortingChange: makeStateUpdater("sorting", table),
          isMultiSortEvent: (e2) => {
            return e2.shiftKey;
          }
        };
      },
      createColumn: (column, table) => {
        column.getAutoSortingFn = () => {
          const firstRows = table.getFilteredRowModel().flatRows.slice(10);
          let isString3 = false;
          for (const row of firstRows) {
            const value = row == null ? void 0 : row.getValue(column.id);
            if (Object.prototype.toString.call(value) === "[object Date]") {
              return sortingFns.datetime;
            }
            if (typeof value === "string") {
              isString3 = true;
              if (value.split(reSplitAlphaNumeric).length > 1) {
                return sortingFns.alphanumeric;
              }
            }
          }
          if (isString3) {
            return sortingFns.text;
          }
          return sortingFns.basic;
        };
        column.getAutoSortDir = () => {
          const firstRow = table.getFilteredRowModel().flatRows[0];
          const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
          if (typeof value === "string") {
            return "asc";
          }
          return "desc";
        };
        column.getSortingFn = () => {
          var _table$options$sortin, _table$options$sortin2;
          if (!column) {
            throw new Error();
          }
          return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
        };
        column.toggleSorting = (desc2, multi) => {
          const nextSortingOrder = column.getNextSortingOrder();
          const hasManualValue = typeof desc2 !== "undefined" && desc2 !== null;
          table.setSorting((old) => {
            const existingSorting = old == null ? void 0 : old.find((d2) => d2.id === column.id);
            const existingIndex = old == null ? void 0 : old.findIndex((d2) => d2.id === column.id);
            let newSorting = [];
            let sortAction;
            let nextDesc = hasManualValue ? desc2 : nextSortingOrder === "desc";
            if (old != null && old.length && column.getCanMultiSort() && multi) {
              if (existingSorting) {
                sortAction = "toggle";
              } else {
                sortAction = "add";
              }
            } else {
              if (old != null && old.length && existingIndex !== old.length - 1) {
                sortAction = "replace";
              } else if (existingSorting) {
                sortAction = "toggle";
              } else {
                sortAction = "replace";
              }
            }
            if (sortAction === "toggle") {
              if (!hasManualValue) {
                if (!nextSortingOrder) {
                  sortAction = "remove";
                }
              }
            }
            if (sortAction === "add") {
              var _table$options$maxMul;
              newSorting = [...old, {
                id: column.id,
                desc: nextDesc
              }];
              newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
            } else if (sortAction === "toggle") {
              newSorting = old.map((d2) => {
                if (d2.id === column.id) {
                  return {
                    ...d2,
                    desc: nextDesc
                  };
                }
                return d2;
              });
            } else if (sortAction === "remove") {
              newSorting = old.filter((d2) => d2.id !== column.id);
            } else {
              newSorting = [{
                id: column.id,
                desc: nextDesc
              }];
            }
            return newSorting;
          });
        };
        column.getFirstSortDir = () => {
          var _ref, _column$columnDef$sor;
          const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
          return sortDescFirst ? "desc" : "asc";
        };
        column.getNextSortingOrder = (multi) => {
          var _table$options$enable, _table$options$enable2;
          const firstSortDirection = column.getFirstSortDir();
          const isSorted = column.getIsSorted();
          if (!isSorted) {
            return firstSortDirection;
          }
          if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
          (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
            return false;
          }
          return isSorted === "desc" ? "asc" : "desc";
        };
        column.getCanSort = () => {
          var _column$columnDef$ena, _table$options$enable3;
          return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
        };
        column.getCanMultiSort = () => {
          var _ref2, _column$columnDef$ena2;
          return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
        };
        column.getIsSorted = () => {
          var _table$getState$sorti;
          const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d2) => d2.id === column.id);
          return !columnSort ? false : columnSort.desc ? "desc" : "asc";
        };
        column.getSortIndex = () => {
          var _table$getState$sorti2, _table$getState$sorti3;
          return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$sorti2 : -1;
        };
        column.clearSorting = () => {
          table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
        };
        column.getToggleSortingHandler = () => {
          const canSort = column.getCanSort();
          return (e2) => {
            if (!canSort)
              return;
            e2.persist == null || e2.persist();
            column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e2) : false);
          };
        };
      },
      createTable: (table) => {
        table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
        table.resetSorting = (defaultState) => {
          var _table$initialState$s, _table$initialState;
          table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
        };
        table.getPreSortedRowModel = () => table.getGroupedRowModel();
        table.getSortedRowModel = () => {
          if (!table._getSortedRowModel && table.options.getSortedRowModel) {
            table._getSortedRowModel = table.options.getSortedRowModel(table);
          }
          if (table.options.manualSorting || !table._getSortedRowModel) {
            return table.getPreSortedRowModel();
          }
          return table._getSortedRowModel();
        };
      }
    };
    builtInFeatures = [
      Headers2,
      ColumnVisibility,
      ColumnOrdering,
      ColumnPinning,
      ColumnFaceting,
      ColumnFiltering,
      GlobalFaceting,
      //depends on ColumnFaceting
      GlobalFiltering,
      //depends on ColumnFiltering
      RowSorting,
      ColumnGrouping,
      //depends on RowSorting
      RowExpanding,
      RowPagination,
      RowPinning,
      RowSelection,
      ColumnSizing
    ];
    $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      const childrenArray = reactExports.Children.toArray(children);
      const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child) => {
          if (child === slottable) {
            if (reactExports.Children.count(newElement) > 1)
              return reactExports.Children.only(null);
            return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
          } else
            return child;
        });
        return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
          ref: forwardedRef
        }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
      }
      return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
        ref: forwardedRef
      }), children);
    });
    $5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
    $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      if (/* @__PURE__ */ reactExports.isValidElement(children))
        return /* @__PURE__ */ reactExports.cloneElement(children, {
          ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
          ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
        });
      return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
    });
    $5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
    $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
    };
    $8927f6f2acc4f386$var$NODES = [
      "a",
      "button",
      "div",
      "form",
      "h2",
      "h3",
      "img",
      "input",
      "label",
      "li",
      "nav",
      "ol",
      "p",
      "span",
      "svg",
      "ul"
    ];
    $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
      const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
        reactExports.useEffect(() => {
          window[Symbol.for("radix-ui")] = true;
        }, []);
        return /* @__PURE__ */ reactExports.createElement(Comp, _extends({}, primitiveProps, {
          ref: forwardedRef
        }));
      });
      Node2.displayName = `Primitive.${node}`;
      return {
        ...primitive,
        [node]: Node2
      };
    }, {});
    $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ reactExports.createContext(void 0);
    $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
    $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
    $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
    $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ reactExports.createContext({
      layers: /* @__PURE__ */ new Set(),
      layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
      branches: /* @__PURE__ */ new Set()
    });
    $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      var _node$ownerDocument;
      const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
      const context = reactExports.useContext($5cb92bef7577960e$var$DismissableLayerContext);
      const [node1, setNode] = reactExports.useState(null);
      const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
      const [, force] = reactExports.useState({});
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setNode(node)
      );
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [
        ...context.layersWithOutsidePointerEventsDisabled
      ].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index3 = node1 ? layers.indexOf(node1) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index3 >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [
          ...context.branches
        ].some(
          (branch) => branch.contains(target)
        );
        if (!isPointerEventsEnabled || isPointerDownOnBranch)
          return;
        onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
        onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
        if (!event.defaultPrevented)
          onDismiss === null || onDismiss === void 0 || onDismiss();
      }, ownerDocument);
      const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [
          ...context.branches
        ].some(
          (branch) => branch.contains(target)
        );
        if (isFocusInBranch)
          return;
        onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
        onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
        if (!event.defaultPrevented)
          onDismiss === null || onDismiss === void 0 || onDismiss();
      }, ownerDocument);
      $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
        const isHighestLayer = index3 === context.layers.size - 1;
        if (!isHighestLayer)
          return;
        onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument);
      reactExports.useEffect(() => {
        if (!node1)
          return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
            ownerDocument.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node1);
        }
        context.layers.add(node1);
        $5cb92bef7577960e$var$dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
            ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
        };
      }, [
        node1,
        ownerDocument,
        disableOutsidePointerEvents,
        context
      ]);
      reactExports.useEffect(() => {
        return () => {
          if (!node1)
            return;
          context.layers.delete(node1);
          context.layersWithOutsidePointerEventsDisabled.delete(node1);
          $5cb92bef7577960e$var$dispatchUpdate();
        };
      }, [
        node1,
        context
      ]);
      reactExports.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
      }));
    });
    $3db38b7d1fb3fe6a$var$count = 0;
    $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
    $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
    $d3863c46a17e8a28$var$EVENT_OPTIONS = {
      bubbles: false,
      cancelable: true
    };
    $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
      const [container1, setContainer] = reactExports.useState(null);
      const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
      const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
      const lastFocusedElementRef = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setContainer(node)
      );
      const focusScope = reactExports.useRef({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      }).current;
      reactExports.useEffect(() => {
        if (trapped) {
          let handleFocusIn2 = function(event) {
            if (focusScope.paused || !container1)
              return;
            const target = event.target;
            if (container1.contains(target))
              lastFocusedElementRef.current = target;
            else
              $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
                select: true
              });
          }, handleFocusOut2 = function(event) {
            if (focusScope.paused || !container1)
              return;
            const relatedTarget = event.relatedTarget;
            if (relatedTarget === null)
              return;
            if (!container1.contains(relatedTarget))
              $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
                select: true
              });
          }, handleMutations2 = function(mutations) {
            const focusedElement = document.activeElement;
            if (focusedElement !== document.body)
              return;
            for (const mutation of mutations)
              if (mutation.removedNodes.length > 0)
                $d3863c46a17e8a28$var$focus(container1);
          };
          var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
          document.addEventListener("focusin", handleFocusIn2);
          document.addEventListener("focusout", handleFocusOut2);
          const mutationObserver = new MutationObserver(handleMutations2);
          if (container1)
            mutationObserver.observe(container1, {
              childList: true,
              subtree: true
            });
          return () => {
            document.removeEventListener("focusin", handleFocusIn2);
            document.removeEventListener("focusout", handleFocusOut2);
            mutationObserver.disconnect();
          };
        }
      }, [
        trapped,
        container1,
        focusScope.paused
      ]);
      reactExports.useEffect(() => {
        if (container1) {
          $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
          const previouslyFocusedElement = document.activeElement;
          const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
          if (!hasFocusedCandidate) {
            const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
            container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
            container1.dispatchEvent(mountEvent);
            if (!mountEvent.defaultPrevented) {
              $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
                select: true
              });
              if (document.activeElement === previouslyFocusedElement)
                $d3863c46a17e8a28$var$focus(container1);
            }
          }
          return () => {
            container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
            setTimeout(() => {
              const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
              container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
              container1.dispatchEvent(unmountEvent);
              if (!unmountEvent.defaultPrevented)
                $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                  select: true
                });
              container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
              $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
            }, 0);
          };
        }
      }, [
        container1,
        onMountAutoFocus,
        onUnmountAutoFocus,
        focusScope
      ]);
      const handleKeyDown = reactExports.useCallback((event) => {
        if (!loop && !trapped)
          return;
        if (focusScope.paused)
          return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container = event.currentTarget;
          const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container)
              event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop)
                $d3863c46a17e8a28$var$focus(first, {
                  select: true
                });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop)
                $d3863c46a17e8a28$var$focus(last, {
                  select: true
                });
            }
          }
        }
      }, [
        loop,
        trapped,
        focusScope.paused
      ]);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        tabIndex: -1
      }, scopeProps, {
        ref: composedRefs,
        onKeyDown: handleKeyDown
      }));
    });
    $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
    $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
    };
    $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
    $1746a345f3d73bb7$var$count = 0;
    sides = ["top", "right", "bottom", "left"];
    min$1 = Math.min;
    max$1 = Math.max;
    round = Math.round;
    floor = Math.floor;
    createCoords = (v4) => ({
      x: v4,
      y: v4
    });
    oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    computePosition$1 = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x4,
        y: y3
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name,
          fn: fn2
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn2({
          x: x4,
          y: y3,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x4 = nextX != null ? nextX : x4;
        y3 = nextY != null ? nextY : y3;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x: x4,
              y: y3
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
        }
      }
      return {
        x: x4,
        y: y3,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    arrow$2 = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x4,
          y: y3,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x4,
          y: y3
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
        const min$1$1 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$1$1, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    flip$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    hide$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "hide",
        options,
        async fn(state) {
          const {
            rects
          } = state;
          const {
            strategy = "referenceHidden",
            ...detectOverflowOptions
          } = evaluate(options, state);
          switch (strategy) {
            case "referenceHidden": {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                elementContext: "reference"
              });
              const offsets = getSideOffsets(overflow, rects.reference);
              return {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets)
                }
              };
            }
            case "escaped": {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                altBoundary: true
              });
              const offsets = getSideOffsets(overflow, rects.floating);
              return {
                data: {
                  escapedOffsets: offsets,
                  escaped: isAnySideFullyClipped(offsets)
                }
              };
            }
            default: {
              return {};
            }
          }
        }
      };
    };
    offset = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x4,
            y: y3,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x4 + diffCoords.x,
            y: y3 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    shift$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x4,
            y: y3,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x5,
                  y: y4
                } = _ref;
                return {
                  x: x5,
                  y: y4
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x: x4,
            y: y3
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x4,
              y: limitedCoords.y - y3
            }
          };
        }
      };
    };
    limitShift$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        options,
        fn(state) {
          const {
            x: x4,
            y: y3,
            placement,
            rects,
            middlewareData
          } = state;
          const {
            offset: offset2 = 0,
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true
          } = evaluate(options, state);
          const coords = {
            x: x4,
            y: y3
          };
          const crossAxis = getSideAxis(placement);
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          const rawOffset = evaluate(offset2, state);
          const computedOffset = typeof rawOffset === "number" ? {
            mainAxis: rawOffset,
            crossAxis: 0
          } : {
            mainAxis: 0,
            crossAxis: 0,
            ...rawOffset
          };
          if (checkMainAxis) {
            const len = mainAxis === "y" ? "height" : "width";
            const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
            const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
            if (mainAxisCoord < limitMin) {
              mainAxisCoord = limitMin;
            } else if (mainAxisCoord > limitMax) {
              mainAxisCoord = limitMax;
            }
          }
          if (checkCrossAxis) {
            var _middlewareData$offse, _middlewareData$offse2;
            const len = mainAxis === "y" ? "width" : "height";
            const isOriginSide = ["top", "left"].includes(getSide(placement));
            const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
            const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
            if (crossAxisCoord < limitMin) {
              crossAxisCoord = limitMin;
            } else if (crossAxisCoord > limitMax) {
              crossAxisCoord = limitMax;
            }
          }
          return {
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          };
        }
      };
    };
    size$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max$1(overflow.left, 0);
            const xMax = max$1(overflow.right, 0);
            const yMin = max$1(overflow.top, 0);
            const yMax = max$1(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
    noOffsets = /* @__PURE__ */ createCoords(0);
    topLayerSelectors = [":popover-open", ":modal"];
    getElementRects = async function(data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          ...await getDimensionsFn(data.floating)
        }
      };
    };
    platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement,
      isRTL
    };
    shift = shift$1;
    flip = flip$1;
    size = size$1;
    hide = hide$1;
    arrow$1 = arrow$2;
    limitShift = limitShift$1;
    computePosition = (reference, floating, options) => {
      const cache = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
    arrow = (options) => {
      function isRef(value) {
        return {}.hasOwnProperty.call(value, "current");
      }
      return {
        name: "arrow",
        options,
        fn(state) {
          const {
            element,
            padding
          } = typeof options === "function" ? options(state) : options;
          if (element && isRef(element)) {
            if (element.current != null) {
              return arrow$1({
                element: element.current,
                padding
              }).fn(state);
            }
            return {};
          }
          if (element) {
            return arrow$1({
              element,
              padding
            }).fn(state);
          }
          return {};
        }
      };
    };
    index2 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
    [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
    [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
    $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
      const { __scopePopper, children } = props;
      const [anchor, setAnchor] = reactExports.useState(null);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperProvider, {
        scope: __scopePopper,
        anchor,
        onAnchorChange: setAnchor
      }, children);
    };
    $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
    $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopePopper, virtualRef, ...anchorProps } = props;
      const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      reactExports.useEffect(() => {
        context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
      });
      return virtualRef ? null : /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
        ref: composedRefs
      }));
    });
    $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
    [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
    $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
      const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, avoidCollisions = true, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, updatePositionStrategy = "optimized", onPlaced, ...contentProps } = props;
      const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
      const [content, setContent] = reactExports.useState(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setContent(node)
      );
      const [arrow$12, setArrow] = reactExports.useState(null);
      const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow$12);
      const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
      const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
      const desiredPlacement = side + (align !== "center" ? "-" + align : "");
      const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...collisionPaddingProp
      };
      const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
        collisionBoundary
      ];
      const hasExplicitBoundaries = boundary.length > 0;
      const detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: hasExplicitBoundaries
      };
      const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            animationFrame: updatePositionStrategy === "always"
          });
          return cleanup;
        },
        elements: {
          reference: context.anchor
        },
        middleware: [
          offset({
            mainAxis: sideOffset + arrowHeight,
            alignmentAxis: alignOffset
          }),
          avoidCollisions && shift({
            mainAxis: true,
            crossAxis: false,
            limiter: sticky === "partial" ? limitShift() : void 0,
            ...detectOverflowOptions
          }),
          avoidCollisions && flip({
            ...detectOverflowOptions
          }),
          size({
            ...detectOverflowOptions,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              const { width: anchorWidth, height: anchorHeight } = rects.reference;
              const contentStyle = elements.floating.style;
              contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
              contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
              contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
              contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
            }
          }),
          arrow$12 && arrow({
            element: arrow$12,
            padding: arrowPadding
          }),
          $cf1ac5d9fe0e8206$var$transformOrigin({
            arrowWidth,
            arrowHeight
          }),
          hideWhenDetached && hide({
            strategy: "referenceHidden",
            ...detectOverflowOptions
          })
        ]
      });
      const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
      const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        if (isPositioned)
          handlePlaced === null || handlePlaced === void 0 || handlePlaced();
      }, [
        isPositioned,
        handlePlaced
      ]);
      const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
      const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
      const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
      const [contentZIndex, setContentZIndex] = reactExports.useState();
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        if (content)
          setContentZIndex(window.getComputedStyle(content).zIndex);
      }, [
        content
      ]);
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
            (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
          ].join(" ")
        },
        dir: props.dir
      }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperContentProvider, {
        scope: __scopePopper,
        placedSide,
        onArrowChange: setArrow,
        arrowX,
        arrowY,
        shouldHideArrow: cannotCenterArrow
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-side": placedSide,
        "data-align": placedAlign
      }, contentProps, {
        ref: composedRefs,
        style: {
          ...contentProps.style,
          // if the PopperContent hasn't been placed yet (not all measurements done)
          // we prevent animations so that users's animation don't kick in too early referring wrong sides
          animation: !isPositioned ? "none" : void 0,
          // hide the content if using the hide middleware and should be hidden
          opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
        }
      }))));
    });
    $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
      name: "transformOrigin",
      options,
      fn(data) {
        var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
        const { placement, rects, middlewareData } = data;
        const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
        const isArrowHidden = cannotCenterArrow;
        const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
        const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
        const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
        const noArrowAlign = {
          start: "0%",
          center: "50%",
          end: "100%"
        }[placedAlign];
        const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
        const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
        let x4 = "";
        let y3 = "";
        if (placedSide === "bottom") {
          x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y3 = `${-arrowHeight}px`;
        } else if (placedSide === "top") {
          x4 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y3 = `${rects.floating.height + arrowHeight}px`;
        } else if (placedSide === "right") {
          x4 = `${-arrowHeight}px`;
          y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        } else if (placedSide === "left") {
          x4 = `${rects.floating.width + arrowHeight}px`;
          y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        }
        return {
          data: {
            x: x4,
            y: y3
          }
        };
      }
    });
    $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
    $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
    $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
    $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      var _globalThis$document;
      const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
      return container ? /* @__PURE__ */ _n.createPortal(/* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
        ref: forwardedRef
      })), container) : null;
    });
    $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
      const { present, children } = props;
      const presence = $921a889cee6df7e8$var$usePresence(present);
      const child = typeof children === "function" ? children({
        present: presence.isPresent
      }) : reactExports.Children.only(children);
      const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
      const forceMount = typeof children === "function";
      return forceMount || presence.isPresent ? /* @__PURE__ */ reactExports.cloneElement(child, {
        ref
      }) : null;
    };
    $921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
    $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
    $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
      bubbles: false,
      cancelable: true
    };
    $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
    [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
    [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
      $d7bdfb9eb0fdf311$var$createCollectionScope
    ]);
    [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
    $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {
        scope: props.__scopeRovingFocusGroup
      }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {
        scope: props.__scopeRovingFocusGroup
      }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
        ref: forwardedRef
      }))));
    });
    $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
      const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: currentTabStopIdProp,
        defaultProp: defaultCurrentTabStopId,
        onChange: onCurrentTabStopIdChange
      });
      const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
      const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
      const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
      const isClickFocusRef = reactExports.useRef(false);
      const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
      reactExports.useEffect(() => {
        const node = ref.current;
        if (node) {
          node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
          return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
        }
      }, [
        handleEntryFocus
      ]);
      return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
        scope: __scopeRovingFocusGroup,
        orientation,
        dir: direction,
        loop,
        currentTabStopId,
        onItemFocus: reactExports.useCallback(
          (tabStopId) => setCurrentTabStopId(tabStopId),
          [
            setCurrentTabStopId
          ]
        ),
        onItemShiftTab: reactExports.useCallback(
          () => setIsTabbingBackOut(true),
          []
        ),
        onFocusableItemAdd: reactExports.useCallback(
          () => setFocusableItemsCount(
            (prevCount) => prevCount + 1
          ),
          []
        ),
        onFocusableItemRemove: reactExports.useCallback(
          () => setFocusableItemsCount(
            (prevCount) => prevCount - 1
          ),
          []
        )
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
        "data-orientation": orientation
      }, groupProps, {
        ref: composedRefs,
        style: {
          outline: "none",
          ...props.style
        },
        onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
          isClickFocusRef.current = true;
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
          const isKeyboardFocus = !isClickFocusRef.current;
          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
            const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
            event.currentTarget.dispatchEvent(entryFocusEvent);
            if (!entryFocusEvent.defaultPrevented) {
              const items = getItems().filter(
                (item) => item.focusable
              );
              const activeItem = items.find(
                (item) => item.active
              );
              const currentItem = items.find(
                (item) => item.id === currentTabStopId
              );
              const candidateItems = [
                activeItem,
                currentItem,
                ...items
              ].filter(Boolean);
              const candidateNodes = candidateItems.map(
                (item) => item.ref.current
              );
              $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
            }
          }
          isClickFocusRef.current = false;
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onBlur,
          () => setIsTabbingBackOut(false)
        )
      })));
    });
    $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
    $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
      const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
      const id3 = tabStopId || autoId;
      const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
      const isCurrentTabStop = context.currentTabStopId === id3;
      const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
      const { onFocusableItemAdd, onFocusableItemRemove } = context;
      reactExports.useEffect(() => {
        if (focusable) {
          onFocusableItemAdd();
          return () => onFocusableItemRemove();
        }
      }, [
        focusable,
        onFocusableItemAdd,
        onFocusableItemRemove
      ]);
      return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
        scope: __scopeRovingFocusGroup,
        id: id3,
        focusable,
        active
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
        tabIndex: isCurrentTabStop ? 0 : -1,
        "data-orientation": context.orientation
      }, itemProps, {
        ref: forwardedRef,
        onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
          if (!focusable)
            event.preventDefault();
          else
            context.onItemFocus(id3);
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onFocus,
          () => context.onItemFocus(id3)
        ),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          if (event.key === "Tab" && event.shiftKey) {
            context.onItemShiftTab();
            return;
          }
          if (event.target !== event.currentTarget)
            return;
          const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
          if (focusIntent !== void 0) {
            event.preventDefault();
            const items = getItems().filter(
              (item) => item.focusable
            );
            let candidateNodes = items.map(
              (item) => item.ref.current
            );
            if (focusIntent === "last")
              candidateNodes.reverse();
            else if (focusIntent === "prev" || focusIntent === "next") {
              if (focusIntent === "prev")
                candidateNodes.reverse();
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(
              () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
            );
          }
        })
      })));
    });
    $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
      ArrowLeft: "prev",
      ArrowUp: "prev",
      ArrowRight: "next",
      ArrowDown: "next",
      PageUp: "first",
      Home: "first",
      PageDown: "last",
      End: "last"
    };
    $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
    $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;
    getDefaultParent = function(originalTarget) {
      if (typeof document === "undefined") {
        return null;
      }
      var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
      return sampleTarget.ownerDocument.body;
    };
    counterMap = /* @__PURE__ */ new WeakMap();
    uncontrolledNodes = /* @__PURE__ */ new WeakMap();
    markerMap = {};
    lockCount = 0;
    unwrapHost = function(node) {
      return node && (node.host || unwrapHost(node.parentNode));
    };
    correctTargets = function(parent, targets) {
      return targets.map(function(target) {
        if (parent.contains(target)) {
          return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
          return correctedTarget;
        }
        console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
        return null;
      }).filter(function(x4) {
        return Boolean(x4);
      });
    };
    applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
      var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
      if (!markerMap[markerName]) {
        markerMap[markerName] = /* @__PURE__ */ new WeakMap();
      }
      var markerCounter = markerMap[markerName];
      var hiddenNodes = [];
      var elementsToKeep = /* @__PURE__ */ new Set();
      var elementsToStop = new Set(targets);
      var keep = function(el2) {
        if (!el2 || elementsToKeep.has(el2)) {
          return;
        }
        elementsToKeep.add(el2);
        keep(el2.parentNode);
      };
      targets.forEach(keep);
      var deep = function(parent) {
        if (!parent || elementsToStop.has(parent)) {
          return;
        }
        Array.prototype.forEach.call(parent.children, function(node) {
          if (elementsToKeep.has(node)) {
            deep(node);
          } else {
            try {
              var attr = node.getAttribute(controlAttribute);
              var alreadyHidden = attr !== null && attr !== "false";
              var counterValue = (counterMap.get(node) || 0) + 1;
              var markerValue = (markerCounter.get(node) || 0) + 1;
              counterMap.set(node, counterValue);
              markerCounter.set(node, markerValue);
              hiddenNodes.push(node);
              if (counterValue === 1 && alreadyHidden) {
                uncontrolledNodes.set(node, true);
              }
              if (markerValue === 1) {
                node.setAttribute(markerName, "true");
              }
              if (!alreadyHidden) {
                node.setAttribute(controlAttribute, "true");
              }
            } catch (e2) {
              console.error("aria-hidden: cannot operate on ", node, e2);
            }
          }
        });
      };
      deep(parentNode);
      elementsToKeep.clear();
      lockCount++;
      return function() {
        hiddenNodes.forEach(function(node) {
          var counterValue = counterMap.get(node) - 1;
          var markerValue = markerCounter.get(node) - 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          if (!counterValue) {
            if (!uncontrolledNodes.has(node)) {
              node.removeAttribute(controlAttribute);
            }
            uncontrolledNodes.delete(node);
          }
          if (!markerValue) {
            node.removeAttribute(markerName);
          }
        });
        lockCount--;
        if (!lockCount) {
          counterMap = /* @__PURE__ */ new WeakMap();
          counterMap = /* @__PURE__ */ new WeakMap();
          uncontrolledNodes = /* @__PURE__ */ new WeakMap();
          markerMap = {};
        }
      };
    };
    hideOthers = function(originalTarget, parentNode, markerName) {
      if (markerName === void 0) {
        markerName = "data-aria-hidden";
      }
      var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
      var activeParentNode = parentNode || getDefaultParent(originalTarget);
      if (!activeParentNode) {
        return function() {
          return null;
        };
      }
      targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
      return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
    };
    __assign$1 = function() {
      __assign$1 = Object.assign || function __assign2(t5) {
        for (var s3, i2 = 1, n5 = arguments.length; i2 < n5; i2++) {
          s3 = arguments[i2];
          for (var p4 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p4))
              t5[p4] = s3[p4];
        }
        return t5;
      };
      return __assign$1.apply(this, arguments);
    };
    zeroRightClassName = "right-scroll-bar-position";
    fullWidthClassName = "width-before-scroll-bar";
    noScrollbarsClassName = "with-scroll-bars-hidden";
    removedBarSizeVariable = "--removed-body-scroll-bar-size";
    useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    currentValues = /* @__PURE__ */ new WeakMap();
    SideCar$1 = function(_a78) {
      var sideCar = _a78.sideCar, rest = __rest$1(_a78, ["sideCar"]);
      if (!sideCar) {
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
      }
      var Target = sideCar.read();
      if (!Target) {
        throw new Error("Sidecar medium not found");
      }
      return reactExports.createElement(Target, __assign$1({}, rest));
    };
    SideCar$1.isSideCarExport = true;
    effectCar = createSidecarMedium();
    nothing = function() {
      return;
    };
    RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
      var ref = reactExports.useRef(null);
      var _a78 = reactExports.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
      }), callbacks = _a78[0], setCallbacks = _a78[1];
      var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
      var SideCar2 = sideCar;
      var containerRef = useMergeRefs([ref, parentRef]);
      var containerProps = __assign$1(__assign$1({}, rest), callbacks);
      return reactExports.createElement(
        reactExports.Fragment,
        null,
        enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
        forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$1(__assign$1({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$1({}, containerProps, { className, ref: containerRef }), children)
      );
    });
    RemoveScroll.defaultProps = {
      enabled: true,
      removeScrollBar: true,
      inert: false
    };
    RemoveScroll.classNames = {
      fullWidth: fullWidthClassName,
      zeroRight: zeroRightClassName
    };
    getNonce = function() {
      if (typeof __webpack_nonce__ !== "undefined") {
        return __webpack_nonce__;
      }
      return void 0;
    };
    stylesheetSingleton = function() {
      var counter = 0;
      var stylesheet = null;
      return {
        add: function(style) {
          if (counter == 0) {
            if (stylesheet = makeStyleTag()) {
              injectStyles(stylesheet, style);
              insertStyleTag(stylesheet);
            }
          }
          counter++;
        },
        remove: function() {
          counter--;
          if (!counter && stylesheet) {
            stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
            stylesheet = null;
          }
        }
      };
    };
    styleHookSingleton = function() {
      var sheet = stylesheetSingleton();
      return function(styles, isDynamic) {
        reactExports.useEffect(function() {
          sheet.add(styles);
          return function() {
            sheet.remove();
          };
        }, [styles && isDynamic]);
      };
    };
    styleSingleton = function() {
      var useStyle = styleHookSingleton();
      var Sheet = function(_a78) {
        var styles = _a78.styles, dynamic = _a78.dynamic;
        useStyle(styles, dynamic);
        return null;
      };
      return Sheet;
    };
    zeroGap = {
      left: 0,
      top: 0,
      right: 0,
      gap: 0
    };
    parse = function(x4) {
      return parseInt(x4 || "", 10) || 0;
    };
    getOffset = function(gapMode) {
      var cs = window.getComputedStyle(document.body);
      var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
      var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
      var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
      return [parse(left), parse(top), parse(right)];
    };
    getGapWidth = function(gapMode) {
      if (gapMode === void 0) {
        gapMode = "margin";
      }
      if (typeof window === "undefined") {
        return zeroGap;
      }
      var offsets = getOffset(gapMode);
      var documentWidth = document.documentElement.clientWidth;
      var windowWidth = window.innerWidth;
      return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
      };
    };
    Style = styleSingleton();
    lockAttribute = "data-scroll-locked";
    getStyles = function(_a78, allowRelative, gapMode, important) {
      var left = _a78.left, top = _a78.top, right = _a78.right, gap = _a78.gap;
      if (gapMode === void 0) {
        gapMode = "margin";
      }
      return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
        allowRelative && "position: relative ".concat(important, ";"),
        gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
        gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
      ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
    };
    getCurrentUseCounter = function() {
      var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
      return isFinite(counter) ? counter : 0;
    };
    useLockAttribute = function() {
      reactExports.useEffect(function() {
        document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
        return function() {
          var newCounter = getCurrentUseCounter() - 1;
          if (newCounter <= 0) {
            document.body.removeAttribute(lockAttribute);
          } else {
            document.body.setAttribute(lockAttribute, newCounter.toString());
          }
        };
      }, []);
    };
    RemoveScrollBar = function(_a78) {
      var noRelative = _a78.noRelative, noImportant = _a78.noImportant, _b = _a78.gapMode, gapMode = _b === void 0 ? "margin" : _b;
      useLockAttribute();
      var gap = reactExports.useMemo(function() {
        return getGapWidth(gapMode);
      }, [gapMode]);
      return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
    };
    passiveSupported = false;
    if (typeof window !== "undefined") {
      try {
        options = Object.defineProperty({}, "passive", {
          get: function() {
            passiveSupported = true;
            return true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (err) {
        passiveSupported = false;
      }
    }
    nonPassive = passiveSupported ? { passive: false } : false;
    alwaysContainsScroll = function(node) {
      return node.tagName === "TEXTAREA";
    };
    elementCanBeScrolled = function(node, overflow) {
      var styles = window.getComputedStyle(node);
      return (
        // not-not-scrollable
        styles[overflow] !== "hidden" && // contains scroll inside self
        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
      );
    };
    elementCouldBeVScrolled = function(node) {
      return elementCanBeScrolled(node, "overflowY");
    };
    elementCouldBeHScrolled = function(node) {
      return elementCanBeScrolled(node, "overflowX");
    };
    locationCouldBeScrolled = function(axis, node) {
      var current = node;
      do {
        if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
          current = current.host;
        }
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
          var _a78 = getScrollVariables(axis, current), s3 = _a78[1], d2 = _a78[2];
          if (s3 > d2) {
            return true;
          }
        }
        current = current.parentNode;
      } while (current && current !== document.body);
      return false;
    };
    getVScrollVariables = function(_a78) {
      var scrollTop = _a78.scrollTop, scrollHeight = _a78.scrollHeight, clientHeight = _a78.clientHeight;
      return [
        scrollTop,
        scrollHeight,
        clientHeight
      ];
    };
    getHScrollVariables = function(_a78) {
      var scrollLeft = _a78.scrollLeft, scrollWidth = _a78.scrollWidth, clientWidth = _a78.clientWidth;
      return [
        scrollLeft,
        scrollWidth,
        clientWidth
      ];
    };
    elementCouldBeScrolled = function(axis, node) {
      return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
    };
    getScrollVariables = function(axis, node) {
      return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
    };
    getDirectionFactor = function(axis, direction) {
      return axis === "h" && direction === "rtl" ? -1 : 1;
    };
    handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
      var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
      var delta = directionFactor * sourceDelta;
      var target = event.target;
      var targetInLock = endTarget.contains(target);
      var shouldCancelScroll = false;
      var isDeltaPositive = delta > 0;
      var availableScroll = 0;
      var availableScrollTop = 0;
      do {
        var _a78 = getScrollVariables(axis, target), position = _a78[0], scroll_1 = _a78[1], capacity = _a78[2];
        var elementScroll = scroll_1 - capacity - directionFactor * position;
        if (position || elementScroll) {
          if (elementCouldBeScrolled(axis, target)) {
            availableScroll += elementScroll;
            availableScrollTop += position;
          }
        }
        target = target.parentNode;
      } while (
        // portaled content
        !targetInLock && target !== document.body || // self content
        targetInLock && (endTarget.contains(target) || endTarget === target)
      );
      if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
        shouldCancelScroll = true;
      } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
        shouldCancelScroll = true;
      }
      return shouldCancelScroll;
    };
    getTouchXY = function(event) {
      return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
    };
    getDeltaXY = function(event) {
      return [event.deltaX, event.deltaY];
    };
    extractRef = function(ref) {
      return ref && "current" in ref ? ref.current : ref;
    };
    deltaCompare = function(x4, y3) {
      return x4[0] === y3[0] && x4[1] === y3[1];
    };
    generateStyle = function(id3) {
      return "\n  .block-interactivity-".concat(id3, " {pointer-events: none;}\n  .allow-interactivity-").concat(id3, " {pointer-events: all;}\n");
    };
    idCounter = 0;
    lockStack = [];
    SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
    ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
      return reactExports.createElement(RemoveScroll, __assign$1({}, props, { ref, sideCar: SideCar }));
    });
    ReactRemoveScroll.classNames = RemoveScroll.classNames;
    $01b9c$RemoveScroll = ReactRemoveScroll;
    $6cc32821e9371a1c$var$SELECTION_KEYS = [
      "Enter",
      " "
    ];
    $6cc32821e9371a1c$var$FIRST_KEYS = [
      "ArrowDown",
      "PageUp",
      "Home"
    ];
    $6cc32821e9371a1c$var$LAST_KEYS = [
      "ArrowUp",
      "PageDown",
      "End"
    ];
    $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
      ...$6cc32821e9371a1c$var$FIRST_KEYS,
      ...$6cc32821e9371a1c$var$LAST_KEYS
    ];
    $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
      ltr: [
        ...$6cc32821e9371a1c$var$SELECTION_KEYS,
        "ArrowRight"
      ],
      rtl: [
        ...$6cc32821e9371a1c$var$SELECTION_KEYS,
        "ArrowLeft"
      ]
    };
    $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
      ltr: [
        "ArrowLeft"
      ],
      rtl: [
        "ArrowRight"
      ]
    };
    $6cc32821e9371a1c$var$MENU_NAME = "Menu";
    [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
    [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
      $6cc32821e9371a1c$var$createCollectionScope,
      $cf1ac5d9fe0e8206$export$722aac194ae923,
      $d7bdfb9eb0fdf311$export$c7109489551a4f4
    ]);
    $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
    $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
    [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
    [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
    $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
      const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
      const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
      const [content, setContent] = reactExports.useState(null);
      const isUsingKeyboardRef = reactExports.useRef(false);
      const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
      const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
      reactExports.useEffect(() => {
        const handleKeyDown = () => {
          isUsingKeyboardRef.current = true;
          document.addEventListener("pointerdown", handlePointer, {
            capture: true,
            once: true
          });
          document.addEventListener("pointermove", handlePointer, {
            capture: true,
            once: true
          });
        };
        const handlePointer = () => isUsingKeyboardRef.current = false;
        document.addEventListener("keydown", handleKeyDown, {
          capture: true
        });
        return () => {
          document.removeEventListener("keydown", handleKeyDown, {
            capture: true
          });
          document.removeEventListener("pointerdown", handlePointer, {
            capture: true
          });
          document.removeEventListener("pointermove", handlePointer, {
            capture: true
          });
        };
      }, []);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuProvider, {
        scope: __scopeMenu,
        open,
        onOpenChange: handleOpenChange,
        content,
        onContentChange: setContent
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootProvider, {
        scope: __scopeMenu,
        onClose: reactExports.useCallback(
          () => handleOpenChange(false),
          [
            handleOpenChange
          ]
        ),
        isUsingKeyboardRef,
        dir: direction,
        modal
      }, children)));
    };
    $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, ...anchorProps } = props;
      const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
        ref: forwardedRef
      }));
    });
    $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
    [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
      forceMount: void 0
    });
    $6cc32821e9371a1c$export$793392f970497feb = (props) => {
      const { __scopeMenu, forceMount, children, container } = props;
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$PortalProvider, {
        scope: __scopeMenu,
        forceMount
      }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, {
        asChild: true,
        container
      }, children)));
    };
    $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
    [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
    $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Provider, {
        scope: props.__scopeMenu
      }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Slot, {
        scope: props.__scopeMenu
      }, rootContext.modal ? /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {
        ref: forwardedRef
      })) : /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {
        ref: forwardedRef
      })))));
    });
    $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      reactExports.useEffect(() => {
        const content = ref.current;
        if (content)
          return hideOthers(content);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          {
            checkForDefaultPrevented: false
          }
        ),
        onDismiss: () => context.onOpenChange(false)
      }));
    });
    $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        onDismiss: () => context.onOpenChange(false)
      }));
    });
    $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
      const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
      const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
      const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
      const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
      const [currentItemId, setCurrentItemId] = reactExports.useState(null);
      const contentRef = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
      const timerRef = reactExports.useRef(0);
      const searchRef = reactExports.useRef("");
      const pointerGraceTimerRef = reactExports.useRef(0);
      const pointerGraceIntentRef = reactExports.useRef(null);
      const pointerDirRef = reactExports.useRef("right");
      const lastPointerXRef = reactExports.useRef(0);
      const ScrollLockWrapper = disableOutsideScroll ? $01b9c$RemoveScroll : reactExports.Fragment;
      const scrollLockWrapperProps = disableOutsideScroll ? {
        as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        allowPinchZoom: true
      } : void 0;
      const handleTypeaheadSearch = (key) => {
        var _items$find, _items$find2;
        const search = searchRef.current + key;
        const items = getItems().filter(
          (item) => !item.disabled
        );
        const currentItem = document.activeElement;
        const currentMatch = (_items$find = items.find(
          (item) => item.ref.current === currentItem
        )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
        const values = items.map(
          (item) => item.textValue
        );
        const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
        const newItem = (_items$find2 = items.find(
          (item) => item.textValue === nextMatch
        )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
        (function updateSearch(value) {
          searchRef.current = value;
          window.clearTimeout(timerRef.current);
          if (value !== "")
            timerRef.current = window.setTimeout(
              () => updateSearch(""),
              1e3
            );
        })(search);
        if (newItem)
          setTimeout(
            () => newItem.focus()
          );
      };
      reactExports.useEffect(() => {
        return () => window.clearTimeout(timerRef.current);
      }, []);
      $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
      const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
        var _pointerGraceIntentRe, _pointerGraceIntentRe2;
        const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
        return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentProvider, {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback((event) => {
          if (isPointerMovingToSubmenu(event))
            event.preventDefault();
        }, [
          isPointerMovingToSubmenu
        ]),
        onItemLeave: reactExports.useCallback((event) => {
          var _contentRef$current;
          if (isPointerMovingToSubmenu(event))
            return;
          (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
          setCurrentItemId(null);
        }, [
          isPointerMovingToSubmenu
        ]),
        onTriggerLeave: reactExports.useCallback((event) => {
          if (isPointerMovingToSubmenu(event))
            event.preventDefault();
        }, [
          isPointerMovingToSubmenu
        ]),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, [])
      }, /* @__PURE__ */ reactExports.createElement(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
        asChild: true,
        trapped: trapFocus,
        onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
          var _contentRef$current2;
          event.preventDefault();
          (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
        }),
        onUnmountAutoFocus: onCloseAutoFocus
      }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
        asChild: true,
        disableOutsidePointerEvents,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss
      }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
        asChild: true
      }, rovingFocusGroupScope, {
        dir: rootContext.dir,
        orientation: "vertical",
        loop,
        currentTabStopId: currentItemId,
        onCurrentTabStopIdChange: setCurrentItemId,
        onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
          if (!rootContext.isUsingKeyboardRef.current)
            event.preventDefault();
        })
      }), /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
        role: "menu",
        "aria-orientation": "vertical",
        "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
        "data-radix-menu-content": "",
        dir: rootContext.dir
      }, popperScope, contentProps, {
        ref: composedRefs,
        style: {
          outline: "none",
          ...contentProps.style
        },
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
          const target = event.target;
          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          const isCharacterKey = event.key.length === 1;
          if (isKeyDownInside) {
            if (event.key === "Tab")
              event.preventDefault();
            if (!isModifierKey && isCharacterKey)
              handleTypeaheadSearch(event.key);
          }
          const content = contentRef.current;
          if (event.target !== content)
            return;
          if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))
            return;
          event.preventDefault();
          const items = getItems().filter(
            (item) => !item.disabled
          );
          const candidateNodes = items.map(
            (item) => item.ref.current
          );
          if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
            candidateNodes.reverse();
          $6cc32821e9371a1c$var$focusFirst(candidateNodes);
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
          if (!event.currentTarget.contains(event.target)) {
            window.clearTimeout(timerRef.current);
            searchRef.current = "";
          }
        }),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
          const target = event.target;
          const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
          if (event.currentTarget.contains(target) && pointerXHasChanged) {
            const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
            pointerDirRef.current = newDir;
            lastPointerXRef.current = event.clientX;
          }
        }))
      })))))));
    });
    $6cc32821e9371a1c$export$dd37bec0e8a99143 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, ...labelProps } = props;
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, labelProps, {
        ref: forwardedRef
      }));
    });
    $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
    $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
    $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { disabled = false, onSelect, ...itemProps } = props;
      const ref = reactExports.useRef(null);
      const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
      const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const isPointerDownRef = reactExports.useRef(false);
      const handleSelect = () => {
        const menuItem = ref.current;
        if (!disabled && menuItem) {
          const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
            bubbles: true,
            cancelable: true
          });
          menuItem.addEventListener(
            $6cc32821e9371a1c$var$ITEM_SELECT,
            (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
            {
              once: true
            }
          );
          $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
          if (itemSelectEvent.defaultPrevented)
            isPointerDownRef.current = false;
          else
            rootContext.onClose();
        }
      };
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {
        ref: composedRefs,
        disabled,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _props$onPointerDown;
          (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
          var _event$currentTarget;
          if (!isPointerDownRef.current)
            (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ")
            return;
          if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }));
    });
    $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
      const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
      const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const [textContent, setTextContent] = reactExports.useState("");
      reactExports.useEffect(() => {
        const menuItem = ref.current;
        if (menuItem) {
          var _menuItem$textContent;
          setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
        }
      }, [
        itemProps.children
      ]);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.ItemSlot, {
        scope: __scopeMenu,
        disabled,
        textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
      }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
        asChild: true
      }, rovingFocusGroupScope, {
        focusable: !disabled
      }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        role: "menuitem",
        "data-highlighted": isFocused ? "" : void 0,
        "aria-disabled": disabled || void 0,
        "data-disabled": disabled ? "" : void 0
      }, itemProps, {
        ref: composedRefs,
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
          if (disabled)
            contentContext.onItemLeave(event);
          else {
            contentContext.onItemEnter(event);
            if (!event.defaultPrevented) {
              const item = event.currentTarget;
              item.focus();
            }
          }
        })),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
          (event) => contentContext.onItemLeave(event)
        )),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onFocus,
          () => setIsFocused(true)
        ),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onBlur,
          () => setIsFocused(false)
        )
      }))));
    });
    $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$ItemIndicatorProvider, {
        scope: props.__scopeMenu,
        checked
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
        role: "menuitemcheckbox",
        "aria-checked": $6cc32821e9371a1c$var$isIndeterminate(checked) ? "mixed" : checked
      }, checkboxItemProps, {
        ref: forwardedRef,
        "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
        onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          checkboxItemProps.onSelect,
          () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),
          {
            checkForDefaultPrevented: false
          }
        )
      })));
    });
    $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
    [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
      value: void 0,
      onValueChange: () => {
      }
    });
    $6cc32821e9371a1c$var$RADIO_ITEM_NAME = "MenuRadioItem";
    $6cc32821e9371a1c$export$69bd225e9817f6d0 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { value, ...radioItemProps } = props;
      const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);
      const checked = value === context.value;
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$ItemIndicatorProvider, {
        scope: props.__scopeMenu,
        checked
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
        role: "menuitemradio",
        "aria-checked": checked
      }, radioItemProps, {
        ref: forwardedRef,
        "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
        onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {
          var _context$onValueChang;
          return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);
        }, {
          checkForDefaultPrevented: false
        })
      })));
    });
    $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
    [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
      checked: false
    });
    $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
      const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {
        ref: forwardedRef,
        "data-state": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)
      })));
    });
    $6cc32821e9371a1c$export$1cec7dcdd713e220 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeMenu, ...separatorProps } = props;
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        role: "separator",
        "aria-orientation": "horizontal"
      }, separatorProps, {
        ref: forwardedRef
      }));
    });
    $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
    [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
    $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = "MenuSubTrigger";
    $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
      const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
      const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
      const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
      const openTimerRef = reactExports.useRef(null);
      const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
      const scope = {
        __scopeMenu: props.__scopeMenu
      };
      const clearOpenTimer = reactExports.useCallback(() => {
        if (openTimerRef.current)
          window.clearTimeout(openTimerRef.current);
        openTimerRef.current = null;
      }, []);
      reactExports.useEffect(
        () => clearOpenTimer,
        [
          clearOpenTimer
        ]
      );
      reactExports.useEffect(() => {
        const pointerGraceTimer = pointerGraceTimerRef.current;
        return () => {
          window.clearTimeout(pointerGraceTimer);
          onPointerGraceIntentChange(null);
        };
      }, [
        pointerGraceTimerRef,
        onPointerGraceIntentChange
      ]);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({
        asChild: true
      }, scope), /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends({
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": $6cc32821e9371a1c$var$getOpenState(context.open)
      }, props, {
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _props$onClick;
          (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);
          if (props.disabled || event.defaultPrevented)
            return;
          event.currentTarget.focus();
          if (!context.open)
            context.onOpenChange(true);
        },
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
          contentContext.onItemEnter(event);
          if (event.defaultPrevented)
            return;
          if (!props.disabled && !context.open && !openTimerRef.current) {
            contentContext.onPointerGraceIntentChange(null);
            openTimerRef.current = window.setTimeout(() => {
              context.onOpenChange(true);
              clearOpenTimer();
            }, 100);
          }
        })),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {
          var _context$content;
          clearOpenTimer();
          const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();
          if (contentRect) {
            var _context$content2;
            const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;
            const rightSide = side === "right";
            const bleed = rightSide ? -5 : 5;
            const contentNearEdge = contentRect[rightSide ? "left" : "right"];
            const contentFarEdge = contentRect[rightSide ? "right" : "left"];
            contentContext.onPointerGraceIntentChange({
              area: [
                // consistently within polygon bounds
                {
                  x: event.clientX + bleed,
                  y: event.clientY
                },
                {
                  x: contentNearEdge,
                  y: contentRect.top
                },
                {
                  x: contentFarEdge,
                  y: contentRect.top
                },
                {
                  x: contentFarEdge,
                  y: contentRect.bottom
                },
                {
                  x: contentNearEdge,
                  y: contentRect.bottom
                }
              ],
              side
            });
            window.clearTimeout(pointerGraceTimerRef.current);
            pointerGraceTimerRef.current = window.setTimeout(
              () => contentContext.onPointerGraceIntentChange(null),
              300
            );
          } else {
            contentContext.onTriggerLeave(event);
            if (event.defaultPrevented)
              return;
            contentContext.onPointerGraceIntentChange(null);
          }
        })),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ")
            return;
          if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            var _context$content3;
            context.onOpenChange(true);
            (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();
            event.preventDefault();
          }
        })
      })));
    });
    $6cc32821e9371a1c$var$SUB_CONTENT_NAME = "MenuSubContent";
    $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const { forceMount = portalContext.forceMount, ...subContentProps } = props;
      const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
      const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Provider, {
        scope: props.__scopeMenu
      }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Slot, {
        scope: props.__scopeMenu
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId
      }, subContentProps, {
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _ref$current;
          if (rootContext.isUsingKeyboardRef.current)
            (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger)
            context.onOpenChange(false);
        }),
        onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            var _subContext$trigger;
            context.onOpenChange(false);
            (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();
            event.preventDefault();
          }
        })
      })))));
    });
    $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
    $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
    $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;
    $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
    $6cc32821e9371a1c$export$b04be29aa201d4f5 = $6cc32821e9371a1c$export$dd37bec0e8a99143;
    $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
    $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;
    $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;
    $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;
    $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;
    $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;
    $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;
    $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
    [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
      $6cc32821e9371a1c$export$4027731b685e72eb
    ]);
    $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
    [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
    $d08ef79370b62062$export$e44a253a59704894 = (props) => {
      const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      const triggerRef = reactExports.useRef(null);
      const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
      });
      return /* @__PURE__ */ reactExports.createElement($d08ef79370b62062$var$DropdownMenuProvider, {
        scope: __scopeDropdownMenu,
        triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
        triggerRef,
        contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: reactExports.useCallback(
          () => setOpen(
            (prevOpen) => !prevOpen
          ),
          [
            setOpen
          ]
        ),
        modal
      }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
        open,
        onOpenChange: setOpen,
        dir,
        modal
      }), children));
    };
    $d08ef79370b62062$var$TRIGGER_NAME = "DropdownMenuTrigger";
    $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
      const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({
        asChild: true
      }, menuScope), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled
      }, triggerProps, {
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open)
              event.preventDefault();
          }
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          if (disabled)
            return;
          if ([
            "Enter",
            " "
          ].includes(event.key))
            context.onOpenToggle();
          if (event.key === "ArrowDown")
            context.onOpenChange(true);
          if ([
            "Enter",
            " ",
            "ArrowDown"
          ].includes(event.key))
            event.preventDefault();
        })
      })));
    });
    $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
      const { __scopeDropdownMenu, ...portalProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
    };
    $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
    $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...contentProps } = props;
      const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      const hasInteractedOutsideRef = reactExports.useRef(false);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({
        id: context.contentId,
        "aria-labelledby": context.triggerId
      }, menuScope, contentProps, {
        ref: forwardedRef,
        onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
          var _context$triggerRef$c;
          if (!hasInteractedOutsideRef.current)
            (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick)
            hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }));
    });
    $d08ef79370b62062$export$76e48c5b57f24495 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...labelProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$b04be29aa201d4f5, _extends({}, menuScope, labelProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...itemProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...checkboxItemProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$e4f69b41b1637536 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...radioItemProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$da160178fd3bc7e9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...separatorProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...subTriggerProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {
        ref: forwardedRef
      }));
    });
    $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDropdownMenu, ...subContentProps } = props;
      const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
      return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
        ref: forwardedRef,
        style: {
          ...props.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }));
    });
    $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
    $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
    $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;
    $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
    $d08ef79370b62062$export$b04be29aa201d4f5 = $d08ef79370b62062$export$76e48c5b57f24495;
    $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;
    $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;
    $d08ef79370b62062$export$371ab307eab489c0 = $d08ef79370b62062$export$e4f69b41b1637536;
    $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;
    $d08ef79370b62062$export$1ff3c3f08ae963c0 = $d08ef79370b62062$export$da160178fd3bc7e9;
    $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;
    $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;
    defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    createLucideIcon = (iconName, iconNode) => {
      const Component = reactExports.forwardRef(
        ({
          color = "currentColor",
          size: size2 = 24,
          strokeWidth = 2,
          absoluteStrokeWidth,
          className = "",
          children,
          ...rest
        }, ref) => {
          return reactExports.createElement(
            "svg",
            {
              ref,
              ...defaultAttributes,
              width: size2,
              height: size2,
              stroke: color,
              strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
              className: ["lucide", `lucide-${toKebabCase(iconName)}`, className].join(" "),
              ...rest
            },
            [
              ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
              ...Array.isArray(children) ? children : [children]
            ]
          );
        }
      );
      Component.displayName = `${iconName}`;
      return Component;
    };
    ArrowDown = createLucideIcon("ArrowDown", [
      ["path", { d: "M12 5v14", key: "s699le" }],
      ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }]
    ]);
    ArrowUp = createLucideIcon("ArrowUp", [
      ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
      ["path", { d: "M12 19V5", key: "x0mq9r" }]
    ]);
    CalendarDays = createLucideIcon("CalendarDays", [
      ["path", { d: "M8 2v4", key: "1cmpym" }],
      ["path", { d: "M16 2v4", key: "4m81vk" }],
      ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
      ["path", { d: "M3 10h18", key: "8toen8" }],
      ["path", { d: "M8 14h.01", key: "6423bh" }],
      ["path", { d: "M12 14h.01", key: "1etili" }],
      ["path", { d: "M16 14h.01", key: "1gbofw" }],
      ["path", { d: "M8 18h.01", key: "lrp35t" }],
      ["path", { d: "M12 18h.01", key: "mhygvu" }],
      ["path", { d: "M16 18h.01", key: "kzsmim" }]
    ]);
    Calendar$1 = createLucideIcon("Calendar", [
      ["path", { d: "M8 2v4", key: "1cmpym" }],
      ["path", { d: "M16 2v4", key: "4m81vk" }],
      ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
      ["path", { d: "M3 10h18", key: "8toen8" }]
    ]);
    CheckCheck = createLucideIcon("CheckCheck", [
      ["path", { d: "M18 6 7 17l-5-5", key: "116fxf" }],
      ["path", { d: "m22 10-7.5 7.5L13 16", key: "ke71qq" }]
    ]);
    Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
    ChevronDown = createLucideIcon("ChevronDown", [
      ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
    ]);
    ChevronLeft = createLucideIcon("ChevronLeft", [
      ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
    ]);
    ChevronRight = createLucideIcon("ChevronRight", [
      ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
    ]);
    ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
    Circle = createLucideIcon("Circle", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
    ]);
    Clock = createLucideIcon("Clock", [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
    ]);
    Dot = createLucideIcon("Dot", [
      ["circle", { cx: "12.1", cy: "12.1", r: "1", key: "18d7e5" }]
    ]);
    Download = createLucideIcon("Download", [
      ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
      ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
      ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
    ]);
    Ellipsis = createLucideIcon("Ellipsis", [
      ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
      ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
      ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
    ]);
    FileText = createLucideIcon("FileText", [
      ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
      ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
      ["path", { d: "M10 9H8", key: "b1mrlr" }],
      ["path", { d: "M16 13H8", key: "t4e002" }],
      ["path", { d: "M16 17H8", key: "z1uh3a" }]
    ]);
    Filter = createLucideIcon("Filter", [
      ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
    ]);
    HardDrive = createLucideIcon("HardDrive", [
      ["line", { x1: "22", x2: "2", y1: "12", y2: "12", key: "1y58io" }],
      [
        "path",
        {
          d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",
          key: "oot6mr"
        }
      ],
      ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16", key: "sgf278" }],
      ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16", key: "1l4acy" }]
    ]);
    ListFilter = createLucideIcon("ListFilter", [
      ["path", { d: "M3 6h18", key: "d0wm0j" }],
      ["path", { d: "M7 12h10", key: "b7w52i" }],
      ["path", { d: "M10 18h4", key: "1ulq68" }]
    ]);
    Pause = createLucideIcon("Pause", [
      ["rect", { width: "4", height: "16", x: "6", y: "4", key: "iffhe4" }],
      ["rect", { width: "4", height: "16", x: "14", y: "4", key: "sjin7j" }]
    ]);
    Plus = createLucideIcon("Plus", [
      ["path", { d: "M5 12h14", key: "1ays0h" }],
      ["path", { d: "M12 5v14", key: "s699le" }]
    ]);
    RefreshCcw = createLucideIcon("RefreshCcw", [
      ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
      ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
      ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
      ["path", { d: "M16 16h5v5", key: "ccwih5" }]
    ]);
    Square = createLucideIcon("Square", [
      ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
    ]);
    SwitchCamera = createLucideIcon("SwitchCamera", [
      ["path", { d: "M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5", key: "mtk2lu" }],
      ["path", { d: "M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5", key: "120jsl" }],
      ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
      ["path", { d: "m18 22-3-3 3-3", key: "kgdoj7" }],
      ["path", { d: "m6 2 3 3-3 3", key: "1fnbkv" }]
    ]);
    Trash2 = createLucideIcon("Trash2", [
      ["path", { d: "M3 6h18", key: "d0wm0j" }],
      ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
      ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
      ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
      ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
    ]);
    Video = createLucideIcon("Video", [
      ["path", { d: "m22 8-6 4 6 4V8Z", key: "50v9me" }],
      ["rect", { width: "14", height: "12", x: "2", y: "6", rx: "2", ry: "2", key: "1rqjg6" }]
    ]);
    WandSparkles = createLucideIcon("WandSparkles", [
      [
        "path",
        {
          d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72",
          key: "ul74o6"
        }
      ],
      ["path", { d: "m14 7 3 3", key: "1r5n42" }],
      ["path", { d: "M5 6v4", key: "ilb8ba" }],
      ["path", { d: "M19 14v4", key: "blhpug" }],
      ["path", { d: "M10 2v2", key: "7u0qdc" }],
      ["path", { d: "M7 8H3", key: "zfb6yr" }],
      ["path", { d: "M21 16h-4", key: "1cnmox" }],
      ["path", { d: "M11 3H9", key: "1obp7u" }]
    ]);
    X$1 = createLucideIcon("X", [
      ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
      ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
    ]);
    CLASS_PART_SEPARATOR = "-";
    arbitraryPropertyRegex = /^\[(.+)\]$/;
    IMPORTANT_MODIFIER = "!";
    SPLIT_CLASSES_REGEX = /\s+/;
    arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
    fractionRegex = /^\d+\/\d+$/;
    stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
    tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
    lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
    colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
    shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
    imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
    imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
    twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
    DropdownMenu = $d08ef79370b62062$export$be92b6f5f03c0fe9;
    DropdownMenuTrigger = $d08ef79370b62062$export$41fb9f06171c75f4;
    DropdownMenuSubTrigger = reactExports.forwardRef(({ className, inset, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $d08ef79370b62062$export$2ea8a7a591ac5eac,
      {
        ref,
        className: cn$1(
          "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
          inset && "pl-8",
          className
        ),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronRight, { className: "ml-auto h-4 w-4" })
        ]
      }
    ));
    DropdownMenuSubTrigger.displayName = $d08ef79370b62062$export$2ea8a7a591ac5eac.displayName;
    DropdownMenuSubContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $d08ef79370b62062$export$6d4de93b380beddf,
      {
        ref,
        className: cn$1(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        ),
        ...props
      }
    ));
    DropdownMenuSubContent.displayName = $d08ef79370b62062$export$6d4de93b380beddf.displayName;
    DropdownMenuContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx($d08ef79370b62062$export$602eac185826482c, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $d08ef79370b62062$export$7c6e2c02157bb7d2,
      {
        ref,
        sideOffset,
        className: cn$1(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        ),
        ...props
      }
    ) }));
    DropdownMenuContent.displayName = $d08ef79370b62062$export$7c6e2c02157bb7d2.displayName;
    DropdownMenuItem = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $d08ef79370b62062$export$6d08773d2e66f8f2,
      {
        ref,
        className: cn$1(
          "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
          inset && "pl-8",
          className
        ),
        ...props
      }
    ));
    DropdownMenuItem.displayName = $d08ef79370b62062$export$6d08773d2e66f8f2.displayName;
    DropdownMenuCheckboxItem = reactExports.forwardRef(({ className, children, checked, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $d08ef79370b62062$export$16ce288f89fa631c,
      {
        ref,
        className: cn$1(
          "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
          className
        ),
        checked,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($d08ef79370b62062$export$c3468e2714d175fa, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "h-4 w-4" }) }) }),
          children
        ]
      }
    ));
    DropdownMenuCheckboxItem.displayName = $d08ef79370b62062$export$16ce288f89fa631c.displayName;
    DropdownMenuRadioItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $d08ef79370b62062$export$371ab307eab489c0,
      {
        ref,
        className: cn$1(
          "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($d08ef79370b62062$export$c3468e2714d175fa, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Circle, { className: "h-2 w-2 fill-current" }) }) }),
          children
        ]
      }
    ));
    DropdownMenuRadioItem.displayName = $d08ef79370b62062$export$371ab307eab489c0.displayName;
    DropdownMenuLabel = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $d08ef79370b62062$export$b04be29aa201d4f5,
      {
        ref,
        className: cn$1(
          "px-2 py-1.5 text-sm font-semibold",
          inset && "pl-8",
          className
        ),
        ...props
      }
    ));
    DropdownMenuLabel.displayName = $d08ef79370b62062$export$b04be29aa201d4f5.displayName;
    DropdownMenuSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $d08ef79370b62062$export$1ff3c3f08ae963c0,
      {
        ref,
        className: cn$1("-mx-1 my-1 h-px bg-muted", className),
        ...props
      }
    ));
    DropdownMenuSeparator.displayName = $d08ef79370b62062$export$1ff3c3f08ae963c0.displayName;
    _excluded$Q = ["color"];
    CaretSortIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Q);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$X = ["color"];
    ChevronLeftIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$X);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$Y = ["color"];
    ChevronRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Y);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$1M = ["color"];
    DoubleArrowLeftIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1M);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M6.85355 3.85355C7.04882 3.65829 7.04882 3.34171 6.85355 3.14645C6.65829 2.95118 6.34171 2.95118 6.14645 3.14645L2.14645 7.14645C1.95118 7.34171 1.95118 7.65829 2.14645 7.85355L6.14645 11.8536C6.34171 12.0488 6.65829 12.0488 6.85355 11.8536C7.04882 11.6583 7.04882 11.3417 6.85355 11.1464L3.20711 7.5L6.85355 3.85355ZM12.8536 3.85355C13.0488 3.65829 13.0488 3.34171 12.8536 3.14645C12.6583 2.95118 12.3417 2.95118 12.1464 3.14645L8.14645 7.14645C7.95118 7.34171 7.95118 7.65829 8.14645 7.85355L12.1464 11.8536C12.3417 12.0488 12.6583 12.0488 12.8536 11.8536C13.0488 11.6583 13.0488 11.3417 12.8536 11.1464L9.20711 7.5L12.8536 3.85355Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$1N = ["color"];
    DoubleArrowRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1N);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M2.14645 11.1464C1.95118 11.3417 1.95118 11.6583 2.14645 11.8536C2.34171 12.0488 2.65829 12.0488 2.85355 11.8536L6.85355 7.85355C7.04882 7.65829 7.04882 7.34171 6.85355 7.14645L2.85355 3.14645C2.65829 2.95118 2.34171 2.95118 2.14645 3.14645C1.95118 3.34171 1.95118 3.65829 2.14645 3.85355L5.79289 7.5L2.14645 11.1464ZM8.14645 11.1464C7.95118 11.3417 7.95118 11.6583 8.14645 11.8536C8.34171 12.0488 8.65829 12.0488 8.85355 11.8536L12.8536 7.85355C13.0488 7.65829 13.0488 7.34171 12.8536 7.14645L8.85355 3.14645C8.65829 2.95118 8.34171 2.95118 8.14645 3.14645C7.95118 3.34171 7.95118 3.65829 8.14645 3.85355L11.7929 7.5L8.14645 11.1464Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$33 = ["color"];
    MagnifyingGlassIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$33);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    _excluded$3E = ["color"];
    ReloadIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
      var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3E);
      return reactExports.createElement("svg", Object.assign({
        width: "15",
        height: "15",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, props, {
        ref: forwardedRef
      }), reactExports.createElement("path", {
        d: "M1.84998 7.49998C1.84998 4.66458 4.05979 1.84998 7.49998 1.84998C10.2783 1.84998 11.6515 3.9064 12.2367 5H10.5C10.2239 5 10 5.22386 10 5.5C10 5.77614 10.2239 6 10.5 6H13.5C13.7761 6 14 5.77614 14 5.5V2.5C14 2.22386 13.7761 2 13.5 2C13.2239 2 13 2.22386 13 2.5V4.31318C12.2955 3.07126 10.6659 0.849976 7.49998 0.849976C3.43716 0.849976 0.849976 4.18537 0.849976 7.49998C0.849976 10.8146 3.43716 14.15 7.49998 14.15C9.44382 14.15 11.0622 13.3808 12.2145 12.2084C12.8315 11.5806 13.3133 10.839 13.6418 10.0407C13.7469 9.78536 13.6251 9.49315 13.3698 9.38806C13.1144 9.28296 12.8222 9.40478 12.7171 9.66014C12.4363 10.3425 12.0251 10.9745 11.5013 11.5074C10.5295 12.4963 9.16504 13.15 7.49998 13.15C4.05979 13.15 1.84998 10.3354 1.84998 7.49998Z",
        fill: color,
        fillRule: "evenodd",
        clipRule: "evenodd"
      }));
    });
    falsyToString = (value) => typeof value === "boolean" ? "".concat(value) : value === 0 ? "0" : value;
    cx = clsx2;
    cva = (base, config) => {
      return (props) => {
        var ref;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null)
          return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant) => {
          const variantProp = props === null || props === void 0 ? void 0 : props[variant];
          const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
          if (variantProp === null)
            return null;
          const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
          return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
          let [key, value] = param;
          if (value === void 0) {
            return acc;
          }
          acc[key] = value;
          return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (ref = config.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1) => {
          let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param1;
          return Object.entries(compoundVariantOptions).every((param) => {
            let [key, value] = param;
            return Array.isArray(value) ? value.includes({
              ...defaultVariants,
              ...propsWithoutUndefined
            }[key]) : {
              ...defaultVariants,
              ...propsWithoutUndefined
            }[key] === value;
          }) ? [
            ...acc,
            cvClass,
            cvClassName
          ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
      };
    };
    buttonVariants = cva(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      {
        variants: {
          variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline"
          },
          size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10"
          }
        },
        defaultVariants: {
          variant: "default",
          size: "default"
        }
      }
    );
    Button$1 = reactExports.forwardRef(
      ({ className, variant, size: size2, asChild = false, ...props }, ref) => {
        const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : "button";
        return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Comp,
          {
            className: cn$1(buttonVariants({ variant, size: size2, className })),
            ref,
            ...props
          }
        );
      }
    );
    Button$1.displayName = "Button";
    millisecondsInWeek = 6048e5;
    millisecondsInDay = 864e5;
    minutesInMonth = 43200;
    minutesInDay = 1440;
    defaultOptions = {};
    formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    formatDistance$2 = (token, count3, options) => {
      let result;
      const tokenValue = formatDistanceLocale$1[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count3 === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count3.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    dateFormats$1 = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    timeFormats$1 = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    dateTimeFormats$1 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    formatLong$1 = {
      date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: "full"
      })
    };
    formatRelativeLocale$1 = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    formatRelative$1 = (token, _date, _baseDate, _options) => formatRelativeLocale$1[token];
    eraValues$1 = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    quarterValues$1 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    monthValues$1 = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    };
    dayValues$1 = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    };
    dayPeriodValues$1 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    formattingDayPeriodValues$1 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    ordinalNumber$1 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      const rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    localize$1 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: "wide"
      })
    };
    matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i;
    parseOrdinalNumberPattern$1 = /\d+/i;
    matchEraPatterns$1 = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    parseEraPatterns$1 = {
      any: [/^b/i, /^(a|c)/i]
    };
    matchQuarterPatterns$1 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    matchMonthPatterns$1 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    parseMonthPatterns$1 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    matchDayPatterns$1 = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    parseDayPatterns$1 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    matchDayPeriodPatterns$1 = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    parseDayPeriodPatterns$1 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    match$1 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: (value) => parseInt(value, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: "any",
        valueCallback: (index3) => index3 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: "any"
      })
    };
    enUS = {
      code: "en-US",
      formatDistance: formatDistance$2,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    lightFormatters = {
      // Year
      y(date, token) {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
      },
      // Month
      M(date, token) {
        const month = date.getMonth();
        return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d(date, token) {
        return addLeadingZeros(date.getDate(), token.length);
      },
      // AM or PM
      a(date, token) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h(date, token) {
        return addLeadingZeros(date.getHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H(date, token) {
        return addLeadingZeros(date.getHours(), token.length);
      },
      // Minute
      m(date, token) {
        return addLeadingZeros(date.getMinutes(), token.length);
      },
      // Second
      s(date, token) {
        return addLeadingZeros(date.getSeconds(), token.length);
      },
      // Fraction of second
      S(date, token) {
        const numberOfDigits = token.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.trunc(
          milliseconds * Math.pow(10, numberOfDigits - 3)
        );
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    formatters$1 = {
      // Era
      G: function(date, token, localize2) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, { width: "abbreviated" });
          case "GGGGG":
            return localize2.era(era, { width: "narrow" });
          case "GGGG":
          default:
            return localize2.era(era, { width: "wide" });
        }
      },
      // Year
      y: function(date, token, localize2) {
        if (token === "yo") {
          const signedYear = date.getFullYear();
          const year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year, { unit: "year" });
        }
        return lightFormatters.y(date, token);
      },
      // Local week-numbering year
      Y: function(date, token, localize2, options) {
        const signedWeekYear = getWeekYear(date, options);
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          const twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize2.ordinalNumber(weekYear, { unit: "year" });
        }
        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function(date, token) {
        const isoWeekYear = getISOWeekYear(date);
        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function(date, token) {
        const year = date.getFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function(date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, { unit: "quarter" });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function(date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, { unit: "quarter" });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function(date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
          case "M":
          case "MM":
            return lightFormatters.M(date, token);
          case "Mo":
            return localize2.ordinalNumber(month + 1, { unit: "month" });
          case "MMM":
            return localize2.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month, { width: "wide", context: "formatting" });
        }
      },
      // Stand-alone month
      L: function(date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return addLeadingZeros(month + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month + 1, { unit: "month" });
          case "LLL":
            return localize2.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month, { width: "wide", context: "standalone" });
        }
      },
      // Local week of year
      w: function(date, token, localize2, options) {
        const week = getWeek(date, options);
        if (token === "wo") {
          return localize2.ordinalNumber(week, { unit: "week" });
        }
        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function(date, token, localize2) {
        const isoWeek = getISOWeek(date);
        if (token === "Io") {
          return localize2.ordinalNumber(isoWeek, { unit: "week" });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function(date, token, localize2) {
        if (token === "do") {
          return localize2.ordinalNumber(date.getDate(), { unit: "date" });
        }
        return lightFormatters.d(date, token);
      },
      // Day of year
      D: function(date, token, localize2) {
        const dayOfYear = getDayOfYear(date);
        if (token === "Do") {
          return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function(date, token, localize2) {
        const dayOfWeek = date.getDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function(date, token, localize2, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function(date, token, localize2, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function(date, token, localize2) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function(date, token, localize2) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function(date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function(date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function(date, token, localize2) {
        if (token === "ho") {
          let hours = date.getHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return lightFormatters.h(date, token);
      },
      // Hour [0-23]
      H: function(date, token, localize2) {
        if (token === "Ho") {
          return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
        }
        return lightFormatters.H(date, token);
      },
      // Hour [0-11]
      K: function(date, token, localize2) {
        const hours = date.getHours() % 12;
        if (token === "Ko") {
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function(date, token, localize2) {
        let hours = date.getHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function(date, token, localize2) {
        if (token === "mo") {
          return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
        }
        return lightFormatters.m(date, token);
      },
      // Second
      s: function(date, token, localize2) {
        if (token === "so") {
          return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
        }
        return lightFormatters.s(date, token);
      },
      // Fraction of second
      S: function(date, token) {
        return lightFormatters.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function(date, token, _localize) {
        const timestamp = Math.trunc(date.getTime() / 1e3);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function(date, token, _localize) {
        const timestamp = date.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    dateLongFormatter = (pattern, formatLong2) => {
      switch (pattern) {
        case "P":
          return formatLong2.date({ width: "short" });
        case "PP":
          return formatLong2.date({ width: "medium" });
        case "PPP":
          return formatLong2.date({ width: "long" });
        case "PPPP":
        default:
          return formatLong2.date({ width: "full" });
      }
    };
    timeLongFormatter = (pattern, formatLong2) => {
      switch (pattern) {
        case "p":
          return formatLong2.time({ width: "short" });
        case "pp":
          return formatLong2.time({ width: "medium" });
        case "ppp":
          return formatLong2.time({ width: "long" });
        case "pppp":
        default:
          return formatLong2.time({ width: "full" });
      }
    };
    dateTimeLongFormatter = (pattern, formatLong2) => {
      const matchResult = pattern.match(/(P+)(p+)?/) || [];
      const datePattern = matchResult[1];
      const timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
      }
      let dateTimeFormat2;
      switch (datePattern) {
        case "P":
          dateTimeFormat2 = formatLong2.dateTime({ width: "short" });
          break;
        case "PP":
          dateTimeFormat2 = formatLong2.dateTime({ width: "medium" });
          break;
        case "PPP":
          dateTimeFormat2 = formatLong2.dateTime({ width: "long" });
          break;
        case "PPPP":
        default:
          dateTimeFormat2 = formatLong2.dateTime({ width: "full" });
          break;
      }
      return dateTimeFormat2.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
    };
    longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    dayOfYearTokenRE = /^D+$/;
    weekYearTokenRE = /^Y+$/;
    throwTokens = ["D", "DD", "YY", "YYYY"];
    formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp = /^'([^]*?)'?$/;
    doubleQuoteRegExp = /''/g;
    unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    formatDistanceLocale = {
      lessThanXSeconds: {
        one: "menos de un segundo",
        other: "menos de {{count}} segundos"
      },
      xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
      },
      halfAMinute: "medio minuto",
      lessThanXMinutes: {
        one: "menos de un minuto",
        other: "menos de {{count}} minutos"
      },
      xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
      },
      aboutXHours: {
        one: "alrededor de 1 hora",
        other: "alrededor de {{count}} horas"
      },
      xHours: {
        one: "1 hora",
        other: "{{count}} horas"
      },
      xDays: {
        one: "1 d\xEDa",
        other: "{{count}} d\xEDas"
      },
      aboutXWeeks: {
        one: "alrededor de 1 semana",
        other: "alrededor de {{count}} semanas"
      },
      xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
      },
      aboutXMonths: {
        one: "alrededor de 1 mes",
        other: "alrededor de {{count}} meses"
      },
      xMonths: {
        one: "1 mes",
        other: "{{count}} meses"
      },
      aboutXYears: {
        one: "alrededor de 1 a\xF1o",
        other: "alrededor de {{count}} a\xF1os"
      },
      xYears: {
        one: "1 a\xF1o",
        other: "{{count}} a\xF1os"
      },
      overXYears: {
        one: "m\xE1s de 1 a\xF1o",
        other: "m\xE1s de {{count}} a\xF1os"
      },
      almostXYears: {
        one: "casi 1 a\xF1o",
        other: "casi {{count}} a\xF1os"
      }
    };
    formatDistance = (token, count3, options) => {
      let result;
      const tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count3 === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count3.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "en " + result;
        } else {
          return "hace " + result;
        }
      }
      return result;
    };
    dateFormats = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: "d MMM y",
      short: "dd/MM/y"
    };
    timeFormats = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    dateTimeFormats = {
      full: "{{date}} 'a las' {{time}}",
      long: "{{date}} 'a las' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    formatRelativeLocale = {
      lastWeek: "'el' eeee 'pasado a la' p",
      yesterday: "'ayer a la' p",
      today: "'hoy a la' p",
      tomorrow: "'ma\xF1ana a la' p",
      nextWeek: "eeee 'a la' p",
      other: "P"
    };
    formatRelativeLocalePlural = {
      lastWeek: "'el' eeee 'pasado a las' p",
      yesterday: "'ayer a las' p",
      today: "'hoy a las' p",
      tomorrow: "'ma\xF1ana a las' p",
      nextWeek: "eeee 'a las' p",
      other: "P"
    };
    formatRelative = (token, date, _baseDate, _options) => {
      if (date.getHours() !== 1) {
        return formatRelativeLocalePlural[token];
      } else {
        return formatRelativeLocale[token];
      }
    };
    eraValues = {
      narrow: ["AC", "DC"],
      abbreviated: ["AC", "DC"],
      wide: ["antes de cristo", "despu\xE9s de cristo"]
    };
    quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["T1", "T2", "T3", "T4"],
      wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
    };
    monthValues = {
      narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
      abbreviated: [
        "ene",
        "feb",
        "mar",
        "abr",
        "may",
        "jun",
        "jul",
        "ago",
        "sep",
        "oct",
        "nov",
        "dic"
      ],
      wide: [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre"
      ]
    };
    dayValues = {
      narrow: ["d", "l", "m", "m", "j", "v", "s"],
      short: ["do", "lu", "ma", "mi", "ju", "vi", "s\xE1"],
      abbreviated: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
      wide: [
        "domingo",
        "lunes",
        "martes",
        "mi\xE9rcoles",
        "jueves",
        "viernes",
        "s\xE1bado"
      ]
    };
    dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "ma\xF1ana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "ma\xF1ana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "ma\xF1ana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      }
    };
    formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "de la ma\xF1ana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la ma\xF1ana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la ma\xF1ana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      }
    };
    ordinalNumber = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return number + "\xBA";
    };
    localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    matchOrdinalNumberPattern = /^(\d+)()?/i;
    parseOrdinalNumberPattern = /\d+/i;
    matchEraPatterns = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
      wide: /^(antes de cristo|antes de la era com[u]n|despu[e]s de cristo|era com[u]n)/i
    };
    parseEraPatterns = {
      any: [/^ac/i, /^dc/i],
      wide: [
        /^(antes de cristo|antes de la era com[u]n)/i,
        /^(despu[e]s de cristo|era com[u]n)/i
      ]
    };
    matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234]()? trimestre/i
    };
    parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    matchMonthPatterns = {
      narrow: /^[efmajsond]/i,
      abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
      wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
    };
    parseMonthPatterns = {
      narrow: [
        /^e/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^en/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ]
    };
    matchDayPatterns = {
      narrow: /^[dlmjvs]/i,
      short: /^(do|lu|ma|mi|ju|vi|s[a])/i,
      abbreviated: /^(dom|lun|mar|mi[e]|jue|vie|s[a]b)/i,
      wide: /^(domingo|lunes|martes|mi[e]rcoles|jueves|viernes|s[a]bado)/i
    };
    parseDayPatterns = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
    };
    matchDayPeriodPatterns = {
      narrow: /^(a|p|mn|md|(de la|a las) (maana|tarde|noche))/i,
      any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maana|tarde|noche))/i
    };
    parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /^md/i,
        morning: /maana/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noche/i
      }
    };
    match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index3) => index3 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    es = {
      code: "es",
      formatDistance,
      formatLong,
      formatRelative,
      localize,
      match,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
      }
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t5) {
        for (var s3, i2 = 1, n5 = arguments.length; i2 < n5; i2++) {
          s3 = arguments[i2];
          for (var p4 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p4))
              t5[p4] = s3[p4];
        }
        return t5;
      };
      return __assign.apply(this, arguments);
    };
    jsxRuntime = { exports: {} };
    reactJsxRuntime_production_min = {};
    {
      jsxRuntime.exports = requireReactJsxRuntime_production_min();
    }
    jsxRuntimeExports = jsxRuntime.exports;
    defaultClassNames = {
      root: "rdp",
      multiple_months: "rdp-multiple_months",
      with_weeknumber: "rdp-with_weeknumber",
      vhidden: "rdp-vhidden",
      button_reset: "rdp-button_reset",
      button: "rdp-button",
      caption: "rdp-caption",
      caption_start: "rdp-caption_start",
      caption_end: "rdp-caption_end",
      caption_between: "rdp-caption_between",
      caption_label: "rdp-caption_label",
      caption_dropdowns: "rdp-caption_dropdowns",
      dropdown: "rdp-dropdown",
      dropdown_month: "rdp-dropdown_month",
      dropdown_year: "rdp-dropdown_year",
      dropdown_icon: "rdp-dropdown_icon",
      months: "rdp-months",
      month: "rdp-month",
      table: "rdp-table",
      tbody: "rdp-tbody",
      tfoot: "rdp-tfoot",
      head: "rdp-head",
      head_row: "rdp-head_row",
      head_cell: "rdp-head_cell",
      nav: "rdp-nav",
      nav_button: "rdp-nav_button",
      nav_button_previous: "rdp-nav_button_previous",
      nav_button_next: "rdp-nav_button_next",
      nav_icon: "rdp-nav_icon",
      row: "rdp-row",
      weeknumber: "rdp-weeknumber",
      cell: "rdp-cell",
      day: "rdp-day",
      day_today: "rdp-day_today",
      day_outside: "rdp-day_outside",
      day_selected: "rdp-day_selected",
      day_disabled: "rdp-day_disabled",
      day_hidden: "rdp-day_hidden",
      day_range_start: "rdp-day_range_start",
      day_range_end: "rdp-day_range_end",
      day_range_middle: "rdp-day_range_middle"
    };
    formatters = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      formatCaption,
      formatDay,
      formatMonthCaption,
      formatWeekNumber,
      formatWeekdayName,
      formatYearCaption
    });
    labelDay = function(day, activeModifiers, options) {
      return format(day, "do MMMM (EEEE)", options);
    };
    labelMonthDropdown = function() {
      return "Month: ";
    };
    labelNext = function() {
      return "Go to next month";
    };
    labelPrevious = function() {
      return "Go to previous month";
    };
    labelWeekday = function(day, options) {
      return format(day, "cccc", options);
    };
    labelWeekNumber = function(n5) {
      return "Week n. ".concat(n5);
    };
    labelYearDropdown = function() {
      return "Year: ";
    };
    labels = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      labelDay,
      labelMonthDropdown,
      labelNext,
      labelPrevious,
      labelWeekNumber,
      labelWeekday,
      labelYearDropdown
    });
    DayPickerContext = reactExports.createContext(void 0);
    NavigationContext = reactExports.createContext(void 0);
    Button = reactExports.forwardRef(function(props, ref) {
      var _a78 = useDayPicker(), classNames = _a78.classNames, styles = _a78.styles;
      var classNamesArr = [classNames.button_reset, classNames.button];
      if (props.className) {
        classNamesArr.push(props.className);
      }
      var className = classNamesArr.join(" ");
      var style = __assign(__assign({}, styles.button_reset), styles.button);
      if (props.style) {
        Object.assign(style, props.style);
      }
      return jsxRuntimeExports.jsx("button", __assign({}, props, { ref, type: "button", className, style }));
    });
    SelectMultipleContext = reactExports.createContext(void 0);
    SelectRangeContext = reactExports.createContext(void 0);
    (function(InternalModifier2) {
      InternalModifier2["Outside"] = "outside";
      InternalModifier2["Disabled"] = "disabled";
      InternalModifier2["Selected"] = "selected";
      InternalModifier2["Hidden"] = "hidden";
      InternalModifier2["Today"] = "today";
      InternalModifier2["RangeStart"] = "range_start";
      InternalModifier2["RangeEnd"] = "range_end";
      InternalModifier2["RangeMiddle"] = "range_middle";
    })(InternalModifier || (InternalModifier = {}));
    Selected = InternalModifier.Selected;
    Disabled = InternalModifier.Disabled;
    Hidden = InternalModifier.Hidden;
    Today = InternalModifier.Today;
    RangeEnd = InternalModifier.RangeEnd;
    RangeMiddle = InternalModifier.RangeMiddle;
    RangeStart = InternalModifier.RangeStart;
    Outside = InternalModifier.Outside;
    ModifiersContext = reactExports.createContext(void 0);
    MAX_RETRY = 365;
    FocusContext = reactExports.createContext(void 0);
    SelectSingleContext = reactExports.createContext(void 0);
    useIsomorphicLayoutEffect = canUseDOM() ? reactExports.useLayoutEffect : reactExports.useEffect;
    serverHandoffComplete = false;
    id = 0;
    $69cb30bb0017df05$var$TABS_NAME = "Tabs";
    [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($69cb30bb0017df05$var$TABS_NAME, [
      $d7bdfb9eb0fdf311$export$c7109489551a4f4
    ]);
    $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
    [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
    $69cb30bb0017df05$export$b2539bed5023c21c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
      const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
      const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: valueProp,
        onChange: onValueChange,
        defaultProp: defaultValue
      });
      return /* @__PURE__ */ reactExports.createElement($69cb30bb0017df05$var$TabsProvider, {
        scope: __scopeTabs,
        baseId: $1746a345f3d73bb7$export$f680877a34711e37(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        dir: direction,
        "data-orientation": orientation
      }, tabsProps, {
        ref: forwardedRef
      })));
    });
    $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
    $69cb30bb0017df05$export$9712d22edc0d78c1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTabs, loop = true, ...listProps } = props;
      const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
      const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
      return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
        asChild: true
      }, rovingFocusGroupScope, {
        orientation: context.orientation,
        dir: context.dir,
        loop
      }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        role: "tablist",
        "aria-orientation": context.orientation
      }, listProps, {
        ref: forwardedRef
      })));
    });
    $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
    $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
      const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
      const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
      const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
      const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
      const isSelected = value === context.value;
      return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
        asChild: true
      }, rovingFocusGroupScope, {
        focusable: !disabled,
        active: isSelected
      }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button",
        role: "tab",
        "aria-selected": isSelected,
        "aria-controls": contentId,
        "data-state": isSelected ? "active" : "inactive",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        id: triggerId
      }, triggerProps, {
        ref: forwardedRef,
        onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false)
            context.onValueChange(value);
          else
            event.preventDefault();
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          if ([
            " ",
            "Enter"
          ].includes(event.key))
            context.onValueChange(value);
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
          const isAutomaticActivation = context.activationMode !== "manual";
          if (!isSelected && !disabled && isAutomaticActivation)
            context.onValueChange(value);
        })
      })));
    });
    $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
    $69cb30bb0017df05$export$bd905d70e8fd2ebb = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
      const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
      const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
      const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
      const isSelected = value === context.value;
      const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
      reactExports.useEffect(() => {
        const rAF = requestAnimationFrame(
          () => isMountAnimationPreventedRef.current = false
        );
        return () => cancelAnimationFrame(rAF);
      }, []);
      return /* @__PURE__ */ reactExports.createElement(
        $921a889cee6df7e8$export$99c2b779aa4e8b8b,
        {
          present: forceMount || isSelected
        },
        ({ present }) => /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
          "data-state": isSelected ? "active" : "inactive",
          "data-orientation": context.orientation,
          role: "tabpanel",
          "aria-labelledby": triggerId,
          hidden: !present,
          id: contentId,
          tabIndex: 0
        }, contentProps, {
          ref: forwardedRef,
          style: {
            ...props.style,
            animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
          }
        }), present && children)
      );
    });
    $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
    $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
    $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
    $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;
    Tabs = $69cb30bb0017df05$export$be92b6f5f03c0fe9;
    TabsList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $69cb30bb0017df05$export$54c2e3dc7acea9f5,
      {
        ref,
        className: cn$1(
          "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
          className
        ),
        ...props
      }
    ));
    TabsList.displayName = $69cb30bb0017df05$export$54c2e3dc7acea9f5.displayName;
    TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $69cb30bb0017df05$export$41fb9f06171c75f4,
      {
        ref,
        className: cn$1(
          "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
          className
        ),
        ...props
      }
    ));
    TabsTrigger.displayName = $69cb30bb0017df05$export$41fb9f06171c75f4.displayName;
    TabsContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $69cb30bb0017df05$export$7c6e2c02157bb7d2,
      {
        ref,
        className: cn$1(
          "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
          className
        ),
        ...props
      }
    ));
    TabsContent.displayName = $69cb30bb0017df05$export$7c6e2c02157bb7d2.displayName;
    Calendar.displayName = "Calendar";
    CVSStatus = {
      PENDING: 1,
      REVIEWED: 2,
      REJECTED: 3,
      SELECTED: 4
    };
    places = [
      "And\xFAjar",
      "Brenes",
      "Bollullos Par del Condado",
      "C\xE1diz",
      "Coria del Rio",
      "Estepa",
      "Gilena",
      "Hytasa",
      "La Carolina",
      "Lantejuela",
      "Moguer",
      "Osuna",
      "Sanl\xFAcar de Barrameda",
      "Sevilla",
      "Utrera"
    ];
    positions = [
      "Carnicer\xEDa",
      "Charcuter\xEDa",
      "Pescader\xEDa",
      "Fruter\xEDa",
      "Panader\xEDa",
      "Pasteler\xEDa",
      "Cajero",
      "Reponedor",
      "Limpieza"
    ];
    badgeVariants = cva(
      "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
      {
        variants: {
          variant: {
            default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
            secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
            destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
            outline: "text-foreground"
          }
        },
        defaultVariants: {
          variant: "default"
        }
      }
    );
    $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
    [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
    [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
    $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
      const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
      const triggerRef = reactExports.useRef(null);
      const contentRef = reactExports.useRef(null);
      const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
      });
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogProvider, {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
        titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
        descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: reactExports.useCallback(
          () => setOpen(
            (prevOpen) => !prevOpen
          ),
          [
            setOpen
          ]
        ),
        modal
      }, children);
    };
    $5d3850c4d0b4e6c7$var$TRIGGER_NAME = "DialogTrigger";
    $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, ...triggerProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);
      const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
      }, triggerProps, {
        ref: composedTriggerRef,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
      }));
    });
    $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
    [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
      forceMount: void 0
    });
    $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
      const { __scopeDialog, forceMount, children, container } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$PortalProvider, {
        scope: __scopeDialog,
        forceMount
      }, reactExports.Children.map(
        children,
        (child) => /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
          present: forceMount || context.open
        }, /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, {
          asChild: true,
          container
        }, child))
      ));
    };
    $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
    $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {
        ref: forwardedRef
      }))) : null;
    });
    $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, ...overlayProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ reactExports.createElement($01b9c$RemoveScroll, {
          as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
          allowPinchZoom: true,
          shards: [
            context.contentRef
          ]
        }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
          "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
        }, overlayProps, {
          ref: forwardedRef,
          style: {
            pointerEvents: "auto",
            ...overlayProps.style
          }
        })))
      );
    });
    $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
    $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, context.modal ? /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {
        ref: forwardedRef
      })) : /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {
        ref: forwardedRef
      })));
    });
    $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
      reactExports.useEffect(() => {
        const content = contentRef.current;
        if (content)
          return hideOthers(content);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
          var _context$triggerRef$c;
          event.preventDefault();
          (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
        }),
        onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }));
    });
    $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
      const hasInteractedOutsideRef = reactExports.useRef(false);
      const hasPointerDownOutsideRef = reactExports.useRef(false);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _props$onCloseAutoFoc;
          (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
          if (!event.defaultPrevented) {
            var _context$triggerRef$c2;
            if (!hasInteractedOutsideRef.current)
              (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _props$onInteractOuts, _context$triggerRef$c3;
          (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown")
              hasPointerDownOutsideRef.current = true;
          }
          const target = event.target;
          const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
            event.preventDefault();
        }
      }));
    });
    $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
      $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus
      }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
      }, contentProps, {
        ref: composedRefs,
        onDismiss: () => context.onOpenChange(false)
      }))), false);
    });
    $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
    $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, ...titleProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends({
        id: context.titleId
      }, titleProps, {
        ref: forwardedRef
      }));
    });
    $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = "DialogDescription";
    $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, ...descriptionProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends({
        id: context.descriptionId
      }, descriptionProps, {
        ref: forwardedRef
      }));
    });
    $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
    $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeDialog, ...closeProps } = props;
      const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button"
      }, closeProps, {
        ref: forwardedRef,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onClick,
          () => context.onOpenChange(false)
        )
      }));
    });
    $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = "DialogTitleWarning";
    [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
      contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
      titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
      docsSlug: "dialog"
    });
    $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
    $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;
    $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
    $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
    $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
    $5d3850c4d0b4e6c7$export$f99233281efd08a0 = $5d3850c4d0b4e6c7$export$16f7638e4a34b909;
    $5d3850c4d0b4e6c7$export$393edc798c47379d = $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5;
    $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;
    $905f4ae918aab1aa$var$ROOT_NAME = "AlertDialog";
    [$905f4ae918aab1aa$var$createAlertDialogContext, $905f4ae918aab1aa$export$b8891880751c2c5b] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($905f4ae918aab1aa$var$ROOT_NAME, [
      $5d3850c4d0b4e6c7$export$cc702773b8ea3e41
    ]);
    $905f4ae918aab1aa$var$useDialogScope = $5d3850c4d0b4e6c7$export$cc702773b8ea3e41();
    $905f4ae918aab1aa$export$de466dd8317b0b75 = (props) => {
      const { __scopeAlertDialog, ...alertDialogProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, _extends({}, dialogScope, alertDialogProps, {
        modal: true
      }));
    };
    $905f4ae918aab1aa$export$6edd7a623ef0f40b = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...triggerProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, _extends({}, dialogScope, triggerProps, {
        ref: forwardedRef
      }));
    });
    $905f4ae918aab1aa$export$660f2bfdb986706c = (props) => {
      const { __scopeAlertDialog, ...portalProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$602eac185826482c, _extends({}, dialogScope, portalProps));
    };
    $905f4ae918aab1aa$export$a707a4895ce23256 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...overlayProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, _extends({}, dialogScope, overlayProps, {
        ref: forwardedRef
      }));
    });
    $905f4ae918aab1aa$var$CONTENT_NAME = "AlertDialogContent";
    [$905f4ae918aab1aa$var$AlertDialogContentProvider, $905f4ae918aab1aa$var$useAlertDialogContentContext] = $905f4ae918aab1aa$var$createAlertDialogContext($905f4ae918aab1aa$var$CONTENT_NAME);
    $905f4ae918aab1aa$export$94e6af45f0af4efd = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, children, ...contentProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
      const cancelRef = reactExports.useRef(null);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$69b62a49393917d6, {
        contentName: $905f4ae918aab1aa$var$CONTENT_NAME,
        titleName: $905f4ae918aab1aa$var$TITLE_NAME,
        docsSlug: "alert-dialog"
      }, /* @__PURE__ */ reactExports.createElement($905f4ae918aab1aa$var$AlertDialogContentProvider, {
        scope: __scopeAlertDialog,
        cancelRef
      }, /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, _extends({
        role: "alertdialog"
      }, dialogScope, contentProps, {
        ref: composedRefs,
        onOpenAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onOpenAutoFocus, (event) => {
          var _cancelRef$current;
          event.preventDefault();
          (_cancelRef$current = cancelRef.current) === null || _cancelRef$current === void 0 || _cancelRef$current.focus({
            preventScroll: true
          });
        }),
        onPointerDownOutside: (event) => event.preventDefault(),
        onInteractOutside: (event) => event.preventDefault()
      }), /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), false)));
    });
    $905f4ae918aab1aa$var$TITLE_NAME = "AlertDialogTitle";
    $905f4ae918aab1aa$export$225e0da62d314b7 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...titleProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$f99233281efd08a0, _extends({}, dialogScope, titleProps, {
        ref: forwardedRef
      }));
    });
    $905f4ae918aab1aa$export$a23b55cde55ad9a5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...descriptionProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$393edc798c47379d, _extends({}, dialogScope, descriptionProps, {
        ref: forwardedRef
      }));
    });
    $905f4ae918aab1aa$export$b454f818c58ee85d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...actionProps } = props;
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, actionProps, {
        ref: forwardedRef
      }));
    });
    $905f4ae918aab1aa$var$CANCEL_NAME = "AlertDialogCancel";
    $905f4ae918aab1aa$export$2f67a923571aaea0 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeAlertDialog, ...cancelProps } = props;
      const { cancelRef } = $905f4ae918aab1aa$var$useAlertDialogContentContext($905f4ae918aab1aa$var$CANCEL_NAME, __scopeAlertDialog);
      const dialogScope = $905f4ae918aab1aa$var$useDialogScope(__scopeAlertDialog);
      const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, cancelRef);
      return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, _extends({}, dialogScope, cancelProps, {
        ref
      }));
    });
    $905f4ae918aab1aa$export$be92b6f5f03c0fe9 = $905f4ae918aab1aa$export$de466dd8317b0b75;
    $905f4ae918aab1aa$export$41fb9f06171c75f4 = $905f4ae918aab1aa$export$6edd7a623ef0f40b;
    $905f4ae918aab1aa$export$602eac185826482c = $905f4ae918aab1aa$export$660f2bfdb986706c;
    $905f4ae918aab1aa$export$c6fdb837b070b4ff = $905f4ae918aab1aa$export$a707a4895ce23256;
    $905f4ae918aab1aa$export$7c6e2c02157bb7d2 = $905f4ae918aab1aa$export$94e6af45f0af4efd;
    $905f4ae918aab1aa$export$e19cd5f9376f8cee = $905f4ae918aab1aa$export$b454f818c58ee85d;
    $905f4ae918aab1aa$export$848c9b7ead0df967 = $905f4ae918aab1aa$export$2f67a923571aaea0;
    $905f4ae918aab1aa$export$f99233281efd08a0 = $905f4ae918aab1aa$export$225e0da62d314b7;
    $905f4ae918aab1aa$export$393edc798c47379d = $905f4ae918aab1aa$export$a23b55cde55ad9a5;
    AlertDialog = $905f4ae918aab1aa$export$be92b6f5f03c0fe9;
    AlertDialogTrigger = $905f4ae918aab1aa$export$41fb9f06171c75f4;
    AlertDialogPortal = $905f4ae918aab1aa$export$602eac185826482c;
    AlertDialogOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $905f4ae918aab1aa$export$c6fdb837b070b4ff,
      {
        className: cn$1(
          "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
          className
        ),
        ...props,
        ref
      }
    ));
    AlertDialogOverlay.displayName = $905f4ae918aab1aa$export$c6fdb837b070b4ff.displayName;
    AlertDialogContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AlertDialogPortal, { children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(AlertDialogOverlay, {}),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        $905f4ae918aab1aa$export$7c6e2c02157bb7d2,
        {
          ref,
          className: cn$1(
            "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            className
          ),
          ...props
        }
      )
    ] }));
    AlertDialogContent.displayName = $905f4ae918aab1aa$export$7c6e2c02157bb7d2.displayName;
    AlertDialogHeader = ({
      className,
      ...props
    }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "div",
      {
        className: cn$1(
          "flex flex-col space-y-2 text-center sm:text-left",
          className
        ),
        ...props
      }
    );
    AlertDialogHeader.displayName = "AlertDialogHeader";
    AlertDialogFooter = ({
      className,
      ...props
    }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "div",
      {
        className: cn$1(
          "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
          className
        ),
        ...props
      }
    );
    AlertDialogFooter.displayName = "AlertDialogFooter";
    AlertDialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $905f4ae918aab1aa$export$f99233281efd08a0,
      {
        ref,
        className: cn$1("text-lg font-semibold", className),
        ...props
      }
    ));
    AlertDialogTitle.displayName = $905f4ae918aab1aa$export$f99233281efd08a0.displayName;
    AlertDialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $905f4ae918aab1aa$export$393edc798c47379d,
      {
        ref,
        className: cn$1("text-sm text-muted-foreground", className),
        ...props
      }
    ));
    AlertDialogDescription.displayName = $905f4ae918aab1aa$export$393edc798c47379d.displayName;
    AlertDialogAction = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $905f4ae918aab1aa$export$e19cd5f9376f8cee,
      {
        ref,
        className: cn$1(buttonVariants(), className),
        ...props
      }
    ));
    AlertDialogAction.displayName = $905f4ae918aab1aa$export$e19cd5f9376f8cee.displayName;
    AlertDialogCancel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $905f4ae918aab1aa$export$848c9b7ead0df967,
      {
        ref,
        className: cn$1(
          buttonVariants({ variant: "outline" }),
          "mt-2 sm:mt-0",
          className
        ),
        ...props
      }
    ));
    AlertDialogCancel.displayName = $905f4ae918aab1aa$export$848c9b7ead0df967.displayName;
    $e698a72e93240346$var$CHECKBOX_NAME = "Checkbox";
    [$e698a72e93240346$var$createCheckboxContext, $e698a72e93240346$export$b566c4ff5488ea01] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($e698a72e93240346$var$CHECKBOX_NAME);
    [$e698a72e93240346$var$CheckboxProvider, $e698a72e93240346$var$useCheckboxContext] = $e698a72e93240346$var$createCheckboxContext($e698a72e93240346$var$CHECKBOX_NAME);
    $e698a72e93240346$export$48513f6b9f8ce62d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeCheckbox, name, checked: checkedProp, defaultChecked, required, disabled, value = "on", onCheckedChange, ...checkboxProps } = props;
      const [button, setButton] = reactExports.useState(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setButton(node)
      );
      const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
      const isFormControl = button ? Boolean(button.closest("form")) : true;
      const [checked = false, setChecked] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: checkedProp,
        defaultProp: defaultChecked,
        onChange: onCheckedChange
      });
      const initialCheckedStateRef = reactExports.useRef(checked);
      reactExports.useEffect(() => {
        const form = button === null || button === void 0 ? void 0 : button.form;
        if (form) {
          const reset = () => setChecked(initialCheckedStateRef.current);
          form.addEventListener("reset", reset);
          return () => form.removeEventListener("reset", reset);
        }
      }, [
        button,
        setChecked
      ]);
      return /* @__PURE__ */ reactExports.createElement($e698a72e93240346$var$CheckboxProvider, {
        scope: __scopeCheckbox,
        state: checked,
        disabled
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button",
        role: "checkbox",
        "aria-checked": $e698a72e93240346$var$isIndeterminate(checked) ? "mixed" : checked,
        "aria-required": required,
        "data-state": $e698a72e93240346$var$getState(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value
      }, checkboxProps, {
        ref: composedRefs,
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
          if (event.key === "Enter")
            event.preventDefault();
        }),
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, (event) => {
          setChecked(
            (prevChecked) => $e698a72e93240346$var$isIndeterminate(prevChecked) ? true : !prevChecked
          );
          if (isFormControl) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current)
              event.stopPropagation();
          }
        })
      })), isFormControl && /* @__PURE__ */ reactExports.createElement($e698a72e93240346$var$BubbleInput, {
        control: button,
        bubbles: !hasConsumerStoppedPropagationRef.current,
        name,
        value,
        checked,
        required,
        disabled,
        style: {
          transform: "translateX(-100%)"
        }
      }));
    });
    $e698a72e93240346$var$INDICATOR_NAME = "CheckboxIndicator";
    $e698a72e93240346$export$59aad738f51d1c05 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
      const context = $e698a72e93240346$var$useCheckboxContext($e698a72e93240346$var$INDICATOR_NAME, __scopeCheckbox);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || $e698a72e93240346$var$isIndeterminate(context.state) || context.state === true
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
        "data-state": $e698a72e93240346$var$getState(context.state),
        "data-disabled": context.disabled ? "" : void 0
      }, indicatorProps, {
        ref: forwardedRef,
        style: {
          pointerEvents: "none",
          ...props.style
        }
      })));
    });
    $e698a72e93240346$var$BubbleInput = (props) => {
      const { control, checked, bubbles = true, ...inputProps } = props;
      const ref = reactExports.useRef(null);
      const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
      const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control);
      reactExports.useEffect(() => {
        const input = ref.current;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
          const event = new Event("click", {
            bubbles
          });
          input.indeterminate = $e698a72e93240346$var$isIndeterminate(checked);
          setChecked.call(input, $e698a72e93240346$var$isIndeterminate(checked) ? false : checked);
          input.dispatchEvent(event);
        }
      }, [
        prevChecked,
        checked,
        bubbles
      ]);
      return /* @__PURE__ */ reactExports.createElement("input", _extends({
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: $e698a72e93240346$var$isIndeterminate(checked) ? false : checked
      }, inputProps, {
        tabIndex: -1,
        ref,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }));
    };
    $e698a72e93240346$export$be92b6f5f03c0fe9 = $e698a72e93240346$export$48513f6b9f8ce62d;
    $e698a72e93240346$export$adb584737d712b70 = $e698a72e93240346$export$59aad738f51d1c05;
    Checkbox = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $e698a72e93240346$export$be92b6f5f03c0fe9,
      {
        ref,
        className: cn$1(
          "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          $e698a72e93240346$export$adb584737d712b70,
          {
            className: cn$1("flex items-center justify-center text-current"),
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "h-4 w-4" })
          }
        )
      }
    ));
    Checkbox.displayName = $e698a72e93240346$export$be92b6f5f03c0fe9.displayName;
    Table2 = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "table",
      {
        ref,
        className: cn$1("w-full caption-bottom text-sm", className),
        ...props
      }
    ) }));
    Table2.displayName = "Table";
    TableHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { ref, className: cn$1("[&_tr]:border-b", className), ...props }));
    TableHeader.displayName = "TableHeader";
    TableBody = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "tbody",
      {
        ref,
        className: cn$1("[&_tr:last-child]:border-0", className),
        ...props
      }
    ));
    TableBody.displayName = "TableBody";
    TableFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "tfoot",
      {
        ref,
        className: cn$1(
          "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
          className
        ),
        ...props
      }
    ));
    TableFooter.displayName = "TableFooter";
    TableRow = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "tr",
      {
        ref,
        className: cn$1(
          "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
          className
        ),
        ...props
      }
    ));
    TableRow.displayName = "TableRow";
    TableHead = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "th",
      {
        ref,
        className: cn$1(
          "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
          className
        ),
        ...props
      }
    ));
    TableHead.displayName = "TableHead";
    TableCell = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "td",
      {
        ref,
        className: cn$1("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
        ...props
      }
    ));
    TableCell.displayName = "TableCell";
    TableCaption = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "caption",
      {
        ref,
        className: cn$1("mt-4 text-sm text-muted-foreground", className),
        ...props
      }
    ));
    TableCaption.displayName = "TableCaption";
    $57acba87d6e25586$var$SCROLL_AREA_NAME = "ScrollArea";
    [$57acba87d6e25586$var$createScrollAreaContext, $57acba87d6e25586$export$488468afe3a6f2b1] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($57acba87d6e25586$var$SCROLL_AREA_NAME);
    [$57acba87d6e25586$var$ScrollAreaProvider, $57acba87d6e25586$var$useScrollAreaContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLL_AREA_NAME);
    $57acba87d6e25586$export$ccf8d8d7bbf3c2cc = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeScrollArea, type = "hover", dir, scrollHideDelay = 600, ...scrollAreaProps } = props;
      const [scrollArea, setScrollArea] = reactExports.useState(null);
      const [viewport, setViewport] = reactExports.useState(null);
      const [content, setContent] = reactExports.useState(null);
      const [scrollbarX, setScrollbarX] = reactExports.useState(null);
      const [scrollbarY, setScrollbarY] = reactExports.useState(null);
      const [cornerWidth, setCornerWidth] = reactExports.useState(0);
      const [cornerHeight, setCornerHeight] = reactExports.useState(0);
      const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
      const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setScrollArea(node)
      );
      const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
      return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaProvider, {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        dir: direction
      }, scrollAreaProps, {
        ref: composedRefs,
        style: {
          position: "relative",
          // Pass corner sizes as CSS vars to reduce re-renders of context consumers
          ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
          ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
          ...props.style
        }
      })));
    });
    $57acba87d6e25586$var$VIEWPORT_NAME = "ScrollAreaViewport";
    $57acba87d6e25586$export$a21cbf9f11fca853 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeScrollArea, children, ...viewportProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$VIEWPORT_NAME, __scopeScrollArea);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onViewportChange);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("style", {
        dangerouslySetInnerHTML: {
          __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
        }
      }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-radix-scroll-area-viewport": ""
      }, viewportProps, {
        ref: composedRefs,
        style: {
          /**
          * We don't support `visible` because the intention is to have at least one scrollbar
          * if this component is used and `visible` will behave like `auto` in that case
          * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
          *
          * We don't handle `auto` because the intention is for the native implementation
          * to be hidden if using this component. We just want to ensure the node is scrollable
          * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
          * the browser from having to work out whether to render native scrollbars or not,
          * we tell it to with the intention of hiding them in CSS.
          */
          overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
          ...props.style
        }
      }), /* @__PURE__ */ reactExports.createElement("div", {
        ref: context.onContentChange,
        style: {
          minWidth: "100%",
          display: "table"
        }
      }, children)));
    });
    $57acba87d6e25586$var$SCROLLBAR_NAME = "ScrollAreaScrollbar";
    $57acba87d6e25586$export$2fabd85d0eba3c57 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { forceMount, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
      const isHorizontal = props.orientation === "horizontal";
      reactExports.useEffect(() => {
        isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
        return () => {
          isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
        };
      }, [
        isHorizontal,
        onScrollbarXEnabledChange,
        onScrollbarYEnabledChange
      ]);
      return context.type === "hover" ? /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarHover, _extends({}, scrollbarProps, {
        ref: forwardedRef,
        forceMount
      })) : context.type === "scroll" ? /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarScroll, _extends({}, scrollbarProps, {
        ref: forwardedRef,
        forceMount
      })) : context.type === "auto" ? /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, _extends({}, scrollbarProps, {
        ref: forwardedRef,
        forceMount
      })) : context.type === "always" ? /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({}, scrollbarProps, {
        ref: forwardedRef
      })) : null;
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarHover = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { forceMount, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const [visible, setVisible] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const scrollArea = context.scrollArea;
        let hideTimer = 0;
        if (scrollArea) {
          const handlePointerEnter = () => {
            window.clearTimeout(hideTimer);
            setVisible(true);
          };
          const handlePointerLeave = () => {
            hideTimer = window.setTimeout(
              () => setVisible(false),
              context.scrollHideDelay
            );
          };
          scrollArea.addEventListener("pointerenter", handlePointerEnter);
          scrollArea.addEventListener("pointerleave", handlePointerLeave);
          return () => {
            window.clearTimeout(hideTimer);
            scrollArea.removeEventListener("pointerenter", handlePointerEnter);
            scrollArea.removeEventListener("pointerleave", handlePointerLeave);
          };
        }
      }, [
        context.scrollArea,
        context.scrollHideDelay
      ]);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || visible
      }, /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, _extends({
        "data-state": visible ? "visible" : "hidden"
      }, scrollbarProps, {
        ref: forwardedRef
      })));
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarScroll = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { forceMount, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const isHorizontal = props.orientation === "horizontal";
      const debounceScrollEnd = $57acba87d6e25586$var$useDebounceCallback(
        () => send("SCROLL_END"),
        100
      );
      const [state, send] = $6c2e24571c90391f$export$3e6543de14f8614f("hidden", {
        hidden: {
          SCROLL: "scrolling"
        },
        scrolling: {
          SCROLL_END: "idle",
          POINTER_ENTER: "interacting"
        },
        interacting: {
          SCROLL: "interacting",
          POINTER_LEAVE: "idle"
        },
        idle: {
          HIDE: "hidden",
          SCROLL: "scrolling",
          POINTER_ENTER: "interacting"
        }
      });
      reactExports.useEffect(() => {
        if (state === "idle") {
          const hideTimer = window.setTimeout(
            () => send("HIDE"),
            context.scrollHideDelay
          );
          return () => window.clearTimeout(hideTimer);
        }
      }, [
        state,
        context.scrollHideDelay,
        send
      ]);
      reactExports.useEffect(() => {
        const viewport = context.viewport;
        const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
        if (viewport) {
          let prevScrollPos = viewport[scrollDirection];
          const handleScroll2 = () => {
            const scrollPos = viewport[scrollDirection];
            const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
            if (hasScrollInDirectionChanged) {
              send("SCROLL");
              debounceScrollEnd();
            }
            prevScrollPos = scrollPos;
          };
          viewport.addEventListener("scroll", handleScroll2);
          return () => viewport.removeEventListener("scroll", handleScroll2);
        }
      }, [
        context.viewport,
        isHorizontal,
        send,
        debounceScrollEnd
      ]);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || state !== "hidden"
      }, /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({
        "data-state": state === "hidden" ? "hidden" : "visible"
      }, scrollbarProps, {
        ref: forwardedRef,
        onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onPointerEnter,
          () => send("POINTER_ENTER")
        ),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          props.onPointerLeave,
          () => send("POINTER_LEAVE")
        )
      })));
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarAuto = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const { forceMount, ...scrollbarProps } = props;
      const [visible, setVisible] = reactExports.useState(false);
      const isHorizontal = props.orientation === "horizontal";
      const handleResize = $57acba87d6e25586$var$useDebounceCallback(() => {
        if (context.viewport) {
          const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
          const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
          setVisible(isHorizontal ? isOverflowX : isOverflowY);
        }
      }, 10);
      $57acba87d6e25586$var$useResizeObserver(context.viewport, handleResize);
      $57acba87d6e25586$var$useResizeObserver(context.content, handleResize);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || visible
      }, /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({
        "data-state": visible ? "visible" : "hidden"
      }, scrollbarProps, {
        ref: forwardedRef
      })));
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarVisible = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { orientation = "vertical", ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const thumbRef = reactExports.useRef(null);
      const pointerOffsetRef = reactExports.useRef(0);
      const [sizes, setSizes] = reactExports.useState({
        content: 0,
        viewport: 0,
        scrollbar: {
          size: 0,
          paddingStart: 0,
          paddingEnd: 0
        }
      });
      const thumbRatio = $57acba87d6e25586$var$getThumbRatio(sizes.viewport, sizes.content);
      const commonProps = {
        ...scrollbarProps,
        sizes,
        onSizesChange: setSizes,
        hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
        onThumbChange: (thumb) => thumbRef.current = thumb,
        onThumbPointerUp: () => pointerOffsetRef.current = 0,
        onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
      };
      function getScrollPosition(pointerPos, dir) {
        return $57acba87d6e25586$var$getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
      }
      if (orientation === "horizontal")
        return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarX, _extends({}, commonProps, {
          ref: forwardedRef,
          onThumbPositionChange: () => {
            if (context.viewport && thumbRef.current) {
              const scrollPos = context.viewport.scrollLeft;
              const offset2 = $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
              thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
            }
          },
          onWheelScroll: (scrollPos) => {
            if (context.viewport)
              context.viewport.scrollLeft = scrollPos;
          },
          onDragScroll: (pointerPos) => {
            if (context.viewport)
              context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }));
      if (orientation === "vertical")
        return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarY, _extends({}, commonProps, {
          ref: forwardedRef,
          onThumbPositionChange: () => {
            if (context.viewport && thumbRef.current) {
              const scrollPos = context.viewport.scrollTop;
              const offset2 = $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes);
              thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
            }
          },
          onWheelScroll: (scrollPos) => {
            if (context.viewport)
              context.viewport.scrollTop = scrollPos;
          },
          onDragScroll: (pointerPos) => {
            if (context.viewport)
              context.viewport.scrollTop = getScrollPosition(pointerPos);
          }
        }));
      return null;
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarX = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { sizes, onSizesChange, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const [computedStyle, setComputedStyle] = reactExports.useState();
      const ref = reactExports.useRef(null);
      const composeRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onScrollbarXChange);
      reactExports.useEffect(() => {
        if (ref.current)
          setComputedStyle(getComputedStyle(ref.current));
      }, [
        ref
      ]);
      return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, _extends({
        "data-orientation": "horizontal"
      }, scrollbarProps, {
        ref: composeRefs,
        sizes,
        style: {
          bottom: 0,
          left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
          right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
          ["--radix-scroll-area-thumb-width"]: $57acba87d6e25586$var$getThumbSize(sizes) + "px",
          ...props.style
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos);
            if ($57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos))
              event.preventDefault();
          }
        },
        onResize: () => {
          if (ref.current && context.viewport && computedStyle)
            onSizesChange({
              content: context.viewport.scrollWidth,
              viewport: context.viewport.offsetWidth,
              scrollbar: {
                size: ref.current.clientWidth,
                paddingStart: $57acba87d6e25586$var$toInt(computedStyle.paddingLeft),
                paddingEnd: $57acba87d6e25586$var$toInt(computedStyle.paddingRight)
              }
            });
        }
      }));
    });
    $57acba87d6e25586$var$ScrollAreaScrollbarY = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { sizes, onSizesChange, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);
      const [computedStyle, setComputedStyle] = reactExports.useState();
      const ref = reactExports.useRef(null);
      const composeRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onScrollbarYChange);
      reactExports.useEffect(() => {
        if (ref.current)
          setComputedStyle(getComputedStyle(ref.current));
      }, [
        ref
      ]);
      return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, _extends({
        "data-orientation": "vertical"
      }, scrollbarProps, {
        ref: composeRefs,
        sizes,
        style: {
          top: 0,
          right: context.dir === "ltr" ? 0 : void 0,
          left: context.dir === "rtl" ? 0 : void 0,
          bottom: "var(--radix-scroll-area-corner-height)",
          ["--radix-scroll-area-thumb-height"]: $57acba87d6e25586$var$getThumbSize(sizes) + "px",
          ...props.style
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos);
            if ($57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos))
              event.preventDefault();
          }
        },
        onResize: () => {
          if (ref.current && context.viewport && computedStyle)
            onSizesChange({
              content: context.viewport.scrollHeight,
              viewport: context.viewport.offsetHeight,
              scrollbar: {
                size: ref.current.clientHeight,
                paddingStart: $57acba87d6e25586$var$toInt(computedStyle.paddingTop),
                paddingEnd: $57acba87d6e25586$var$toInt(computedStyle.paddingBottom)
              }
            });
        }
      }));
    });
    [$57acba87d6e25586$var$ScrollbarProvider, $57acba87d6e25586$var$useScrollbarContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME);
    $57acba87d6e25586$var$ScrollAreaScrollbarImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeScrollArea, sizes, hasThumb, onThumbChange, onThumbPointerUp, onThumbPointerDown, onThumbPositionChange, onDragScroll, onWheelScroll, onResize, ...scrollbarProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, __scopeScrollArea);
      const [scrollbar, setScrollbar] = reactExports.useState(null);
      const composeRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setScrollbar(node)
      );
      const rectRef = reactExports.useRef(null);
      const prevWebkitUserSelectRef = reactExports.useRef("");
      const viewport = context.viewport;
      const maxScrollPos = sizes.content - sizes.viewport;
      const handleWheelScroll = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onWheelScroll);
      const handleThumbPositionChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onThumbPositionChange);
      const handleResize = $57acba87d6e25586$var$useDebounceCallback(onResize, 10);
      function handleDragScroll(event) {
        if (rectRef.current) {
          const x4 = event.clientX - rectRef.current.left;
          const y3 = event.clientY - rectRef.current.top;
          onDragScroll({
            x: x4,
            y: y3
          });
        }
      }
      reactExports.useEffect(() => {
        const handleWheel = (event) => {
          const element = event.target;
          const isScrollbarWheel = scrollbar === null || scrollbar === void 0 ? void 0 : scrollbar.contains(element);
          if (isScrollbarWheel)
            handleWheelScroll(event, maxScrollPos);
        };
        document.addEventListener("wheel", handleWheel, {
          passive: false
        });
        return () => document.removeEventListener("wheel", handleWheel, {
          passive: false
        });
      }, [
        viewport,
        scrollbar,
        maxScrollPos,
        handleWheelScroll
      ]);
      reactExports.useEffect(handleThumbPositionChange, [
        sizes,
        handleThumbPositionChange
      ]);
      $57acba87d6e25586$var$useResizeObserver(scrollbar, handleResize);
      $57acba87d6e25586$var$useResizeObserver(context.content, handleResize);
      return /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollbarProvider, {
        scope: __scopeScrollArea,
        scrollbar,
        hasThumb,
        onThumbChange: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onThumbChange),
        onThumbPointerUp: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onThumbPointerDown)
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, scrollbarProps, {
        ref: composeRefs,
        style: {
          position: "absolute",
          ...scrollbarProps.style
        },
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
          const mainPointer = 0;
          if (event.button === mainPointer) {
            const element = event.target;
            element.setPointerCapture(event.pointerId);
            rectRef.current = scrollbar.getBoundingClientRect();
            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
            document.body.style.webkitUserSelect = "none";
            if (context.viewport)
              context.viewport.style.scrollBehavior = "auto";
            handleDragScroll(event);
          }
        }),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, handleDragScroll),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
          const element = event.target;
          if (element.hasPointerCapture(event.pointerId))
            element.releasePointerCapture(event.pointerId);
          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
          if (context.viewport)
            context.viewport.style.scrollBehavior = "";
          rectRef.current = null;
        })
      })));
    });
    $57acba87d6e25586$var$THUMB_NAME = "ScrollAreaThumb";
    $57acba87d6e25586$export$9fba1154677d7cd2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { forceMount, ...thumbProps } = props;
      const scrollbarContext = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, props.__scopeScrollArea);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || scrollbarContext.hasThumb
      }, /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaThumbImpl, _extends({
        ref: forwardedRef
      }, thumbProps)));
    });
    $57acba87d6e25586$var$ScrollAreaThumbImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeScrollArea, style, ...thumbProps } = props;
      const scrollAreaContext = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$THUMB_NAME, __scopeScrollArea);
      const scrollbarContext = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, __scopeScrollArea);
      const { onThumbPositionChange } = scrollbarContext;
      const composedRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => scrollbarContext.onThumbChange(node)
      );
      const removeUnlinkedScrollListenerRef = reactExports.useRef();
      const debounceScrollEnd = $57acba87d6e25586$var$useDebounceCallback(() => {
        if (removeUnlinkedScrollListenerRef.current) {
          removeUnlinkedScrollListenerRef.current();
          removeUnlinkedScrollListenerRef.current = void 0;
        }
      }, 100);
      reactExports.useEffect(() => {
        const viewport = scrollAreaContext.viewport;
        if (viewport) {
          const handleScroll2 = () => {
            debounceScrollEnd();
            if (!removeUnlinkedScrollListenerRef.current) {
              const listener = $57acba87d6e25586$var$addUnlinkedScrollListener(viewport, onThumbPositionChange);
              removeUnlinkedScrollListenerRef.current = listener;
              onThumbPositionChange();
            }
          };
          onThumbPositionChange();
          viewport.addEventListener("scroll", handleScroll2);
          return () => viewport.removeEventListener("scroll", handleScroll2);
        }
      }, [
        scrollAreaContext.viewport,
        debounceScrollEnd,
        onThumbPositionChange
      ]);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden"
      }, thumbProps, {
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style
        },
        onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x4 = event.clientX - thumbRect.left;
          const y3 = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({
            x: x4,
            y: y3
          });
        }),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }));
    });
    $57acba87d6e25586$var$CORNER_NAME = "ScrollAreaCorner";
    $57acba87d6e25586$export$56969d565df7cc4b = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, props.__scopeScrollArea);
      const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
      const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
      return hasCorner ? /* @__PURE__ */ reactExports.createElement($57acba87d6e25586$var$ScrollAreaCornerImpl, _extends({}, props, {
        ref: forwardedRef
      })) : null;
    });
    $57acba87d6e25586$var$ScrollAreaCornerImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeScrollArea, ...cornerProps } = props;
      const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, __scopeScrollArea);
      const [width1, setWidth] = reactExports.useState(0);
      const [height1, setHeight] = reactExports.useState(0);
      const hasSize = Boolean(width1 && height1);
      $57acba87d6e25586$var$useResizeObserver(context.scrollbarX, () => {
        var _context$scrollbarX;
        const height = ((_context$scrollbarX = context.scrollbarX) === null || _context$scrollbarX === void 0 ? void 0 : _context$scrollbarX.offsetHeight) || 0;
        context.onCornerHeightChange(height);
        setHeight(height);
      });
      $57acba87d6e25586$var$useResizeObserver(context.scrollbarY, () => {
        var _context$scrollbarY;
        const width = ((_context$scrollbarY = context.scrollbarY) === null || _context$scrollbarY === void 0 ? void 0 : _context$scrollbarY.offsetWidth) || 0;
        context.onCornerWidthChange(width);
        setWidth(width);
      });
      return hasSize ? /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, cornerProps, {
        ref: forwardedRef,
        style: {
          width: width1,
          height: height1,
          position: "absolute",
          right: context.dir === "ltr" ? 0 : void 0,
          left: context.dir === "rtl" ? 0 : void 0,
          bottom: 0,
          ...props.style
        }
      })) : null;
    });
    $57acba87d6e25586$var$addUnlinkedScrollListener = (node, handler = () => {
    }) => {
      let prevPosition = {
        left: node.scrollLeft,
        top: node.scrollTop
      };
      let rAF = 0;
      (function loop() {
        const position = {
          left: node.scrollLeft,
          top: node.scrollTop
        };
        const isHorizontalScroll = prevPosition.left !== position.left;
        const isVerticalScroll = prevPosition.top !== position.top;
        if (isHorizontalScroll || isVerticalScroll)
          handler();
        prevPosition = position;
        rAF = window.requestAnimationFrame(loop);
      })();
      return () => window.cancelAnimationFrame(rAF);
    };
    $57acba87d6e25586$export$be92b6f5f03c0fe9 = $57acba87d6e25586$export$ccf8d8d7bbf3c2cc;
    $57acba87d6e25586$export$d5c6c08dc2d3ca7 = $57acba87d6e25586$export$a21cbf9f11fca853;
    $57acba87d6e25586$export$ac61190d9fc311a9 = $57acba87d6e25586$export$56969d565df7cc4b;
    ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $57acba87d6e25586$export$be92b6f5f03c0fe9,
      {
        ref,
        className: cn$1("relative overflow-hidden", className),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx($57acba87d6e25586$export$d5c6c08dc2d3ca7, { className: "h-full w-full rounded-[inherit]", children }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(ScrollBar, {}),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx($57acba87d6e25586$export$ac61190d9fc311a9, {})
        ]
      }
    ));
    ScrollArea.displayName = $57acba87d6e25586$export$be92b6f5f03c0fe9.displayName;
    ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $57acba87d6e25586$export$2fabd85d0eba3c57,
      {
        ref,
        orientation,
        className: cn$1(
          "flex touch-none select-none transition-colors",
          orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
          orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($57acba87d6e25586$export$9fba1154677d7cd2, { className: "relative flex-1 rounded-full bg-border" })
      }
    ));
    ScrollBar.displayName = $57acba87d6e25586$export$2fabd85d0eba3c57.displayName;
    Input = reactExports.forwardRef(
      ({ className, type, ...props }, ref) => {
        return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "input",
          {
            type,
            className: cn$1(
              "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
              className
            ),
            ref,
            ...props
          }
        );
      }
    );
    Input.displayName = "Input";
    $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }));
    });
    $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;
    $cc7e05a45900e73f$var$OPEN_KEYS = [
      " ",
      "Enter",
      "ArrowUp",
      "ArrowDown"
    ];
    $cc7e05a45900e73f$var$SELECTION_KEYS = [
      " ",
      "Enter"
    ];
    $cc7e05a45900e73f$var$SELECT_NAME = "Select";
    [$cc7e05a45900e73f$var$Collection, $cc7e05a45900e73f$var$useCollection, $cc7e05a45900e73f$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($cc7e05a45900e73f$var$SELECT_NAME);
    [$cc7e05a45900e73f$var$createSelectContext, $cc7e05a45900e73f$export$286727a75dc039bd] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cc7e05a45900e73f$var$SELECT_NAME, [
      $cc7e05a45900e73f$var$createCollectionScope,
      $cf1ac5d9fe0e8206$export$722aac194ae923
    ]);
    $cc7e05a45900e73f$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
    [$cc7e05a45900e73f$var$SelectProvider, $cc7e05a45900e73f$var$useSelectContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$SELECT_NAME);
    [$cc7e05a45900e73f$var$SelectNativeOptionsProvider, $cc7e05a45900e73f$var$useSelectNativeOptionsContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$SELECT_NAME);
    $cc7e05a45900e73f$export$ef9b1a59e592288f = (props) => {
      const { __scopeSelect, children, open: openProp, defaultOpen, onOpenChange, value: valueProp, defaultValue, onValueChange, dir, name, autoComplete, disabled, required } = props;
      const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
      const [trigger, setTrigger] = reactExports.useState(null);
      const [valueNode, setValueNode] = reactExports.useState(null);
      const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
      const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
      const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
      });
      const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: valueProp,
        defaultProp: defaultValue,
        onChange: onValueChange
      });
      const triggerPointerDownPosRef = reactExports.useRef(null);
      const isFormControl = trigger ? Boolean(trigger.closest("form")) : true;
      const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
      const nativeSelectKey = Array.from(nativeOptionsSet).map(
        (option) => option.props.value
      ).join(";");
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectProvider, {
        required,
        scope: __scopeSelect,
        trigger,
        onTriggerChange: setTrigger,
        valueNode,
        onValueNodeChange: setValueNode,
        valueNodeHasChildren,
        onValueNodeHasChildrenChange: setValueNodeHasChildren,
        contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
        value,
        onValueChange: setValue,
        open,
        onOpenChange: setOpen,
        dir: direction,
        triggerPointerDownPosRef,
        disabled
      }, /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$Collection.Provider, {
        scope: __scopeSelect
      }, /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectNativeOptionsProvider, {
        scope: props.__scopeSelect,
        onNativeOptionAdd: reactExports.useCallback((option) => {
          setNativeOptionsSet(
            (prev) => new Set(prev).add(option)
          );
        }, []),
        onNativeOptionRemove: reactExports.useCallback((option) => {
          setNativeOptionsSet((prev) => {
            const optionsSet = new Set(prev);
            optionsSet.delete(option);
            return optionsSet;
          });
        }, [])
      }, children)), isFormControl ? /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$BubbleSelect, {
        key: nativeSelectKey,
        "aria-hidden": true,
        required,
        tabIndex: -1,
        name,
        autoComplete,
        value,
        onChange: (event) => setValue(event.target.value),
        disabled
      }, value === void 0 ? /* @__PURE__ */ reactExports.createElement("option", {
        value: ""
      }) : null, Array.from(nativeOptionsSet)) : null));
    };
    $cc7e05a45900e73f$var$TRIGGER_NAME = "SelectTrigger";
    $cc7e05a45900e73f$export$3ac1e88a1c0b9f1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, disabled = false, ...triggerProps } = props;
      const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$TRIGGER_NAME, __scopeSelect);
      const isDisabled = context.disabled || disabled;
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.onTriggerChange);
      const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
      const [searchRef, handleTypeaheadSearch, resetTypeahead] = $cc7e05a45900e73f$var$useTypeaheadSearch((search) => {
        const enabledItems = getItems().filter(
          (item) => !item.disabled
        );
        const currentItem = enabledItems.find(
          (item) => item.value === context.value
        );
        const nextItem = $cc7e05a45900e73f$var$findNextItem(enabledItems, search, currentItem);
        if (nextItem !== void 0)
          context.onValueChange(nextItem.value);
      });
      const handleOpen = () => {
        if (!isDisabled) {
          context.onOpenChange(true);
          resetTypeahead();
        }
      };
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
        asChild: true
      }, popperScope), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": $cc7e05a45900e73f$var$shouldShowPlaceholder(context.value) ? "" : void 0
      }, triggerProps, {
        ref: composedRefs,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
        }),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(triggerProps.onPointerDown, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId))
            target.releasePointerCapture(event.pointerId);
          if (event.button === 0 && event.ctrlKey === false) {
            handleOpen();
            context.triggerPointerDownPosRef.current = {
              x: Math.round(event.pageX),
              y: Math.round(event.pageY)
            };
            event.preventDefault();
          }
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1)
            handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ")
            return;
          if ($cc7e05a45900e73f$var$OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      })));
    });
    $cc7e05a45900e73f$var$VALUE_NAME = "SelectValue";
    $cc7e05a45900e73f$export$e288731fd71264f0 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$VALUE_NAME, __scopeSelect);
      const { onValueNodeHasChildrenChange } = context;
      const hasChildren = children !== void 0;
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.onValueNodeChange);
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        onValueNodeHasChildrenChange(hasChildren);
      }, [
        onValueNodeHasChildrenChange,
        hasChildren
      ]);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, valueProps, {
        ref: composedRefs,
        style: {
          pointerEvents: "none"
        }
      }), $cc7e05a45900e73f$var$shouldShowPlaceholder(context.value) ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, placeholder) : children);
    });
    $cc7e05a45900e73f$export$99b400cabb58c515 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, children, ...iconProps } = props;
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
        "aria-hidden": true
      }, iconProps, {
        ref: forwardedRef
      }), children || "\u25BC");
    });
    $cc7e05a45900e73f$export$b2af6c9944296213 = (props) => {
      return /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, _extends({
        asChild: true
      }, props));
    };
    $cc7e05a45900e73f$var$CONTENT_NAME = "SelectContent";
    $cc7e05a45900e73f$export$c973a4b3cb86a03d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, props.__scopeSelect);
      const [fragment, setFragment] = reactExports.useState();
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        setFragment(new DocumentFragment());
      }, []);
      if (!context.open) {
        const frag = fragment;
        return frag ? /* @__PURE__ */ reactDomExports.createPortal(/* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectContentProvider, {
          scope: props.__scopeSelect
        }, /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$Collection.Slot, {
          scope: props.__scopeSelect
        }, /* @__PURE__ */ reactExports.createElement("div", null, props.children))), frag) : null;
      }
      return /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectContentImpl, _extends({}, props, {
        ref: forwardedRef
      }));
    });
    $cc7e05a45900e73f$var$CONTENT_MARGIN = 10;
    [$cc7e05a45900e73f$var$SelectContentProvider, $cc7e05a45900e73f$var$useSelectContentContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$CONTENT_NAME);
    $cc7e05a45900e73f$var$SelectContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const {
        __scopeSelect,
        position = "item-aligned",
        onCloseAutoFocus,
        onEscapeKeyDown,
        onPointerDownOutside,
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions,
        //
        ...contentProps
      } = props;
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
      const [content, setContent] = reactExports.useState(null);
      const [viewport, setViewport] = reactExports.useState(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setContent(node)
      );
      const [selectedItem, setSelectedItem] = reactExports.useState(null);
      const [selectedItemText, setSelectedItemText] = reactExports.useState(null);
      const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
      const [isPositioned, setIsPositioned] = reactExports.useState(false);
      const firstValidItemFoundRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        if (content)
          return hideOthers(content);
      }, [
        content
      ]);
      $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
      const focusFirst = reactExports.useCallback((candidates) => {
        const [firstItem, ...restItems] = getItems().map(
          (item) => item.ref.current
        );
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
            return;
          candidate === null || candidate === void 0 || candidate.scrollIntoView({
            block: "nearest"
          });
          if (candidate === firstItem && viewport)
            viewport.scrollTop = 0;
          if (candidate === lastItem && viewport)
            viewport.scrollTop = viewport.scrollHeight;
          candidate === null || candidate === void 0 || candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
            return;
        }
      }, [
        getItems,
        viewport
      ]);
      const focusSelectedItem = reactExports.useCallback(
        () => focusFirst([
          selectedItem,
          content
        ]),
        [
          focusFirst,
          selectedItem,
          content
        ]
      );
      reactExports.useEffect(() => {
        if (isPositioned)
          focusSelectedItem();
      }, [
        isPositioned,
        focusSelectedItem
      ]);
      const { onOpenChange, triggerPointerDownPosRef } = context;
      reactExports.useEffect(() => {
        if (content) {
          let pointerMoveDelta = {
            x: 0,
            y: 0
          };
          const handlePointerMove = (event) => {
            var _triggerPointerDownPo, _triggerPointerDownPo2, _triggerPointerDownPo3, _triggerPointerDownPo4;
            pointerMoveDelta = {
              x: Math.abs(Math.round(event.pageX) - ((_triggerPointerDownPo = (_triggerPointerDownPo2 = triggerPointerDownPosRef.current) === null || _triggerPointerDownPo2 === void 0 ? void 0 : _triggerPointerDownPo2.x) !== null && _triggerPointerDownPo !== void 0 ? _triggerPointerDownPo : 0)),
              y: Math.abs(Math.round(event.pageY) - ((_triggerPointerDownPo3 = (_triggerPointerDownPo4 = triggerPointerDownPosRef.current) === null || _triggerPointerDownPo4 === void 0 ? void 0 : _triggerPointerDownPo4.y) !== null && _triggerPointerDownPo3 !== void 0 ? _triggerPointerDownPo3 : 0))
            };
          };
          const handlePointerUp = (event) => {
            if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10)
              event.preventDefault();
            else if (!content.contains(event.target))
              onOpenChange(false);
            document.removeEventListener("pointermove", handlePointerMove);
            triggerPointerDownPosRef.current = null;
          };
          if (triggerPointerDownPosRef.current !== null) {
            document.addEventListener("pointermove", handlePointerMove);
            document.addEventListener("pointerup", handlePointerUp, {
              capture: true,
              once: true
            });
          }
          return () => {
            document.removeEventListener("pointermove", handlePointerMove);
            document.removeEventListener("pointerup", handlePointerUp, {
              capture: true
            });
          };
        }
      }, [
        content,
        onOpenChange,
        triggerPointerDownPosRef
      ]);
      reactExports.useEffect(() => {
        const close = () => onOpenChange(false);
        window.addEventListener("blur", close);
        window.addEventListener("resize", close);
        return () => {
          window.removeEventListener("blur", close);
          window.removeEventListener("resize", close);
        };
      }, [
        onOpenChange
      ]);
      const [searchRef, handleTypeaheadSearch] = $cc7e05a45900e73f$var$useTypeaheadSearch((search) => {
        const enabledItems = getItems().filter(
          (item) => !item.disabled
        );
        const currentItem = enabledItems.find(
          (item) => item.ref.current === document.activeElement
        );
        const nextItem = $cc7e05a45900e73f$var$findNextItem(enabledItems, search, currentItem);
        if (nextItem)
          setTimeout(
            () => nextItem.ref.current.focus()
          );
      });
      const itemRefCallback = reactExports.useCallback((node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem)
            firstValidItemFoundRef.current = true;
        }
      }, [
        context.value
      ]);
      const handleItemLeave = reactExports.useCallback(
        () => content === null || content === void 0 ? void 0 : content.focus(),
        [
          content
        ]
      );
      const itemTextRefCallback = reactExports.useCallback((node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem)
          setSelectedItemText(node);
      }, [
        context.value
      ]);
      const SelectPosition = position === "popper" ? $cc7e05a45900e73f$var$SelectPopperPosition : $cc7e05a45900e73f$var$SelectItemAlignedPosition;
      const popperContentProps = SelectPosition === $cc7e05a45900e73f$var$SelectPopperPosition ? {
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions
      } : {};
      return /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectContentProvider, {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef
      }, /* @__PURE__ */ reactExports.createElement($01b9c$RemoveScroll, {
        as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        allowPinchZoom: true
      }, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
        asChild: true,
        trapped: context.open,
        onMountAutoFocus: (event) => {
          event.preventDefault();
        },
        onUnmountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onCloseAutoFocus, (event) => {
          var _context$trigger;
          (_context$trigger = context.trigger) === null || _context$trigger === void 0 || _context$trigger.focus({
            preventScroll: true
          });
          event.preventDefault();
        })
      }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
        asChild: true,
        disableOutsidePointerEvents: true,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: () => context.onOpenChange(false)
      }, /* @__PURE__ */ reactExports.createElement(SelectPosition, _extends({
        role: "listbox",
        id: context.contentId,
        "data-state": context.open ? "open" : "closed",
        dir: context.dir,
        onContextMenu: (event) => event.preventDefault()
      }, contentProps, popperContentProps, {
        onPlaced: () => setIsPositioned(true),
        ref: composedRefs,
        style: {
          // flex layout so we can place the scroll buttons properly
          display: "flex",
          flexDirection: "column",
          // reset the outline by default as the content MAY get focused
          outline: "none",
          ...contentProps.style
        },
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (event.key === "Tab")
            event.preventDefault();
          if (!isModifierKey && event.key.length === 1)
            handleTypeaheadSearch(event.key);
          if ([
            "ArrowUp",
            "ArrowDown",
            "Home",
            "End"
          ].includes(event.key)) {
            const items = getItems().filter(
              (item) => !item.disabled
            );
            let candidateNodes = items.map(
              (item) => item.ref.current
            );
            if ([
              "ArrowUp",
              "End"
            ].includes(event.key))
              candidateNodes = candidateNodes.slice().reverse();
            if ([
              "ArrowUp",
              "ArrowDown"
            ].includes(event.key)) {
              const currentElement = event.target;
              const currentIndex = candidateNodes.indexOf(currentElement);
              candidateNodes = candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(
              () => focusFirst(candidateNodes)
            );
            event.preventDefault();
          }
        })
      }))))));
    });
    $cc7e05a45900e73f$var$SelectItemAlignedPosition = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, onPlaced, ...popperProps } = props;
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
      const [contentWrapper, setContentWrapper] = reactExports.useState(null);
      const [content, setContent] = reactExports.useState(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setContent(node)
      );
      const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
      const shouldExpandOnScrollRef = reactExports.useRef(false);
      const shouldRepositionRef = reactExports.useRef(true);
      const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
      const position = reactExports.useCallback(() => {
        if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
          const triggerRect = context.trigger.getBoundingClientRect();
          const contentRect = content.getBoundingClientRect();
          const valueNodeRect = context.valueNode.getBoundingClientRect();
          const itemTextRect = selectedItemText.getBoundingClientRect();
          if (context.dir !== "rtl") {
            const itemTextOffset = itemTextRect.left - contentRect.left;
            const left = valueNodeRect.left - itemTextOffset;
            const leftDelta = triggerRect.left - left;
            const minContentWidth = triggerRect.width + leftDelta;
            const contentWidth = Math.max(minContentWidth, contentRect.width);
            const rightEdge = window.innerWidth - $cc7e05a45900e73f$var$CONTENT_MARGIN;
            const clampedLeft = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(left, [
              $cc7e05a45900e73f$var$CONTENT_MARGIN,
              rightEdge - contentWidth
            ]);
            contentWrapper.style.minWidth = minContentWidth + "px";
            contentWrapper.style.left = clampedLeft + "px";
          } else {
            const itemTextOffset = contentRect.right - itemTextRect.right;
            const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
            const rightDelta = window.innerWidth - triggerRect.right - right;
            const minContentWidth = triggerRect.width + rightDelta;
            const contentWidth = Math.max(minContentWidth, contentRect.width);
            const leftEdge = window.innerWidth - $cc7e05a45900e73f$var$CONTENT_MARGIN;
            const clampedRight = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(right, [
              $cc7e05a45900e73f$var$CONTENT_MARGIN,
              leftEdge - contentWidth
            ]);
            contentWrapper.style.minWidth = minContentWidth + "px";
            contentWrapper.style.right = clampedRight + "px";
          }
          const items = getItems();
          const availableHeight = window.innerHeight - $cc7e05a45900e73f$var$CONTENT_MARGIN * 2;
          const itemsHeight = viewport.scrollHeight;
          const contentStyles = window.getComputedStyle(content);
          const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
          const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
          const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
          const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
          const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
          const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
          const viewportStyles = window.getComputedStyle(viewport);
          const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
          const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
          const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - $cc7e05a45900e73f$var$CONTENT_MARGIN;
          const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
          const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
          const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
          const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
          const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
          const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
          if (willAlignWithoutTopOverflow) {
            const isLastItem = selectedItem === items[items.length - 1].ref.current;
            contentWrapper.style.bottom = "0px";
            const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
            const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
            const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
            contentWrapper.style.height = height + "px";
          } else {
            const isFirstItem = selectedItem === items[0].ref.current;
            contentWrapper.style.top = "0px";
            const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);
            const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
            contentWrapper.style.height = height + "px";
            viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
          }
          contentWrapper.style.margin = `${$cc7e05a45900e73f$var$CONTENT_MARGIN}px 0`;
          contentWrapper.style.minHeight = minContentHeight + "px";
          contentWrapper.style.maxHeight = availableHeight + "px";
          onPlaced === null || onPlaced === void 0 || onPlaced();
          requestAnimationFrame(
            () => shouldExpandOnScrollRef.current = true
          );
        }
      }, [
        getItems,
        context.trigger,
        context.valueNode,
        contentWrapper,
        content,
        viewport,
        selectedItem,
        selectedItemText,
        context.dir,
        onPlaced
      ]);
      $9f79659886946c16$export$e5c5a5f917a5871c(
        () => position(),
        [
          position
        ]
      );
      const [contentZIndex, setContentZIndex] = reactExports.useState();
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        if (content)
          setContentZIndex(window.getComputedStyle(content).zIndex);
      }, [
        content
      ]);
      const handleScrollButtonChange = reactExports.useCallback((node) => {
        if (node && shouldRepositionRef.current === true) {
          position();
          focusSelectedItem === null || focusSelectedItem === void 0 || focusSelectedItem();
          shouldRepositionRef.current = false;
        }
      }, [
        position,
        focusSelectedItem
      ]);
      return /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectViewportProvider, {
        scope: __scopeSelect,
        contentWrapper,
        shouldExpandOnScrollRef,
        onScrollButtonChange: handleScrollButtonChange
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: setContentWrapper,
        style: {
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: contentZIndex
        }
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, popperProps, {
        ref: composedRefs,
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%",
          ...popperProps.style
        }
      }))));
    });
    $cc7e05a45900e73f$var$SelectPopperPosition = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, align = "start", collisionPadding = $cc7e05a45900e73f$var$CONTENT_MARGIN, ...popperProps } = props;
      const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({}, popperScope, popperProps, {
        ref: forwardedRef,
        align,
        collisionPadding,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...popperProps.style,
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }));
    });
    [$cc7e05a45900e73f$var$SelectViewportProvider, $cc7e05a45900e73f$var$useSelectViewportContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, {});
    $cc7e05a45900e73f$var$VIEWPORT_NAME = "SelectViewport";
    $cc7e05a45900e73f$export$9ed6e7b40248d36d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, ...viewportProps } = props;
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$VIEWPORT_NAME, __scopeSelect);
      const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$VIEWPORT_NAME, __scopeSelect);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentContext.onViewportChange);
      const prevScrollTopRef = reactExports.useRef(0);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("style", {
        dangerouslySetInnerHTML: {
          __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
        }
      }), /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$Collection.Slot, {
        scope: __scopeSelect
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-radix-select-viewport": "",
        role: "presentation"
      }, viewportProps, {
        ref: composedRefs,
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto",
          ...viewportProps.style
        },
        onScroll: $e42e1063c40fb3ef$export$b9ecd428b558ff10(viewportProps.onScroll, (event) => {
          const viewport = event.currentTarget;
          const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
          if (shouldExpandOnScrollRef !== null && shouldExpandOnScrollRef !== void 0 && shouldExpandOnScrollRef.current && contentWrapper) {
            const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
            if (scrolledBy > 0) {
              const availableHeight = window.innerHeight - $cc7e05a45900e73f$var$CONTENT_MARGIN * 2;
              const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
              const cssHeight = parseFloat(contentWrapper.style.height);
              const prevHeight = Math.max(cssMinHeight, cssHeight);
              if (prevHeight < availableHeight) {
                const nextHeight = prevHeight + scrolledBy;
                const clampedNextHeight = Math.min(availableHeight, nextHeight);
                const heightDiff = nextHeight - clampedNextHeight;
                contentWrapper.style.height = clampedNextHeight + "px";
                if (contentWrapper.style.bottom === "0px") {
                  viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                  contentWrapper.style.justifyContent = "flex-end";
                }
              }
            }
          }
          prevScrollTopRef.current = viewport.scrollTop;
        })
      }))));
    });
    $cc7e05a45900e73f$var$GROUP_NAME = "SelectGroup";
    [$cc7e05a45900e73f$var$SelectGroupContextProvider, $cc7e05a45900e73f$var$useSelectGroupContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$GROUP_NAME);
    $cc7e05a45900e73f$var$LABEL_NAME = "SelectLabel";
    $cc7e05a45900e73f$export$f67338d29bd972f8 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, ...labelProps } = props;
      const groupContext = $cc7e05a45900e73f$var$useSelectGroupContext($cc7e05a45900e73f$var$LABEL_NAME, __scopeSelect);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        id: groupContext.id
      }, labelProps, {
        ref: forwardedRef
      }));
    });
    $cc7e05a45900e73f$var$ITEM_NAME = "SelectItem";
    [$cc7e05a45900e73f$var$SelectItemContextProvider, $cc7e05a45900e73f$var$useSelectItemContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$ITEM_NAME);
    $cc7e05a45900e73f$export$13ef48a934230896 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, value, disabled = false, textValue: textValueProp, ...itemProps } = props;
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$ITEM_NAME, __scopeSelect);
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$ITEM_NAME, __scopeSelect);
      const isSelected = context.value === value;
      const [textValue, setTextValue] = reactExports.useState(textValueProp !== null && textValueProp !== void 0 ? textValueProp : "");
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) => {
        var _contentContext$itemR;
        return (_contentContext$itemR = contentContext.itemRefCallback) === null || _contentContext$itemR === void 0 ? void 0 : _contentContext$itemR.call(contentContext, node, value, disabled);
      });
      const textId = $1746a345f3d73bb7$export$f680877a34711e37();
      const handleSelect = () => {
        if (!disabled) {
          context.onValueChange(value);
          context.onOpenChange(false);
        }
      };
      if (value === "")
        throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
      return /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectItemContextProvider, {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => {
            var _node$textContent;
            return prevTextValue || ((_node$textContent = node === null || node === void 0 ? void 0 : node.textContent) !== null && _node$textContent !== void 0 ? _node$textContent : "").trim();
          });
        }, [])
      }, /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$Collection.ItemSlot, {
        scope: __scopeSelect,
        value,
        disabled,
        textValue
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        role: "option",
        "aria-labelledby": textId,
        "data-highlighted": isFocused ? "" : void 0,
        "aria-selected": isSelected && isFocused,
        "data-state": isSelected ? "checked" : "unchecked",
        "aria-disabled": disabled || void 0,
        "data-disabled": disabled ? "" : void 0,
        tabIndex: disabled ? void 0 : -1
      }, itemProps, {
        ref: composedRefs,
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          itemProps.onFocus,
          () => setIsFocused(true)
        ),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
          itemProps.onBlur,
          () => setIsFocused(false)
        ),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(itemProps.onPointerUp, handleSelect),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(itemProps.onPointerMove, (event) => {
          if (disabled) {
            var _contentContext$onIte;
            (_contentContext$onIte = contentContext.onItemLeave) === null || _contentContext$onIte === void 0 || _contentContext$onIte.call(contentContext);
          } else
            event.currentTarget.focus({
              preventScroll: true
            });
        }),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(itemProps.onPointerLeave, (event) => {
          if (event.currentTarget === document.activeElement) {
            var _contentContext$onIte2;
            (_contentContext$onIte2 = contentContext.onItemLeave) === null || _contentContext$onIte2 === void 0 || _contentContext$onIte2.call(contentContext);
          }
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(itemProps.onKeyDown, (event) => {
          var _contentContext$searc;
          const isTypingAhead = ((_contentContext$searc = contentContext.searchRef) === null || _contentContext$searc === void 0 ? void 0 : _contentContext$searc.current) !== "";
          if (isTypingAhead && event.key === " ")
            return;
          if ($cc7e05a45900e73f$var$SELECTION_KEYS.includes(event.key))
            handleSelect();
          if (event.key === " ")
            event.preventDefault();
        })
      }))));
    });
    $cc7e05a45900e73f$var$ITEM_TEXT_NAME = "SelectItemText";
    $cc7e05a45900e73f$export$3572fb0fb821ff49 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, className, style, ...itemTextProps } = props;
      const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
      const itemContext = $cc7e05a45900e73f$var$useSelectItemContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
      const nativeOptionsContext = $cc7e05a45900e73f$var$useSelectNativeOptionsContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
      const [itemTextNode, setItemTextNode] = reactExports.useState(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
        forwardedRef,
        (node) => setItemTextNode(node),
        itemContext.onItemTextChange,
        (node) => {
          var _contentContext$itemT;
          return (_contentContext$itemT = contentContext.itemTextRefCallback) === null || _contentContext$itemT === void 0 ? void 0 : _contentContext$itemT.call(contentContext, node, itemContext.value, itemContext.disabled);
        }
      );
      const textContent = itemTextNode === null || itemTextNode === void 0 ? void 0 : itemTextNode.textContent;
      const nativeOption = reactExports.useMemo(
        () => /* @__PURE__ */ reactExports.createElement("option", {
          key: itemContext.value,
          value: itemContext.value,
          disabled: itemContext.disabled
        }, textContent),
        [
          itemContext.disabled,
          itemContext.value,
          textContent
        ]
      );
      const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        onNativeOptionAdd(nativeOption);
        return () => onNativeOptionRemove(nativeOption);
      }, [
        onNativeOptionAdd,
        onNativeOptionRemove,
        nativeOption
      ]);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
        id: itemContext.textId
      }, itemTextProps, {
        ref: composedRefs
      })), itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? /* @__PURE__ */ reactDomExports.createPortal(itemTextProps.children, context.valueNode) : null);
    });
    $cc7e05a45900e73f$var$ITEM_INDICATOR_NAME = "SelectItemIndicator";
    $cc7e05a45900e73f$export$6b9198de19accfe6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, ...itemIndicatorProps } = props;
      const itemContext = $cc7e05a45900e73f$var$useSelectItemContext($cc7e05a45900e73f$var$ITEM_INDICATOR_NAME, __scopeSelect);
      return itemContext.isSelected ? /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
        "aria-hidden": true
      }, itemIndicatorProps, {
        ref: forwardedRef
      })) : null;
    });
    $cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
    $cc7e05a45900e73f$export$d8117927658af6d7 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
      const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
      const [canScrollUp1, setCanScrollUp] = reactExports.useState(false);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, viewportContext.onScrollButtonChange);
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        if (contentContext.viewport && contentContext.isPositioned) {
          let handleScroll3 = function() {
            const canScrollUp = viewport.scrollTop > 0;
            setCanScrollUp(canScrollUp);
          };
          var handleScroll2 = handleScroll3;
          const viewport = contentContext.viewport;
          handleScroll3();
          viewport.addEventListener("scroll", handleScroll3);
          return () => viewport.removeEventListener("scroll", handleScroll3);
        }
      }, [
        contentContext.viewport,
        contentContext.isPositioned
      ]);
      return canScrollUp1 ? /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectScrollButtonImpl, _extends({}, props, {
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem)
            viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      })) : null;
    });
    $cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
    $cc7e05a45900e73f$export$ff951e476c12189 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
      const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
      const [canScrollDown1, setCanScrollDown] = reactExports.useState(false);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, viewportContext.onScrollButtonChange);
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        if (contentContext.viewport && contentContext.isPositioned) {
          let handleScroll3 = function() {
            const maxScroll = viewport.scrollHeight - viewport.clientHeight;
            const canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll;
            setCanScrollDown(canScrollDown);
          };
          var handleScroll2 = handleScroll3;
          const viewport = contentContext.viewport;
          handleScroll3();
          viewport.addEventListener("scroll", handleScroll3);
          return () => viewport.removeEventListener("scroll", handleScroll3);
        }
      }, [
        contentContext.viewport,
        contentContext.isPositioned
      ]);
      return canScrollDown1 ? /* @__PURE__ */ reactExports.createElement($cc7e05a45900e73f$var$SelectScrollButtonImpl, _extends({}, props, {
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem)
            viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      })) : null;
    });
    $cc7e05a45900e73f$var$SelectScrollButtonImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
      const contentContext = $cc7e05a45900e73f$var$useSelectContentContext("SelectScrollButton", __scopeSelect);
      const autoScrollTimerRef = reactExports.useRef(null);
      const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
      const clearAutoScrollTimer = reactExports.useCallback(() => {
        if (autoScrollTimerRef.current !== null) {
          window.clearInterval(autoScrollTimerRef.current);
          autoScrollTimerRef.current = null;
        }
      }, []);
      reactExports.useEffect(() => {
        return () => clearAutoScrollTimer();
      }, [
        clearAutoScrollTimer
      ]);
      $9f79659886946c16$export$e5c5a5f917a5871c(() => {
        var _activeItem$ref$curre;
        const activeItem = getItems().find(
          (item) => item.ref.current === document.activeElement
        );
        activeItem === null || activeItem === void 0 || (_activeItem$ref$curre = activeItem.ref.current) === null || _activeItem$ref$curre === void 0 || _activeItem$ref$curre.scrollIntoView({
          block: "nearest"
        });
      }, [
        getItems
      ]);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "aria-hidden": true
      }, scrollIndicatorProps, {
        ref: forwardedRef,
        style: {
          flexShrink: 0,
          ...scrollIndicatorProps.style
        },
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(scrollIndicatorProps.onPointerDown, () => {
          if (autoScrollTimerRef.current === null)
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(scrollIndicatorProps.onPointerMove, () => {
          var _contentContext$onIte3;
          (_contentContext$onIte3 = contentContext.onItemLeave) === null || _contentContext$onIte3 === void 0 || _contentContext$onIte3.call(contentContext);
          if (autoScrollTimerRef.current === null)
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(scrollIndicatorProps.onPointerLeave, () => {
          clearAutoScrollTimer();
        })
      }));
    });
    $cc7e05a45900e73f$export$eba4b1df07cb1d3 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeSelect, ...separatorProps } = props;
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "aria-hidden": true
      }, separatorProps, {
        ref: forwardedRef
      }));
    });
    $cc7e05a45900e73f$var$BubbleSelect = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { value, ...selectProps } = props;
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const prevValue = $010c2913dbd2fe3d$export$5cae361ad82dce8b(value);
      reactExports.useEffect(() => {
        const select = ref.current;
        const selectProto = window.HTMLSelectElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(selectProto, "value");
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
          const event = new Event("change", {
            bubbles: true
          });
          setValue.call(select, value);
          select.dispatchEvent(event);
        }
      }, [
        prevValue,
        value
      ]);
      return /* @__PURE__ */ reactExports.createElement($ea1ef594cf570d83$export$439d29a4e110a164, {
        asChild: true
      }, /* @__PURE__ */ reactExports.createElement("select", _extends({}, selectProps, {
        ref: composedRefs,
        defaultValue: value
      })));
    });
    $cc7e05a45900e73f$var$BubbleSelect.displayName = "BubbleSelect";
    $cc7e05a45900e73f$export$be92b6f5f03c0fe9 = $cc7e05a45900e73f$export$ef9b1a59e592288f;
    $cc7e05a45900e73f$export$41fb9f06171c75f4 = $cc7e05a45900e73f$export$3ac1e88a1c0b9f1;
    $cc7e05a45900e73f$export$4c8d1a57a761ef94 = $cc7e05a45900e73f$export$e288731fd71264f0;
    $cc7e05a45900e73f$export$f04a61298a47a40f = $cc7e05a45900e73f$export$99b400cabb58c515;
    $cc7e05a45900e73f$export$602eac185826482c = $cc7e05a45900e73f$export$b2af6c9944296213;
    $cc7e05a45900e73f$export$7c6e2c02157bb7d2 = $cc7e05a45900e73f$export$c973a4b3cb86a03d;
    $cc7e05a45900e73f$export$d5c6c08dc2d3ca7 = $cc7e05a45900e73f$export$9ed6e7b40248d36d;
    $cc7e05a45900e73f$export$b04be29aa201d4f5 = $cc7e05a45900e73f$export$f67338d29bd972f8;
    $cc7e05a45900e73f$export$6d08773d2e66f8f2 = $cc7e05a45900e73f$export$13ef48a934230896;
    $cc7e05a45900e73f$export$d6e5bf9c43ea9319 = $cc7e05a45900e73f$export$3572fb0fb821ff49;
    $cc7e05a45900e73f$export$c3468e2714d175fa = $cc7e05a45900e73f$export$6b9198de19accfe6;
    $cc7e05a45900e73f$export$2f60d3ec9ad468f2 = $cc7e05a45900e73f$export$d8117927658af6d7;
    $cc7e05a45900e73f$export$bf1aedc3039c8d63 = $cc7e05a45900e73f$export$ff951e476c12189;
    $cc7e05a45900e73f$export$1ff3c3f08ae963c0 = $cc7e05a45900e73f$export$eba4b1df07cb1d3;
    Select = $cc7e05a45900e73f$export$be92b6f5f03c0fe9;
    SelectValue = $cc7e05a45900e73f$export$4c8d1a57a761ef94;
    SelectTrigger = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $cc7e05a45900e73f$export$41fb9f06171c75f4,
      {
        ref,
        className: cn$1(
          "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
          className
        ),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsxRuntimeExports$1.jsx($cc7e05a45900e73f$export$f04a61298a47a40f, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronDown, { className: "h-4 w-4 opacity-50" }) })
        ]
      }
    ));
    SelectTrigger.displayName = $cc7e05a45900e73f$export$41fb9f06171c75f4.displayName;
    SelectScrollUpButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $cc7e05a45900e73f$export$2f60d3ec9ad468f2,
      {
        ref,
        className: cn$1(
          "flex cursor-default items-center justify-center py-1",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronUp, { className: "h-4 w-4" })
      }
    ));
    SelectScrollUpButton.displayName = $cc7e05a45900e73f$export$2f60d3ec9ad468f2.displayName;
    SelectScrollDownButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $cc7e05a45900e73f$export$bf1aedc3039c8d63,
      {
        ref,
        className: cn$1(
          "flex cursor-default items-center justify-center py-1",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronDown, { className: "h-4 w-4" })
      }
    ));
    SelectScrollDownButton.displayName = $cc7e05a45900e73f$export$bf1aedc3039c8d63.displayName;
    SelectContent = reactExports.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx($cc7e05a45900e73f$export$602eac185826482c, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $cc7e05a45900e73f$export$7c6e2c02157bb7d2,
      {
        ref,
        className: cn$1(
          "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        ),
        position,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectScrollUpButton, {}),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            $cc7e05a45900e73f$export$d5c6c08dc2d3ca7,
            {
              className: cn$1(
                "p-1",
                position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
              ),
              children
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectScrollDownButton, {})
        ]
      }
    ) }));
    SelectContent.displayName = $cc7e05a45900e73f$export$7c6e2c02157bb7d2.displayName;
    SelectLabel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $cc7e05a45900e73f$export$b04be29aa201d4f5,
      {
        ref,
        className: cn$1("py-1.5 pl-8 pr-2 text-sm font-semibold", className),
        ...props
      }
    ));
    SelectLabel.displayName = $cc7e05a45900e73f$export$b04be29aa201d4f5.displayName;
    SelectItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      $cc7e05a45900e73f$export$6d08773d2e66f8f2,
      {
        ref,
        className: cn$1(
          "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($cc7e05a45900e73f$export$c3468e2714d175fa, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Check, { className: "h-4 w-4" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx($cc7e05a45900e73f$export$d6e5bf9c43ea9319, { children })
        ]
      }
    ));
    SelectItem.displayName = $cc7e05a45900e73f$export$6d08773d2e66f8f2.displayName;
    SelectSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $cc7e05a45900e73f$export$1ff3c3f08ae963c0,
      {
        ref,
        className: cn$1("-mx-1 my-1 h-px bg-muted", className),
        ...props
      }
    ));
    SelectSeparator.displayName = $cc7e05a45900e73f$export$1ff3c3f08ae963c0.displayName;
    useDebounce = (value, delay) => {
      const [debouncedValue, setDebouncedValue] = reactExports.useState(value);
      reactExports.useEffect(() => {
        const handler = setTimeout(() => {
          setDebouncedValue(value);
        }, delay);
        return () => {
          clearTimeout(handler);
        };
      }, [value, delay]);
      return debouncedValue;
    };
    ({ entries: ke, setPrototypeOf: Ne, isFrozen: Ze, getPrototypeOf: Je, getOwnPropertyDescriptor: Qe } = Object);
    ({ freeze: O2, seal: X, create: Be } = Object);
    ({ apply: ce, construct: de } = typeof Reflect != "undefined" && Reflect);
    O2 || (O2 = function(n5) {
      return n5;
    });
    X || (X = function(n5) {
      return n5;
    });
    ce || (ce = function(n5, t5, a2) {
      return n5.apply(t5, a2);
    });
    de || (de = function(n5, t5) {
      return new n5(...t5);
    });
    Zt = F2(Array.prototype.forEach);
    De = F2(Array.prototype.pop);
    jt = F2(Array.prototype.push);
    te = F2(String.prototype.toLowerCase);
    ae = F2(String.prototype.toString);
    Ie = F2(String.prototype.match);
    $t = F2(String.prototype.replace);
    tn = F2(String.prototype.indexOf);
    en = F2(String.prototype.trim);
    Q = F2(Object.prototype.hasOwnProperty);
    U = F2(RegExp.prototype.test);
    Vt = nn(TypeError);
    Ce = O2(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
    re = O2(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
    se = O2(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
    an = O2(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
    ie = O2(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
    rn = O2(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
    Le = O2(["#text"]);
    Me = O2(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
    le = O2(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
    Pe = O2(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
    Qt = O2(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
    sn = X(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    ln = X(/<%[\w\W]*|[\w\W]*%>/gm);
    cn = X(/\${[\w\W]*}/gm);
    dn = X(/^data-[\-\w.\u00B7-\uFFFF]/);
    un = X(/^aria-[\-\w]+$/);
    He = X(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
    fn = X(/^(?:\w+script|data):/i);
    mn = X(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
    Ue = X(/^html$/i);
    pn = X(/^[a-z][a-z\d]*(-[a-z\d]+)+$/i);
    Oe = Object.freeze({ __proto__: null, MUSTACHE_EXPR: sn, ERB_EXPR: ln, TMPLIT_EXPR: cn, DATA_ATTR: dn, ARIA_ATTR: un, IS_ALLOWED_URI: He, IS_SCRIPT_OR_DATA: fn, ATTR_WHITESPACE: mn, DOCTYPE_NAME: Ue, CUSTOM_ELEMENT: pn });
    gn = function() {
      return typeof window == "undefined" ? null : window;
    };
    hn = function(n5, t5) {
      if (typeof n5 != "object" || typeof n5.createPolicy != "function")
        return null;
      let a2 = null, g = "data-tt-policy-suffix";
      t5 && t5.hasAttribute(g) && (a2 = t5.getAttribute(g));
      let E4 = "dompurify" + (a2 ? "#" + a2 : "");
      try {
        return n5.createPolicy(E4, { createHTML(y3) {
          return y3;
        }, createScriptURL(y3) {
          return y3;
        } });
      } catch (y3) {
        return console.warn("TrustedTypes policy " + E4 + " could not be created."), null;
      }
    };
    ze = Fe();
    We = (r5) => {
      switch (r5) {
        case "success":
          return bn;
        case "info":
          return En;
        case "warning":
          return yn;
        case "error":
          return wn;
        default:
          return null;
      }
    };
    Tn = Array(12).fill(0);
    Ye = ({ visible: r5 }) => React.createElement("div", { className: "sonner-loading-wrapper", "data-visible": r5 }, React.createElement("div", { className: "sonner-spinner" }, Tn.map((n5, t5) => React.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${t5}` }))));
    bn = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" }));
    yn = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" }));
    En = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" }));
    wn = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
    je = () => {
      let [r5, n5] = React.useState(false);
      return React.useEffect(() => {
        let t5 = () => {
          n5(document.hidden);
        };
        return document.addEventListener("visibilitychange", t5), () => window.removeEventListener("visibilitychange", t5);
      }, []), r5;
    };
    ue = 1;
    fe = class {
      constructor() {
        this.subscribe = (n5) => (this.subscribers.push(n5), () => {
          let t5 = this.subscribers.indexOf(n5);
          this.subscribers.splice(t5, 1);
        });
        this.publish = (n5) => {
          this.subscribers.forEach((t5) => t5(n5));
        };
        this.addToast = (n5) => {
          this.publish(n5), this.toasts = [...this.toasts, n5];
        };
        this.create = (n5) => {
          var A4;
          let { message: t5, ...a2 } = n5, g = typeof (n5 == null ? void 0 : n5.id) == "number" || ((A4 = n5.id) == null ? void 0 : A4.length) > 0 ? n5.id : ue++, E4 = this.toasts.find((T4) => T4.id === g), y3 = n5.dismissible === void 0 ? true : n5.dismissible;
          return E4 ? this.toasts = this.toasts.map((T4) => T4.id === g ? (this.publish({ ...T4, ...n5, id: g, title: t5 }), { ...T4, ...n5, id: g, dismissible: y3, title: t5 }) : T4) : this.addToast({ title: t5, ...a2, dismissible: y3, id: g }), g;
        };
        this.dismiss = (n5) => (n5 || this.toasts.forEach((t5) => {
          this.subscribers.forEach((a2) => a2({ id: t5.id, dismiss: true }));
        }), this.subscribers.forEach((t5) => t5({ id: n5, dismiss: true })), n5);
        this.message = (n5, t5) => this.create({ ...t5, message: n5 });
        this.error = (n5, t5) => this.create({ ...t5, message: n5, type: "error" });
        this.success = (n5, t5) => this.create({ ...t5, type: "success", message: n5 });
        this.info = (n5, t5) => this.create({ ...t5, type: "info", message: n5 });
        this.warning = (n5, t5) => this.create({ ...t5, type: "warning", message: n5 });
        this.loading = (n5, t5) => this.create({ ...t5, type: "loading", message: n5 });
        this.promise = (n5, t5) => {
          if (!t5)
            return;
          let a2;
          t5.loading !== void 0 && (a2 = this.create({ ...t5, promise: n5, type: "loading", message: t5.loading, description: typeof t5.description != "function" ? t5.description : void 0 }));
          let g = n5 instanceof Promise ? n5 : n5(), E4 = a2 !== void 0;
          return g.then((y3) => {
            if (y3 && typeof y3.ok == "boolean" && !y3.ok) {
              E4 = false;
              let A4 = typeof t5.error == "function" ? t5.error(`HTTP error! status: ${y3.status}`) : t5.error, T4 = typeof t5.description == "function" ? t5.description(`HTTP error! status: ${y3.status}`) : t5.description;
              this.create({ id: a2, type: "error", message: A4, description: T4 });
            } else if (t5.success !== void 0) {
              E4 = false;
              let A4 = typeof t5.success == "function" ? t5.success(y3) : t5.success, T4 = typeof t5.description == "function" ? t5.description(y3) : t5.description;
              this.create({ id: a2, type: "success", message: A4, description: T4 });
            }
          }).catch((y3) => {
            if (t5.error !== void 0) {
              E4 = false;
              let A4 = typeof t5.error == "function" ? t5.error(y3) : t5.error, T4 = typeof t5.description == "function" ? t5.description(y3) : t5.description;
              this.create({ id: a2, type: "error", message: A4, description: T4 });
            }
          }).finally(() => {
            var y3;
            E4 && (this.dismiss(a2), a2 = void 0), (y3 = t5.finally) == null || y3.call(t5);
          }), a2;
        };
        this.custom = (n5, t5) => {
          let a2 = (t5 == null ? void 0 : t5.id) || ue++;
          return this.create({ jsx: n5(a2), id: a2, ...t5 }), a2;
        };
        this.subscribers = [], this.toasts = [];
      }
    };
    K = new fe();
    xn = (r5, n5) => {
      let t5 = (n5 == null ? void 0 : n5.id) || ue++;
      return K.addToast({ title: r5, ...n5, id: t5 }), t5;
    };
    vn = xn;
    An = Object.assign(vn, { success: K.success, info: K.info, warning: K.warning, error: K.error, custom: K.custom, message: K.message, promise: K.promise, dismiss: K.dismiss, loading: K.loading });
    me(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position="right"]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position="left"]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success],[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info],[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning],[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error],[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
    Sn = 3;
    Rn = "32px";
    Nn = 4e3;
    Dn = 356;
    In = 14;
    Cn = 20;
    Ln = 200;
    Pn = (r5) => {
      var Ot, Yt, At, _t, j3, ut, kt;
      let { invert: n5, toast: t5, unstyled: a2, interacting: g, setHeights: E4, visibleToasts: y3, heights: A4, index: T4, toasts: mt, expanded: wt, removeToast: Dt, closeButton: It, style: f3, cancelButtonStyle: st, actionButtonStyle: Ct, className: Bt = "", descriptionClassName: Ht = "", duration: pt, position: R5, gap: it, loadingIcon: k4, expandByDefault: lt2, classNames: m2, icons: z4, closeButtonAriaLabel: Ut = "Close toast", pauseWhenPageIsHidden: P5, cn: N4 } = r5, [q2, gt2] = React.useState(false), [Lt, ct] = React.useState(false), [et, xt] = React.useState(false), [W4, nt] = React.useState(false), [v4, b2] = React.useState(0), [u4, D5] = React.useState(0), p4 = React.useRef(null), C4 = React.useRef(null), w5 = T4 === 0, ht = T4 + 1 <= y3, I4 = t5.type, Y3 = t5.dismissible !== false, Tt = t5.className || "", bt = t5.descriptionClassName || "", G4 = React.useMemo(() => A4.findIndex((c2) => c2.toastId === t5.id) || 0, [A4, t5.id]), Ft = React.useMemo(() => {
        var c2;
        return (c2 = t5.closeButton) != null ? c2 : It;
      }, [t5.closeButton, It]), Mt = React.useMemo(() => t5.duration || pt || Nn, [t5.duration, pt]), ot = React.useRef(0), Z3 = React.useRef(0), vt = React.useRef(0), dt = React.useRef(null), [zt, ee2] = R5.split("-"), Pt = React.useMemo(() => A4.reduce((c2, _3, S4) => S4 >= G4 ? c2 : c2 + _3.height, 0), [A4, G4]), yt = je(), Et = t5.invert || n5, at = I4 === "loading";
      Z3.current = React.useMemo(() => G4 * it + Pt, [G4, Pt]), React.useEffect(() => {
        gt2(true);
      }, []), React.useLayoutEffect(() => {
        if (!q2)
          return;
        let c2 = C4.current, _3 = c2.style.height;
        c2.style.height = "auto";
        let S4 = c2.getBoundingClientRect().height;
        c2.style.height = _3, D5(S4), E4(($2) => $2.find((h2) => h2.toastId === t5.id) ? $2.map((h2) => h2.toastId === t5.id ? { ...h2, height: S4 } : h2) : [{ toastId: t5.id, height: S4, position: t5.position }, ...$2]);
      }, [q2, t5.title, t5.description, E4, t5.id]);
      let J3 = React.useCallback(() => {
        ct(true), b2(Z3.current), E4((c2) => c2.filter((_3) => _3.toastId !== t5.id)), setTimeout(() => {
          Dt(t5);
        }, Ln);
      }, [t5, Dt, E4, Z3]);
      React.useEffect(() => {
        if (t5.promise && I4 === "loading" || t5.duration === 1 / 0 || t5.type === "loading")
          return;
        let c2, _3 = Mt;
        return wt || g || P5 && yt ? (() => {
          if (vt.current < ot.current) {
            let V3 = (/* @__PURE__ */ new Date()).getTime() - ot.current;
            _3 = _3 - V3;
          }
          vt.current = (/* @__PURE__ */ new Date()).getTime();
        })() : (() => {
          _3 !== 1 / 0 && (ot.current = (/* @__PURE__ */ new Date()).getTime(), c2 = setTimeout(() => {
            var V3;
            (V3 = t5.onAutoClose) == null || V3.call(t5, t5), J3();
          }, _3));
        })(), () => clearTimeout(c2);
      }, [wt, g, lt2, t5, Mt, J3, t5.promise, I4, P5, yt]), React.useEffect(() => {
        let c2 = C4.current;
        if (c2) {
          let _3 = c2.getBoundingClientRect().height;
          return D5(_3), E4((S4) => [{ toastId: t5.id, height: _3, position: t5.position }, ...S4]), () => E4((S4) => S4.filter(($2) => $2.toastId !== t5.id));
        }
      }, [E4, t5.id]), React.useEffect(() => {
        t5.delete && J3();
      }, [J3, t5.delete]);
      function Kt() {
        return z4 != null && z4.loading ? React.createElement("div", { className: "sonner-loader", "data-visible": I4 === "loading" }, z4.loading) : k4 ? React.createElement("div", { className: "sonner-loader", "data-visible": I4 === "loading" }, k4) : React.createElement(Ye, { visible: I4 === "loading" });
      }
      function Wt(c2) {
        return { __html: ze.sanitize(c2) };
      }
      return React.createElement("li", { "aria-live": t5.important ? "assertive" : "polite", "aria-atomic": "true", role: "status", tabIndex: 0, ref: C4, className: N4(Bt, Tt, m2 == null ? void 0 : m2.toast, (Ot = t5 == null ? void 0 : t5.classNames) == null ? void 0 : Ot.toast, m2 == null ? void 0 : m2.default, m2 == null ? void 0 : m2[I4], (Yt = t5 == null ? void 0 : t5.classNames) == null ? void 0 : Yt[I4]), "data-sonner-toast": "", "data-styled": !(t5.jsx || t5.unstyled || a2), "data-mounted": q2, "data-promise": !!t5.promise, "data-removed": Lt, "data-visible": ht, "data-y-position": zt, "data-x-position": ee2, "data-index": T4, "data-front": w5, "data-swiping": et, "data-dismissible": Y3, "data-type": I4, "data-invert": Et, "data-swipe-out": W4, "data-expanded": !!(wt || lt2 && q2), style: { "--index": T4, "--toasts-before": T4, "--z-index": mt.length - T4, "--offset": `${Lt ? v4 : Z3.current}px`, "--initial-height": lt2 ? "auto" : `${u4}px`, ...f3, ...t5.style }, onPointerDown: (c2) => {
        at || !Y3 || (p4.current = /* @__PURE__ */ new Date(), b2(Z3.current), c2.target.setPointerCapture(c2.pointerId), c2.target.tagName !== "BUTTON" && (xt(true), dt.current = { x: c2.clientX, y: c2.clientY }));
      }, onPointerUp: () => {
        var $2, V3, h2, rt;
        if (W4 || !Y3)
          return;
        dt.current = null;
        let c2 = Number((($2 = C4.current) == null ? void 0 : $2.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), _3 = (/* @__PURE__ */ new Date()).getTime() - ((V3 = p4.current) == null ? void 0 : V3.getTime()), S4 = Math.abs(c2) / _3;
        if (Math.abs(c2) >= Cn || S4 > 0.11) {
          b2(Z3.current), (h2 = t5.onDismiss) == null || h2.call(t5, t5), J3(), nt(true);
          return;
        }
        (rt = C4.current) == null || rt.style.setProperty("--swipe-amount", "0px"), xt(false);
      }, onPointerMove: (c2) => {
        var qt;
        if (!dt.current || !Y3)
          return;
        let _3 = c2.clientY - dt.current.y, S4 = c2.clientX - dt.current.x, V3 = (zt === "top" ? Math.min : Math.max)(0, _3), h2 = c2.pointerType === "touch" ? 10 : 2;
        Math.abs(V3) > h2 ? (qt = C4.current) == null || qt.style.setProperty("--swipe-amount", `${_3}px`) : Math.abs(S4) > h2 && (dt.current = null);
      } }, Ft && !t5.jsx ? React.createElement("button", { "aria-label": Ut, "data-disabled": at, "data-close-button": true, onClick: at || !Y3 ? () => {
      } : () => {
        var c2;
        J3(), (c2 = t5.onDismiss) == null || c2.call(t5, t5);
      }, className: N4(m2 == null ? void 0 : m2.closeButton, (At = t5 == null ? void 0 : t5.classNames) == null ? void 0 : At.closeButton) }, React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null, t5.jsx || React.isValidElement(t5.title) ? t5.jsx || t5.title : React.createElement(React.Fragment, null, I4 || t5.icon || t5.promise ? React.createElement("div", { "data-icon": "", className: N4(m2 == null ? void 0 : m2.icon) }, t5.promise || t5.type === "loading" && !t5.icon ? t5.icon || Kt() : null, t5.type !== "loading" ? t5.icon || (z4 == null ? void 0 : z4[I4]) || We(I4) : null) : null, React.createElement("div", { "data-content": "", className: N4(m2 == null ? void 0 : m2.content) }, React.createElement("div", { "data-title": "", className: N4(m2 == null ? void 0 : m2.title, (_t = t5 == null ? void 0 : t5.classNames) == null ? void 0 : _t.title), dangerouslySetInnerHTML: Wt(t5.title) }), t5.description ? React.createElement("div", { "data-description": "", className: N4(Ht, bt, m2 == null ? void 0 : m2.description, (j3 = t5 == null ? void 0 : t5.classNames) == null ? void 0 : j3.description), dangerouslySetInnerHTML: Wt(t5.description) }) : null), React.isValidElement(t5.cancel) ? t5.cancel : t5.cancel && Xt(t5.cancel) ? React.createElement("button", { "data-button": true, "data-cancel": true, style: t5.cancelButtonStyle || st, onClick: (c2) => {
        Xt(t5.cancel) && Y3 && (J3(), t5.cancel.onClick(c2));
      }, className: N4(m2 == null ? void 0 : m2.cancelButton, (ut = t5 == null ? void 0 : t5.classNames) == null ? void 0 : ut.cancelButton) }, t5.cancel.label) : null, React.isValidElement(t5.action) ? t5.action : t5.action && Xt(t5.action) ? React.createElement("button", { "data-button": "", style: t5.actionButtonStyle || Ct, onClick: (c2) => {
        Xt(t5.action) && (t5.action.onClick(c2), !c2.defaultPrevented && J3());
      }, className: N4(m2 == null ? void 0 : m2.actionButton, (kt = t5 == null ? void 0 : t5.classNames) == null ? void 0 : kt.actionButton) }, t5.action.label) : null));
    };
    Jn = (r5) => {
      let { invert: n5, position: t5 = "bottom-right", hotkey: a2 = ["altKey", "KeyT"], expand: g, closeButton: E4, className: y3, offset: A4, theme: T4 = "light", richColors: mt, duration: wt, style: Dt, visibleToasts: It = Sn, toastOptions: f3, dir: st = $e(), gap: Ct = In, loadingIcon: Bt, icons: Ht, containerAriaLabel: pt = "Notifications", pauseWhenPageIsHidden: R5, cn: it = Mn } = r5, [k4, lt2] = React.useState([]), m2 = React.useMemo(() => Array.from(new Set([t5].concat(k4.filter((b2) => b2.position).map((b2) => b2.position)))), [k4, t5]), [z4, Ut] = React.useState([]), [P5, N4] = React.useState(false), [q2, gt2] = React.useState(false), [Lt, ct] = React.useState(T4 !== "system" ? T4 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), et = React.useRef(null), xt = a2.join("+").replace(/Key/g, "").replace(/Digit/g, ""), W4 = React.useRef(null), nt = React.useRef(false), v4 = React.useCallback((b2) => lt2((u4) => u4.filter(({ id: D5 }) => D5 !== b2.id)), []);
      return React.useEffect(() => K.subscribe((b2) => {
        if (b2.dismiss) {
          lt2((u4) => u4.map((D5) => D5.id === b2.id ? { ...D5, delete: true } : D5));
          return;
        }
        setTimeout(() => {
          _n.flushSync(() => {
            lt2((u4) => {
              let D5 = u4.findIndex((p4) => p4.id === b2.id);
              return D5 !== -1 ? [...u4.slice(0, D5), { ...u4[D5], ...b2 }, ...u4.slice(D5 + 1)] : [b2, ...u4];
            });
          });
        });
      }), []), React.useEffect(() => {
        if (T4 !== "system") {
          ct(T4);
          return;
        }
        T4 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? ct("dark") : ct("light")), typeof window != "undefined" && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: b2 }) => {
          ct(b2 ? "dark" : "light");
        });
      }, [T4]), React.useEffect(() => {
        k4.length <= 1 && N4(false);
      }, [k4]), React.useEffect(() => {
        let b2 = (u4) => {
          var p4, C4;
          a2.every((w5) => u4[w5] || u4.code === w5) && (N4(true), (p4 = et.current) == null || p4.focus()), u4.code === "Escape" && (document.activeElement === et.current || (C4 = et.current) != null && C4.contains(document.activeElement)) && N4(false);
        };
        return document.addEventListener("keydown", b2), () => document.removeEventListener("keydown", b2);
      }, [a2]), React.useEffect(() => {
        if (et.current)
          return () => {
            W4.current && (W4.current.focus({ preventScroll: true }), W4.current = null, nt.current = false);
          };
      }, [et.current]), k4.length ? React.createElement("section", { "aria-label": `${pt} ${xt}`, tabIndex: -1 }, m2.map((b2, u4) => {
        var C4;
        let [D5, p4] = b2.split("-");
        return React.createElement("ol", { key: b2, dir: st === "auto" ? $e() : st, tabIndex: -1, ref: et, className: y3, "data-sonner-toaster": true, "data-theme": Lt, "data-rich-colors": mt, "data-y-position": D5, "data-x-position": p4, style: { "--front-toast-height": `${((C4 = z4[0]) == null ? void 0 : C4.height) || 0}px`, "--offset": typeof A4 == "number" ? `${A4}px` : A4 || Rn, "--width": `${Dn}px`, "--gap": `${Ct}px`, ...Dt }, onBlur: (w5) => {
          nt.current && !w5.currentTarget.contains(w5.relatedTarget) && (nt.current = false, W4.current && (W4.current.focus({ preventScroll: true }), W4.current = null));
        }, onFocus: (w5) => {
          w5.target instanceof HTMLElement && w5.target.dataset.dismissible === "false" || nt.current || (nt.current = true, W4.current = w5.relatedTarget);
        }, onMouseEnter: () => N4(true), onMouseMove: () => N4(true), onMouseLeave: () => {
          q2 || N4(false);
        }, onPointerDown: (w5) => {
          w5.target instanceof HTMLElement && w5.target.dataset.dismissible === "false" || gt2(true);
        }, onPointerUp: () => gt2(false) }, k4.filter((w5) => !w5.position && u4 === 0 || w5.position === b2).map((w5, ht) => {
          var I4, Y3;
          return React.createElement(Pn, { key: w5.id, icons: Ht, index: ht, toast: w5, duration: (I4 = f3 == null ? void 0 : f3.duration) != null ? I4 : wt, className: f3 == null ? void 0 : f3.className, descriptionClassName: f3 == null ? void 0 : f3.descriptionClassName, invert: n5, visibleToasts: It, closeButton: (Y3 = f3 == null ? void 0 : f3.closeButton) != null ? Y3 : E4, interacting: q2, position: b2, style: f3 == null ? void 0 : f3.style, unstyled: f3 == null ? void 0 : f3.unstyled, classNames: f3 == null ? void 0 : f3.classNames, cancelButtonStyle: f3 == null ? void 0 : f3.cancelButtonStyle, actionButtonStyle: f3 == null ? void 0 : f3.actionButtonStyle, removeToast: v4, toasts: k4.filter((Tt) => Tt.position == w5.position), heights: z4.filter((Tt) => Tt.position == w5.position), setHeights: Ut, expandByDefault: g, gap: Ct, loadingIcon: Bt, expanded: P5, pauseWhenPageIsHidden: R5, cn: it });
        }));
      })) : null;
    };
    P2 = ["light", "dark"];
    E2 = "(prefers-color-scheme: dark)";
    L2 = reactExports.createContext(void 0);
    D2 = { setTheme: (e2) => {
    }, themes: [] };
    j = () => {
      var e2;
      return (e2 = reactExports.useContext(L2)) != null ? e2 : D2;
    };
    reactExports.memo(({ forcedTheme: e2, storageKey: a2, attribute: n5, enableSystem: g, enableColorScheme: m2, defaultTheme: c2, value: o3, attrs: y3, nonce: h2 }) => {
      let k4 = c2 === "system", w5 = n5 === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${y3.map((u4) => `'${u4}'`).join(",")})`};` : `var d=document.documentElement,n='${n5}',s='setAttribute';`, i2 = m2 ? (P2.includes(c2) ? c2 : null) ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${c2}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", d2 = (l4, u4 = false, R5 = true) => {
        let f3 = o3 ? o3[l4] : l4, p4 = u4 ? l4 + "|| ''" : `'${f3}'`, $2 = "";
        return m2 && R5 && !u4 && P2.includes(l4) && ($2 += `d.style.colorScheme = '${l4}';`), n5 === "class" ? u4 || f3 ? $2 += `c.add(${p4})` : $2 += "null" : f3 && ($2 += `d[s](n,${p4})`), $2;
      }, S4 = e2 ? `!function(){${w5}${d2(e2)}}()` : g ? `!function(){try{${w5}var e=localStorage.getItem('${a2}');if('system'===e||(!e&&${k4})){var t='${E2}',m=window.matchMedia(t);if(m.media!==t||m.matches){${d2("dark")}}else{${d2("light")}}}else if(e){${o3 ? `var x=${JSON.stringify(o3)};` : ""}${d2(o3 ? "x[e]" : "e", true)}}${k4 ? "" : "else{" + d2(c2, false, false) + "}"}${i2}}catch(e){}}()` : `!function(){try{${w5}var e=localStorage.getItem('${a2}');if(e){${o3 ? `var x=${JSON.stringify(o3)};` : ""}${d2(o3 ? "x[e]" : "e", true)}}else{${d2(c2, false, false)};}${i2}}catch(t){}}();`;
      return reactExports.createElement("script", { nonce: h2, dangerouslySetInnerHTML: { __html: S4 } });
    });
    Toaster = ({ ...props }) => {
      const { theme = "system" } = j();
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        Jn,
        {
          theme,
          className: "toaster group",
          toastOptions: {
            classNames: {
              toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
              description: "group-[.toast]:text-muted-foreground",
              actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
              cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
            }
          },
          ...props
        }
      );
    };
    $$Astro = createAstro();
    $$Cvs = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
      Astro2.self = $$Cvs;
      return renderTemplate`${renderComponent($$result, "BaseLayout", $$Base, { "title": "Diaz Cadenas - Curriculums", "classNames": "min-h-screen items-center" }, { "default": ($$result2) => renderTemplate` ${maybeRenderHead()}<div class="container min-h-screen overflow-hidden"> ${renderComponent($$result2, "CVTableIsland", CVTableIsland, { "client:load": true, "client:component-hydration": "load", "client:component-path": "@/components/cv-table/table.island", "client:component-export": "default" })} </div> ` })}`;
    }, "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/cvs.astro", void 0);
    $$file = "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/cvs.astro";
    $$url = "/cvs";
    cvs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Cvs,
      file: $$file,
      url: $$url
    }, Symbol.toStringTag, { value: "Module" }));
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/vnode-children_Gh7ykD0n.mjs
var vnode_children_Gh7ykD0n_exports = {};
__export(vnode_children_Gh7ykD0n_exports, {
  default: () => convert
});
function P3(e2) {
  let t5 = {}, a2;
  if (e2)
    for (_2.lastIndex = 0, e2 = " " + (e2 || "") + " "; a2 = _2.exec(e2); )
      a2[0] !== " " && (t5[a2[1]] = a2[3]);
  return t5;
}
function w3(e2) {
  let t5 = typeof e2 == "string" ? e2 : e2.value, a2, r5, n5, i2, l4, d2, g, h2, s3, c2 = [];
  o.lastIndex = 0, r5 = a2 = { type: 0, children: [] };
  let E4 = 0;
  function m2() {
    i2 = t5.substring(E4, o.lastIndex - n5[0].length), i2 && r5.children.push({ type: 2, value: i2, parent: r5 });
  }
  for (; n5 = o.exec(t5); ) {
    if (d2 = n5[5] || n5[8], g = n5[6] || n5[9], h2 = n5[7] || n5[10], x2.has(r5.name) && n5[2] !== r5.name) {
      l4 = o.lastIndex - n5[0].length, r5.children.length > 0 && (r5.children[0].value += n5[0]);
      continue;
    } else if (d2 === "<!--") {
      if (l4 = o.lastIndex - n5[0].length, x2.has(r5.name))
        continue;
      s3 = { type: 3, value: g, parent: r5, loc: [{ start: l4, end: l4 + d2.length }, { start: o.lastIndex - h2.length, end: o.lastIndex }] }, c2.push(s3), s3.parent.children.push(s3);
    } else if (d2 === "<!")
      l4 = o.lastIndex - n5[0].length, s3 = { type: 4, value: g, parent: r5, loc: [{ start: l4, end: l4 + d2.length }, { start: o.lastIndex - h2.length, end: o.lastIndex }] }, c2.push(s3), s3.parent.children.push(s3);
    else if (n5[1] !== "/")
      if (m2(), x2.has(r5.name)) {
        E4 = o.lastIndex, m2();
        continue;
      } else
        s3 = { type: 1, name: n5[2] + "", attributes: P3(n5[3]), parent: r5, children: [], loc: [{ start: o.lastIndex - n5[0].length, end: o.lastIndex }] }, c2.push(s3), s3.parent.children.push(s3), n5[4] && n5[4].indexOf("/") > -1 || D3.has(s3.name) ? (s3.loc[1] = s3.loc[0], s3.isSelfClosingTag = true) : r5 = s3;
    else
      m2(), n5[2] + "" === r5.name ? (s3 = r5, r5 = s3.parent, s3.loc.push({ start: o.lastIndex - n5[0].length, end: o.lastIndex }), i2 = t5.substring(s3.loc[0].end, s3.loc[1].start), s3.children.length === 0 && s3.children.push({ type: 2, value: i2, parent: r5 })) : n5[2] + "" === c2[c2.length - 1].name && c2[c2.length - 1].isSelfClosingTag === true && (s3 = c2[c2.length - 1], s3.loc.push({ start: o.lastIndex - n5[0].length, end: o.lastIndex }));
    E4 = o.lastIndex;
  }
  return i2 = t5.slice(E4), r5.children.push({ type: 2, value: i2, parent: r5 }), a2;
}
function convert(children) {
  let doc = w3(children.toString().trim());
  let id3 = ids++;
  let key = 0;
  function createReactElementFromNode(node) {
    const childVnodes = Array.isArray(node.children) && node.children.length ? node.children.map((child) => createReactElementFromNode(child)).filter(Boolean) : void 0;
    if (node.type === R3) {
      return reactExports.createElement(reactExports.Fragment, {}, childVnodes);
    } else if (node.type === k2) {
      const { class: className, ...props } = node.attributes;
      return reactExports.createElement(node.name, { ...props, className, key: `${id3}-${key++}` }, childVnodes);
    } else if (node.type === j2) {
      return node.value.trim() ? node.value : void 0;
    }
  }
  const root = createReactElementFromNode(doc);
  return root.props.children;
}
var R3, k2, j2, D3, x2, _2, o, ids;
var init_vnode_children_Gh7ykD0n = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/vnode-children_Gh7ykD0n.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_cvs_qudRXU8T();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    R3 = 0;
    k2 = 1;
    j2 = 2;
    D3 = /* @__PURE__ */ new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
    x2 = /* @__PURE__ */ new Set(["script", "style"]);
    _2 = /([\@\.a-z0-9_\:\-]*)\s*?=?\s*?(['"]?)([\s\S]*?)\2\s+/gim;
    o = /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:-]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!)([\s\S]*?)(>))/gm;
    ids = 0;
  }
});

// .wrangler/tmp/pages-KkpaTB/renderers.mjs
function l$22(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function ja$1(a2) {
  if (p$12.call(ia$1, a2))
    return true;
  if (p$12.call(ha$1, a2))
    return false;
  if (fa$1.test(a2))
    return ia$1[a2] = true;
  ha$1[a2] = true;
  return false;
}
function r4(a2, b2, c2, d2, f3, e2, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = f3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = e2;
  this.removeEmptyString = g;
}
function la$1(a2) {
  return a2[1].toUpperCase();
}
function v3(a2) {
  if ("boolean" === typeof a2 || "number" === typeof a2)
    return "" + a2;
  a2 = "" + a2;
  var b2 = na.exec(a2);
  if (b2) {
    var c2 = "", d2, f3 = 0;
    for (d2 = b2.index; d2 < a2.length; d2++) {
      switch (a2.charCodeAt(d2)) {
        case 34:
          b2 = "&quot;";
          break;
        case 38:
          b2 = "&amp;";
          break;
        case 39:
          b2 = "&#x27;";
          break;
        case 60:
          b2 = "&lt;";
          break;
        case 62:
          b2 = "&gt;";
          break;
        default:
          continue;
      }
      f3 !== d2 && (c2 += a2.substring(f3, d2));
      f3 = d2 + 1;
      c2 += b2;
    }
    a2 = f3 !== d2 ? c2 + a2.substring(f3, d2) : c2;
  }
  return a2;
}
function w$1(a2, b2) {
  return { insertionMode: a2, selectedValue: b2 };
}
function ra$1(a2, b2, c2) {
  switch (b2) {
    case "select":
      return w$1(1, null != c2.value ? c2.value : c2.defaultValue);
    case "svg":
      return w$1(2, null);
    case "math":
      return w$1(3, null);
    case "foreignObject":
      return w$1(1, null);
    case "table":
      return w$1(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return w$1(5, null);
    case "colgroup":
      return w$1(7, null);
    case "tr":
      return w$1(6, null);
  }
  return 4 <= a2.insertionMode || 0 === a2.insertionMode ? w$1(1, null) : a2;
}
function ta$1(a2, b2, c2) {
  if ("object" !== typeof c2)
    throw Error(l$22(62));
  b2 = true;
  for (var d2 in c2)
    if (p$12.call(c2, d2)) {
      var f3 = c2[d2];
      if (null != f3 && "boolean" !== typeof f3 && "" !== f3) {
        if (0 === d2.indexOf("--")) {
          var e2 = v3(d2);
          f3 = v3(("" + f3).trim());
        } else {
          e2 = d2;
          var g = sa$1.get(e2);
          void 0 !== g ? e2 = g : (g = v3(e2.replace(oa$1, "-$1").toLowerCase().replace(pa$1, "-ms-")), sa$1.set(e2, g), e2 = g);
          f3 = "number" === typeof f3 ? 0 === f3 || p$12.call(u$12, d2) ? "" + f3 : f3 + "px" : v3(("" + f3).trim());
        }
        b2 ? (b2 = false, a2.push(' style="', e2, ":", f3)) : a2.push(";", e2, ":", f3);
      }
    }
  b2 || a2.push('"');
}
function x$1(a2, b2, c2, d2) {
  switch (c2) {
    case "style":
      ta$1(a2, b2, d2);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
    if (b2 = t$13.hasOwnProperty(c2) ? t$13[c2] : null, null !== b2) {
      switch (typeof d2) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b2.acceptsBooleans)
            return;
      }
      c2 = b2.attributeName;
      switch (b2.type) {
        case 3:
          d2 && a2.push(" ", c2, '=""');
          break;
        case 4:
          true === d2 ? a2.push(" ", c2, '=""') : false !== d2 && a2.push(" ", c2, '="', v3(d2), '"');
          break;
        case 5:
          isNaN(d2) || a2.push(" ", c2, '="', v3(d2), '"');
          break;
        case 6:
          !isNaN(d2) && 1 <= d2 && a2.push(" ", c2, '="', v3(d2), '"');
          break;
        default:
          b2.sanitizeURL && (d2 = "" + d2), a2.push(" ", c2, '="', v3(d2), '"');
      }
    } else if (ja$1(c2)) {
      switch (typeof d2) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b2 = c2.toLowerCase().slice(0, 5), "data-" !== b2 && "aria-" !== b2)
            return;
      }
      a2.push(" ", c2, '="', v3(d2), '"');
    }
  }
}
function y$1(a2, b2, c2) {
  if (null != b2) {
    if (null != c2)
      throw Error(l$22(60));
    if ("object" !== typeof b2 || !("__html" in b2))
      throw Error(l$22(61));
    b2 = b2.__html;
    null !== b2 && void 0 !== b2 && a2.push("" + b2);
  }
}
function ua$1(a2) {
  var b2 = "";
  aa$1.Children.forEach(a2, function(a3) {
    null != a3 && (b2 += a3);
  });
  return b2;
}
function va$1(a2, b2, c2, d2) {
  a2.push(A3(c2));
  var f3 = c2 = null, e2;
  for (e2 in b2)
    if (p$12.call(b2, e2)) {
      var g = b2[e2];
      if (null != g)
        switch (e2) {
          case "children":
            c2 = g;
            break;
          case "dangerouslySetInnerHTML":
            f3 = g;
            break;
          default:
            x$1(a2, d2, e2, g);
        }
    }
  a2.push(">");
  y$1(a2, f3, c2);
  return "string" === typeof c2 ? (a2.push(v3(c2)), null) : c2;
}
function A3(a2) {
  var b2 = xa$1.get(a2);
  if (void 0 === b2) {
    if (!wa$1.test(a2))
      throw Error(l$22(65, a2));
    b2 = "<" + a2;
    xa$1.set(a2, b2);
  }
  return b2;
}
function ya$1(a2, b2, c2, d2, f3) {
  switch (b2) {
    case "select":
      a2.push(A3("select"));
      var e2 = null, g = null;
      for (n5 in c2)
        if (p$12.call(c2, n5)) {
          var h2 = c2[n5];
          if (null != h2)
            switch (n5) {
              case "children":
                e2 = h2;
                break;
              case "dangerouslySetInnerHTML":
                g = h2;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                x$1(a2, d2, n5, h2);
            }
        }
      a2.push(">");
      y$1(a2, g, e2);
      return e2;
    case "option":
      g = f3.selectedValue;
      a2.push(A3("option"));
      var k4 = h2 = null, m2 = null;
      var n5 = null;
      for (e2 in c2)
        if (p$12.call(c2, e2)) {
          var q2 = c2[e2];
          if (null != q2)
            switch (e2) {
              case "children":
                h2 = q2;
                break;
              case "selected":
                m2 = q2;
                break;
              case "dangerouslySetInnerHTML":
                n5 = q2;
                break;
              case "value":
                k4 = q2;
              default:
                x$1(a2, d2, e2, q2);
            }
        }
      if (null != g)
        if (c2 = null !== k4 ? "" + k4 : ua$1(h2), qa$1(g))
          for (d2 = 0; d2 < g.length; d2++) {
            if ("" + g[d2] === c2) {
              a2.push(' selected=""');
              break;
            }
          }
        else
          "" + g === c2 && a2.push(' selected=""');
      else
        m2 && a2.push(' selected=""');
      a2.push(">");
      y$1(a2, n5, h2);
      return h2;
    case "textarea":
      a2.push(A3("textarea"));
      n5 = g = e2 = null;
      for (h2 in c2)
        if (p$12.call(c2, h2) && (k4 = c2[h2], null != k4))
          switch (h2) {
            case "children":
              n5 = k4;
              break;
            case "value":
              e2 = k4;
              break;
            case "defaultValue":
              g = k4;
              break;
            case "dangerouslySetInnerHTML":
              throw Error(l$22(91));
            default:
              x$1(
                a2,
                d2,
                h2,
                k4
              );
          }
      null === e2 && null !== g && (e2 = g);
      a2.push(">");
      if (null != n5) {
        if (null != e2)
          throw Error(l$22(92));
        if (qa$1(n5) && 1 < n5.length)
          throw Error(l$22(93));
        e2 = "" + n5;
      }
      "string" === typeof e2 && "\n" === e2[0] && a2.push("\n");
      null !== e2 && a2.push(v3("" + e2));
      return null;
    case "input":
      a2.push(A3("input"));
      k4 = n5 = h2 = e2 = null;
      for (g in c2)
        if (p$12.call(c2, g) && (m2 = c2[g], null != m2))
          switch (g) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(l$22(399, "input"));
            case "defaultChecked":
              k4 = m2;
              break;
            case "defaultValue":
              h2 = m2;
              break;
            case "checked":
              n5 = m2;
              break;
            case "value":
              e2 = m2;
              break;
            default:
              x$1(a2, d2, g, m2);
          }
      null !== n5 ? x$1(a2, d2, "checked", n5) : null !== k4 && x$1(a2, d2, "checked", k4);
      null !== e2 ? x$1(a2, d2, "value", e2) : null !== h2 && x$1(a2, d2, "value", h2);
      a2.push("/>");
      return null;
    case "menuitem":
      a2.push(A3("menuitem"));
      for (var C4 in c2)
        if (p$12.call(c2, C4) && (e2 = c2[C4], null != e2))
          switch (C4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(l$22(400));
            default:
              x$1(a2, d2, C4, e2);
          }
      a2.push(">");
      return null;
    case "title":
      a2.push(A3("title"));
      e2 = null;
      for (q2 in c2)
        if (p$12.call(c2, q2) && (g = c2[q2], null != g))
          switch (q2) {
            case "children":
              e2 = g;
              break;
            case "dangerouslySetInnerHTML":
              throw Error(l$22(434));
            default:
              x$1(a2, d2, q2, g);
          }
      a2.push(">");
      return e2;
    case "listing":
    case "pre":
      a2.push(A3(b2));
      g = e2 = null;
      for (k4 in c2)
        if (p$12.call(c2, k4) && (h2 = c2[k4], null != h2))
          switch (k4) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g = h2;
              break;
            default:
              x$1(a2, d2, k4, h2);
          }
      a2.push(">");
      if (null != g) {
        if (null != e2)
          throw Error(l$22(60));
        if ("object" !== typeof g || !("__html" in g))
          throw Error(l$22(61));
        c2 = g.__html;
        null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a2.push("\n", c2) : a2.push("" + c2));
      }
      "string" === typeof e2 && "\n" === e2[0] && a2.push("\n");
      return e2;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a2.push(A3(b2));
      for (var D5 in c2)
        if (p$12.call(c2, D5) && (e2 = c2[D5], null != e2))
          switch (D5) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(l$22(399, b2));
            default:
              x$1(a2, d2, D5, e2);
          }
      a2.push("/>");
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return va$1(
        a2,
        c2,
        b2,
        d2
      );
    case "html":
      return 0 === f3.insertionMode && a2.push("<!DOCTYPE html>"), va$1(a2, c2, b2, d2);
    default:
      if (-1 === b2.indexOf("-") && "string" !== typeof c2.is)
        return va$1(a2, c2, b2, d2);
      a2.push(A3(b2));
      g = e2 = null;
      for (m2 in c2)
        if (p$12.call(c2, m2) && (h2 = c2[m2], null != h2))
          switch (m2) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g = h2;
              break;
            case "style":
              ta$1(a2, d2, h2);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ja$1(m2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a2.push(" ", m2, '="', v3(h2), '"');
          }
      a2.push(">");
      y$1(a2, g, e2);
      return e2;
  }
}
function za$1(a2, b2, c2) {
  a2.push('<!--$?--><template id="');
  if (null === c2)
    throw Error(l$22(395));
  a2.push(c2);
  return a2.push('"></template>');
}
function Aa$1(a2, b2, c2, d2) {
  switch (c2.insertionMode) {
    case 0:
    case 1:
      return a2.push('<div hidden id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 2:
      return a2.push('<svg aria-hidden="true" style="display:none" id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 3:
      return a2.push('<math aria-hidden="true" style="display:none" id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 4:
      return a2.push('<table hidden id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 5:
      return a2.push('<table hidden><tbody id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 6:
      return a2.push('<table hidden><tr id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    case 7:
      return a2.push('<table hidden><colgroup id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
    default:
      throw Error(l$22(397));
  }
}
function Ba$1(a2, b2) {
  switch (b2.insertionMode) {
    case 0:
    case 1:
      return a2.push("</div>");
    case 2:
      return a2.push("</svg>");
    case 3:
      return a2.push("</math>");
    case 4:
      return a2.push("</table>");
    case 5:
      return a2.push("</tbody></table>");
    case 6:
      return a2.push("</tr></table>");
    case 7:
      return a2.push("</colgroup></table>");
    default:
      throw Error(l$22(397));
  }
}
function Da$1(a2) {
  return JSON.stringify(a2).replace(Ca$1, function(a3) {
    switch (a3) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function Ea$1(a2, b2) {
  b2 = void 0 === b2 ? "" : b2;
  return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b2 + "P:", segmentPrefix: b2 + "S:", boundaryPrefix: b2 + "B:", idPrefix: b2, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a2 };
}
function Fa$1(a2, b2, c2, d2) {
  if (c2.generateStaticMarkup)
    return a2.push(v3(b2)), false;
  "" === b2 ? a2 = d2 : (d2 && a2.push("<!-- -->"), a2.push(v3(b2)), a2 = true);
  return a2;
}
function Xa$1(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case Ia$1:
      return "Fragment";
    case Ha$1:
      return "Portal";
    case Ka$1:
      return "Profiler";
    case Ja$1:
      return "StrictMode";
    case Oa$1:
      return "Suspense";
    case Pa$1:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ma$1:
        return (a2.displayName || "Context") + ".Consumer";
      case La$1:
        return (a2._context.displayName || "Context") + ".Provider";
      case Na$1:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Qa$1:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Xa$1(a2.type) || "Memo";
      case Ra$1:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Xa$1(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Za$1(a2, b2) {
  a2 = a2.contextTypes;
  if (!a2)
    return Ya$1;
  var c2 = {}, d2;
  for (d2 in a2)
    c2[d2] = b2[d2];
  return c2;
}
function F3(a2, b2) {
  if (a2 !== b2) {
    a2.context._currentValue2 = a2.parentValue;
    a2 = a2.parent;
    var c2 = b2.parent;
    if (null === a2) {
      if (null !== c2)
        throw Error(l$22(401));
    } else {
      if (null === c2)
        throw Error(l$22(401));
      F3(a2, c2);
    }
    b2.context._currentValue2 = b2.value;
  }
}
function $a$1(a2) {
  a2.context._currentValue2 = a2.parentValue;
  a2 = a2.parent;
  null !== a2 && $a$1(a2);
}
function ab$1(a2) {
  var b2 = a2.parent;
  null !== b2 && ab$1(b2);
  a2.context._currentValue2 = a2.value;
}
function bb$1(a2, b2) {
  a2.context._currentValue2 = a2.parentValue;
  a2 = a2.parent;
  if (null === a2)
    throw Error(l$22(402));
  a2.depth === b2.depth ? F3(a2, b2) : bb$1(a2, b2);
}
function cb$1(a2, b2) {
  var c2 = b2.parent;
  if (null === c2)
    throw Error(l$22(402));
  a2.depth === c2.depth ? F3(a2, c2) : cb$1(a2, c2);
  b2.context._currentValue2 = b2.value;
}
function G3(a2) {
  var b2 = E$12;
  b2 !== a2 && (null === b2 ? ab$1(a2) : null === a2 ? $a$1(b2) : b2.depth === a2.depth ? F3(b2, a2) : b2.depth > a2.depth ? bb$1(b2, a2) : cb$1(b2, a2), E$12 = a2);
}
function eb$1(a2, b2, c2, d2) {
  var f3 = void 0 !== a2.state ? a2.state : null;
  a2.updater = db$1;
  a2.props = c2;
  a2.state = f3;
  var e2 = { queue: [], replace: false };
  a2._reactInternals = e2;
  var g = b2.contextType;
  a2.context = "object" === typeof g && null !== g ? g._currentValue2 : d2;
  g = b2.getDerivedStateFromProps;
  "function" === typeof g && (g = g(c2, f3), f3 = null === g || void 0 === g ? f3 : B$12({}, f3, g), a2.state = f3);
  if ("function" !== typeof b2.getDerivedStateFromProps && "function" !== typeof a2.getSnapshotBeforeUpdate && ("function" === typeof a2.UNSAFE_componentWillMount || "function" === typeof a2.componentWillMount))
    if (b2 = a2.state, "function" === typeof a2.componentWillMount && a2.componentWillMount(), "function" === typeof a2.UNSAFE_componentWillMount && a2.UNSAFE_componentWillMount(), b2 !== a2.state && db$1.enqueueReplaceState(a2, a2.state, null), null !== e2.queue && 0 < e2.queue.length)
      if (b2 = e2.queue, g = e2.replace, e2.queue = null, e2.replace = false, g && 1 === b2.length)
        a2.state = b2[0];
      else {
        e2 = g ? b2[0] : a2.state;
        f3 = true;
        for (g = g ? 1 : 0; g < b2.length; g++) {
          var h2 = b2[g];
          h2 = "function" === typeof h2 ? h2.call(a2, e2, c2, d2) : h2;
          null != h2 && (f3 ? (f3 = false, e2 = B$12({}, e2, h2)) : B$12(e2, h2));
        }
        a2.state = e2;
      }
    else
      e2.queue = null;
}
function gb$1(a2, b2, c2) {
  var d2 = a2.id;
  a2 = a2.overflow;
  var f3 = 32 - H$12(d2) - 1;
  d2 &= ~(1 << f3);
  c2 += 1;
  var e2 = 32 - H$12(b2) + f3;
  if (30 < e2) {
    var g = f3 - f3 % 5;
    e2 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    f3 -= g;
    return { id: 1 << 32 - H$12(b2) + f3 | c2 << f3 | d2, overflow: e2 + a2 };
  }
  return { id: 1 << e2 | c2 << f3 | d2, overflow: a2 };
}
function hb$1(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (ib$1(a2) / jb$1 | 0) | 0;
}
function kb$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
function Q$12() {
  if (null === I$12)
    throw Error(l$22(321));
  return I$12;
}
function pb$1() {
  if (0 < P$12)
    throw Error(l$22(312));
  return { memoizedState: null, queue: null, next: null };
}
function qb$1() {
  null === K$12 ? null === J$1 ? (L$12 = false, J$1 = K$12 = pb$1()) : (L$12 = true, K$12 = J$1) : null === K$12.next ? (L$12 = false, K$12 = K$12.next = pb$1()) : (L$12 = true, K$12 = K$12.next);
  return K$12;
}
function rb$1() {
  ob$1 = I$12 = null;
  M$12 = false;
  J$1 = null;
  P$12 = 0;
  K$12 = O$12 = null;
}
function sb$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function tb$1(a2, b2, c2) {
  I$12 = Q$12();
  K$12 = qb$1();
  if (L$12) {
    var d2 = K$12.queue;
    b2 = d2.dispatch;
    if (null !== O$12 && (c2 = O$12.get(d2), void 0 !== c2)) {
      O$12.delete(d2);
      d2 = K$12.memoizedState;
      do
        d2 = a2(d2, c2.action), c2 = c2.next;
      while (null !== c2);
      K$12.memoizedState = d2;
      return [d2, b2];
    }
    return [K$12.memoizedState, b2];
  }
  a2 = a2 === sb$1 ? "function" === typeof b2 ? b2() : b2 : void 0 !== c2 ? c2(b2) : b2;
  K$12.memoizedState = a2;
  a2 = K$12.queue = { last: null, dispatch: null };
  a2 = a2.dispatch = ub$1.bind(null, I$12, a2);
  return [K$12.memoizedState, a2];
}
function vb$1(a2, b2) {
  I$12 = Q$12();
  K$12 = qb$1();
  b2 = void 0 === b2 ? null : b2;
  if (null !== K$12) {
    var c2 = K$12.memoizedState;
    if (null !== c2 && null !== b2) {
      var d2 = c2[1];
      a:
        if (null === d2)
          d2 = false;
        else {
          for (var f3 = 0; f3 < d2.length && f3 < b2.length; f3++)
            if (!lb$1(b2[f3], d2[f3])) {
              d2 = false;
              break a;
            }
          d2 = true;
        }
      if (d2)
        return c2[0];
    }
  }
  a2 = a2();
  K$12.memoizedState = [a2, b2];
  return a2;
}
function ub$1(a2, b2, c2) {
  if (25 <= P$12)
    throw Error(l$22(301));
  if (a2 === I$12)
    if (M$12 = true, a2 = { action: c2, next: null }, null === O$12 && (O$12 = /* @__PURE__ */ new Map()), c2 = O$12.get(b2), void 0 === c2)
      O$12.set(b2, a2);
    else {
      for (b2 = c2; null !== b2.next; )
        b2 = b2.next;
      b2.next = a2;
    }
}
function wb$1() {
  throw Error(l$22(394));
}
function R$12() {
}
function zb$1(a2) {
  console.error(a2);
  return null;
}
function T$12() {
}
function Ab$1(a2, b2, c2, d2, f3, e2, g, h2, k4) {
  var m2 = [], n5 = /* @__PURE__ */ new Set();
  b2 = { destination: null, responseState: b2, progressiveChunkSize: void 0 === d2 ? 12800 : d2, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: n5, pingedTasks: m2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f3 ? zb$1 : f3, onAllReady: void 0 === e2 ? T$12 : e2, onShellReady: void 0 === g ? T$12 : g, onShellError: void 0 === h2 ? T$12 : h2, onFatalError: void 0 === k4 ? T$12 : k4 };
  c2 = U$12(b2, 0, null, c2, false, false);
  c2.parentFlushed = true;
  a2 = Bb$1(b2, a2, null, c2, n5, Ya$1, null, fb$1);
  m2.push(a2);
  return b2;
}
function Bb$1(a2, b2, c2, d2, f3, e2, g, h2) {
  a2.allPendingTasks++;
  null === c2 ? a2.pendingRootTasks++ : c2.pendingTasks++;
  var k4 = { node: b2, ping: function() {
    var b3 = a2.pingedTasks;
    b3.push(k4);
    1 === b3.length && Cb$1(a2);
  }, blockedBoundary: c2, blockedSegment: d2, abortSet: f3, legacyContext: e2, context: g, treeContext: h2 };
  f3.add(k4);
  return k4;
}
function U$12(a2, b2, c2, d2, f3, e2) {
  return { status: 0, id: -1, index: b2, parentFlushed: false, chunks: [], children: [], formatContext: d2, boundary: c2, lastPushedText: f3, textEmbedded: e2 };
}
function V$12(a2, b2) {
  a2 = a2.onError(b2);
  if (null != a2 && "string" !== typeof a2)
    throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a2 + '" instead');
  return a2;
}
function W$12(a2, b2) {
  var c2 = a2.onShellError;
  c2(b2);
  c2 = a2.onFatalError;
  c2(b2);
  null !== a2.destination ? (a2.status = 2, a2.destination.destroy(b2)) : (a2.status = 1, a2.fatalError = b2);
}
function Db$1(a2, b2, c2, d2, f3) {
  I$12 = {};
  ob$1 = b2;
  N$12 = 0;
  for (a2 = c2(d2, f3); M$12; )
    M$12 = false, N$12 = 0, P$12 += 1, K$12 = null, a2 = c2(d2, f3);
  rb$1();
  return a2;
}
function Eb$1(a2, b2, c2, d2) {
  var f3 = c2.render(), e2 = d2.childContextTypes;
  if (null !== e2 && void 0 !== e2) {
    var g = b2.legacyContext;
    if ("function" !== typeof c2.getChildContext)
      d2 = g;
    else {
      c2 = c2.getChildContext();
      for (var h2 in c2)
        if (!(h2 in e2))
          throw Error(l$22(108, Xa$1(d2) || "Unknown", h2));
      d2 = B$12({}, g, c2);
    }
    b2.legacyContext = d2;
    X$12(a2, b2, f3);
    b2.legacyContext = g;
  } else
    X$12(a2, b2, f3);
}
function Fb2(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = B$12({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Gb$1(a2, b2, c2, d2, f3) {
  if ("function" === typeof c2)
    if (c2.prototype && c2.prototype.isReactComponent) {
      f3 = Za$1(c2, b2.legacyContext);
      var e2 = c2.contextType;
      e2 = new c2(d2, "object" === typeof e2 && null !== e2 ? e2._currentValue2 : f3);
      eb$1(e2, c2, d2, f3);
      Eb$1(a2, b2, e2, c2);
    } else {
      e2 = Za$1(c2, b2.legacyContext);
      f3 = Db$1(a2, b2, c2, d2, e2);
      var g = 0 !== N$12;
      if ("object" === typeof f3 && null !== f3 && "function" === typeof f3.render && void 0 === f3.$$typeof)
        eb$1(f3, c2, d2, e2), Eb$1(a2, b2, f3, c2);
      else if (g) {
        d2 = b2.treeContext;
        b2.treeContext = gb$1(d2, 1, 0);
        try {
          X$12(a2, b2, f3);
        } finally {
          b2.treeContext = d2;
        }
      } else
        X$12(a2, b2, f3);
    }
  else if ("string" === typeof c2) {
    f3 = b2.blockedSegment;
    e2 = ya$1(f3.chunks, c2, d2, a2.responseState, f3.formatContext);
    f3.lastPushedText = false;
    g = f3.formatContext;
    f3.formatContext = ra$1(g, c2, d2);
    Hb$1(a2, b2, e2);
    f3.formatContext = g;
    switch (c2) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f3.chunks.push("</", c2, ">");
    }
    f3.lastPushedText = false;
  } else {
    switch (c2) {
      case Ua$1:
      case Ta$1:
      case Ja$1:
      case Ka$1:
      case Ia$1:
        X$12(a2, b2, d2.children);
        return;
      case Pa$1:
        X$12(a2, b2, d2.children);
        return;
      case Sa$1:
        throw Error(l$22(343));
      case Oa$1:
        a: {
          c2 = b2.blockedBoundary;
          f3 = b2.blockedSegment;
          e2 = d2.fallback;
          d2 = d2.children;
          g = /* @__PURE__ */ new Set();
          var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, k4 = U$12(a2, f3.chunks.length, h2, f3.formatContext, false, false);
          f3.children.push(k4);
          f3.lastPushedText = false;
          var m2 = U$12(a2, 0, null, f3.formatContext, false, false);
          m2.parentFlushed = true;
          b2.blockedBoundary = h2;
          b2.blockedSegment = m2;
          try {
            if (Hb$1(
              a2,
              b2,
              d2
            ), a2.responseState.generateStaticMarkup || m2.lastPushedText && m2.textEmbedded && m2.chunks.push("<!-- -->"), m2.status = 1, Y$1(h2, m2), 0 === h2.pendingTasks)
              break a;
          } catch (n5) {
            m2.status = 4, h2.forceClientRender = true, h2.errorDigest = V$12(a2, n5);
          } finally {
            b2.blockedBoundary = c2, b2.blockedSegment = f3;
          }
          b2 = Bb$1(a2, e2, c2, k4, g, b2.legacyContext, b2.context, b2.treeContext);
          a2.pingedTasks.push(b2);
        }
        return;
    }
    if ("object" === typeof c2 && null !== c2)
      switch (c2.$$typeof) {
        case Na$1:
          d2 = Db$1(a2, b2, c2.render, d2, f3);
          if (0 !== N$12) {
            c2 = b2.treeContext;
            b2.treeContext = gb$1(c2, 1, 0);
            try {
              X$12(a2, b2, d2);
            } finally {
              b2.treeContext = c2;
            }
          } else
            X$12(a2, b2, d2);
          return;
        case Qa$1:
          c2 = c2.type;
          d2 = Fb2(c2, d2);
          Gb$1(a2, b2, c2, d2, f3);
          return;
        case La$1:
          f3 = d2.children;
          c2 = c2._context;
          d2 = d2.value;
          e2 = c2._currentValue2;
          c2._currentValue2 = d2;
          g = E$12;
          E$12 = d2 = { parent: g, depth: null === g ? 0 : g.depth + 1, context: c2, parentValue: e2, value: d2 };
          b2.context = d2;
          X$12(a2, b2, f3);
          a2 = E$12;
          if (null === a2)
            throw Error(l$22(403));
          d2 = a2.parentValue;
          a2.context._currentValue2 = d2 === Va$1 ? a2.context._defaultValue : d2;
          a2 = E$12 = a2.parent;
          b2.context = a2;
          return;
        case Ma$1:
          d2 = d2.children;
          d2 = d2(c2._currentValue2);
          X$12(a2, b2, d2);
          return;
        case Ra$1:
          f3 = c2._init;
          c2 = f3(c2._payload);
          d2 = Fb2(c2, d2);
          Gb$1(
            a2,
            b2,
            c2,
            d2,
            void 0
          );
          return;
      }
    throw Error(l$22(130, null == c2 ? c2 : typeof c2, ""));
  }
}
function X$12(a2, b2, c2) {
  b2.node = c2;
  if ("object" === typeof c2 && null !== c2) {
    switch (c2.$$typeof) {
      case Ga$1:
        Gb$1(a2, b2, c2.type, c2.props, c2.ref);
        return;
      case Ha$1:
        throw Error(l$22(257));
      case Ra$1:
        var d2 = c2._init;
        c2 = d2(c2._payload);
        X$12(a2, b2, c2);
        return;
    }
    if (qa$1(c2)) {
      Ib$1(a2, b2, c2);
      return;
    }
    null === c2 || "object" !== typeof c2 ? d2 = null : (d2 = Wa$1 && c2[Wa$1] || c2["@@iterator"], d2 = "function" === typeof d2 ? d2 : null);
    if (d2 && (d2 = d2.call(c2))) {
      c2 = d2.next();
      if (!c2.done) {
        var f3 = [];
        do
          f3.push(c2.value), c2 = d2.next();
        while (!c2.done);
        Ib$1(a2, b2, f3);
      }
      return;
    }
    a2 = Object.prototype.toString.call(c2);
    throw Error(l$22(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a2));
  }
  "string" === typeof c2 ? (d2 = b2.blockedSegment, d2.lastPushedText = Fa$1(b2.blockedSegment.chunks, c2, a2.responseState, d2.lastPushedText)) : "number" === typeof c2 && (d2 = b2.blockedSegment, d2.lastPushedText = Fa$1(b2.blockedSegment.chunks, "" + c2, a2.responseState, d2.lastPushedText));
}
function Ib$1(a2, b2, c2) {
  for (var d2 = c2.length, f3 = 0; f3 < d2; f3++) {
    var e2 = b2.treeContext;
    b2.treeContext = gb$1(e2, d2, f3);
    try {
      Hb$1(a2, b2, c2[f3]);
    } finally {
      b2.treeContext = e2;
    }
  }
}
function Hb$1(a2, b2, c2) {
  var d2 = b2.blockedSegment.formatContext, f3 = b2.legacyContext, e2 = b2.context;
  try {
    return X$12(a2, b2, c2);
  } catch (k4) {
    if (rb$1(), "object" === typeof k4 && null !== k4 && "function" === typeof k4.then) {
      c2 = k4;
      var g = b2.blockedSegment, h2 = U$12(a2, g.chunks.length, null, g.formatContext, g.lastPushedText, true);
      g.children.push(h2);
      g.lastPushedText = false;
      a2 = Bb$1(a2, b2.node, b2.blockedBoundary, h2, b2.abortSet, b2.legacyContext, b2.context, b2.treeContext).ping;
      c2.then(a2, a2);
      b2.blockedSegment.formatContext = d2;
      b2.legacyContext = f3;
      b2.context = e2;
      G3(e2);
    } else
      throw b2.blockedSegment.formatContext = d2, b2.legacyContext = f3, b2.context = e2, G3(e2), k4;
  }
}
function Jb$1(a2) {
  var b2 = a2.blockedBoundary;
  a2 = a2.blockedSegment;
  a2.status = 3;
  Kb$1(this, b2, a2);
}
function Lb$1(a2, b2, c2) {
  var d2 = a2.blockedBoundary;
  a2.blockedSegment.status = 3;
  null === d2 ? (b2.allPendingTasks--, 2 !== b2.status && (b2.status = 2, null !== b2.destination && b2.destination.push(null))) : (d2.pendingTasks--, d2.forceClientRender || (d2.forceClientRender = true, a2 = void 0 === c2 ? Error(l$22(432)) : c2, d2.errorDigest = b2.onError(a2), d2.parentFlushed && b2.clientRenderedBoundaries.push(d2)), d2.fallbackAbortableTasks.forEach(function(a3) {
    return Lb$1(a3, b2, c2);
  }), d2.fallbackAbortableTasks.clear(), b2.allPendingTasks--, 0 === b2.allPendingTasks && (d2 = b2.onAllReady, d2()));
}
function Y$1(a2, b2) {
  if (0 === b2.chunks.length && 1 === b2.children.length && null === b2.children[0].boundary) {
    var c2 = b2.children[0];
    c2.id = b2.id;
    c2.parentFlushed = true;
    1 === c2.status && Y$1(a2, c2);
  } else
    a2.completedSegments.push(b2);
}
function Kb$1(a2, b2, c2) {
  if (null === b2) {
    if (c2.parentFlushed) {
      if (null !== a2.completedRootSegment)
        throw Error(l$22(389));
      a2.completedRootSegment = c2;
    }
    a2.pendingRootTasks--;
    0 === a2.pendingRootTasks && (a2.onShellError = T$12, b2 = a2.onShellReady, b2());
  } else
    b2.pendingTasks--, b2.forceClientRender || (0 === b2.pendingTasks ? (c2.parentFlushed && 1 === c2.status && Y$1(b2, c2), b2.parentFlushed && a2.completedBoundaries.push(b2), b2.fallbackAbortableTasks.forEach(Jb$1, a2), b2.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (Y$1(b2, c2), 1 === b2.completedSegments.length && b2.parentFlushed && a2.partialBoundaries.push(b2)));
  a2.allPendingTasks--;
  0 === a2.allPendingTasks && (a2 = a2.onAllReady, a2());
}
function Cb$1(a2) {
  if (2 !== a2.status) {
    var b2 = E$12, c2 = yb$1.current;
    yb$1.current = xb$1;
    var d2 = S$12;
    S$12 = a2.responseState;
    try {
      var f3 = a2.pingedTasks, e2;
      for (e2 = 0; e2 < f3.length; e2++) {
        var g = f3[e2];
        var h2 = a2, k4 = g.blockedSegment;
        if (0 === k4.status) {
          G3(g.context);
          try {
            X$12(h2, g, g.node), h2.responseState.generateStaticMarkup || k4.lastPushedText && k4.textEmbedded && k4.chunks.push("<!-- -->"), g.abortSet.delete(g), k4.status = 1, Kb$1(h2, g.blockedBoundary, k4);
          } catch (z4) {
            if (rb$1(), "object" === typeof z4 && null !== z4 && "function" === typeof z4.then) {
              var m2 = g.ping;
              z4.then(m2, m2);
            } else {
              g.abortSet.delete(g);
              k4.status = 4;
              var n5 = g.blockedBoundary, q2 = z4, C4 = V$12(h2, q2);
              null === n5 ? W$12(h2, q2) : (n5.pendingTasks--, n5.forceClientRender || (n5.forceClientRender = true, n5.errorDigest = C4, n5.parentFlushed && h2.clientRenderedBoundaries.push(n5)));
              h2.allPendingTasks--;
              if (0 === h2.allPendingTasks) {
                var D5 = h2.onAllReady;
                D5();
              }
            }
          } finally {
          }
        }
      }
      f3.splice(0, e2);
      null !== a2.destination && Mb$1(a2, a2.destination);
    } catch (z4) {
      V$12(a2, z4), W$12(a2, z4);
    } finally {
      S$12 = d2, yb$1.current = c2, c2 === xb$1 && G3(b2);
    }
  }
}
function Z$1(a2, b2, c2) {
  c2.parentFlushed = true;
  switch (c2.status) {
    case 0:
      var d2 = c2.id = a2.nextSegmentId++;
      c2.lastPushedText = false;
      c2.textEmbedded = false;
      a2 = a2.responseState;
      b2.push('<template id="');
      b2.push(a2.placeholderPrefix);
      a2 = d2.toString(16);
      b2.push(a2);
      return b2.push('"></template>');
    case 1:
      c2.status = 2;
      var f3 = true;
      d2 = c2.chunks;
      var e2 = 0;
      c2 = c2.children;
      for (var g = 0; g < c2.length; g++) {
        for (f3 = c2[g]; e2 < f3.index; e2++)
          b2.push(d2[e2]);
        f3 = Nb$1(a2, b2, f3);
      }
      for (; e2 < d2.length - 1; e2++)
        b2.push(d2[e2]);
      e2 < d2.length && (f3 = b2.push(d2[e2]));
      return f3;
    default:
      throw Error(l$22(390));
  }
}
function Nb$1(a2, b2, c2) {
  var d2 = c2.boundary;
  if (null === d2)
    return Z$1(a2, b2, c2);
  d2.parentFlushed = true;
  if (d2.forceClientRender)
    return a2.responseState.generateStaticMarkup || (d2 = d2.errorDigest, b2.push("<!--$!-->"), b2.push("<template"), d2 && (b2.push(' data-dgst="'), d2 = v3(d2), b2.push(d2), b2.push('"')), b2.push("></template>")), Z$1(a2, b2, c2), a2 = a2.responseState.generateStaticMarkup ? true : b2.push("<!--/$-->"), a2;
  if (0 < d2.pendingTasks) {
    d2.rootSegmentID = a2.nextSegmentId++;
    0 < d2.completedSegments.length && a2.partialBoundaries.push(d2);
    var f3 = a2.responseState;
    var e2 = f3.nextSuspenseID++;
    f3 = f3.boundaryPrefix + e2.toString(16);
    d2 = d2.id = f3;
    za$1(b2, a2.responseState, d2);
    Z$1(a2, b2, c2);
    return b2.push("<!--/$-->");
  }
  if (d2.byteSize > a2.progressiveChunkSize)
    return d2.rootSegmentID = a2.nextSegmentId++, a2.completedBoundaries.push(d2), za$1(b2, a2.responseState, d2.id), Z$1(a2, b2, c2), b2.push("<!--/$-->");
  a2.responseState.generateStaticMarkup || b2.push("<!--$-->");
  c2 = d2.completedSegments;
  if (1 !== c2.length)
    throw Error(l$22(391));
  Nb$1(a2, b2, c2[0]);
  a2 = a2.responseState.generateStaticMarkup ? true : b2.push("<!--/$-->");
  return a2;
}
function Ob$1(a2, b2, c2) {
  Aa$1(b2, a2.responseState, c2.formatContext, c2.id);
  Nb$1(a2, b2, c2);
  return Ba$1(b2, c2.formatContext);
}
function Pb$1(a2, b2, c2) {
  for (var d2 = c2.completedSegments, f3 = 0; f3 < d2.length; f3++)
    Qb$1(a2, b2, c2, d2[f3]);
  d2.length = 0;
  a2 = a2.responseState;
  d2 = c2.id;
  c2 = c2.rootSegmentID;
  b2.push(a2.startInlineScript);
  a2.sentCompleteBoundaryFunction ? b2.push('$RC("') : (a2.sentCompleteBoundaryFunction = true, b2.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
  if (null === d2)
    throw Error(l$22(395));
  c2 = c2.toString(16);
  b2.push(d2);
  b2.push('","');
  b2.push(a2.segmentPrefix);
  b2.push(c2);
  return b2.push('")<\/script>');
}
function Qb$1(a2, b2, c2, d2) {
  if (2 === d2.status)
    return true;
  var f3 = d2.id;
  if (-1 === f3) {
    if (-1 === (d2.id = c2.rootSegmentID))
      throw Error(l$22(392));
    return Ob$1(a2, b2, d2);
  }
  Ob$1(a2, b2, d2);
  a2 = a2.responseState;
  b2.push(a2.startInlineScript);
  a2.sentCompleteSegmentFunction ? b2.push('$RS("') : (a2.sentCompleteSegmentFunction = true, b2.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
  b2.push(a2.segmentPrefix);
  f3 = f3.toString(16);
  b2.push(f3);
  b2.push('","');
  b2.push(a2.placeholderPrefix);
  b2.push(f3);
  return b2.push('")<\/script>');
}
function Mb$1(a2, b2) {
  try {
    var c2 = a2.completedRootSegment;
    if (null !== c2 && 0 === a2.pendingRootTasks) {
      Nb$1(a2, b2, c2);
      a2.completedRootSegment = null;
      var d2 = a2.responseState.bootstrapChunks;
      for (c2 = 0; c2 < d2.length - 1; c2++)
        b2.push(d2[c2]);
      c2 < d2.length && b2.push(d2[c2]);
    }
    var f3 = a2.clientRenderedBoundaries, e2;
    for (e2 = 0; e2 < f3.length; e2++) {
      var g = f3[e2];
      d2 = b2;
      var h2 = a2.responseState, k4 = g.id, m2 = g.errorDigest, n5 = g.errorMessage, q2 = g.errorComponentStack;
      d2.push(h2.startInlineScript);
      h2.sentClientRenderFunction ? d2.push('$RX("') : (h2.sentClientRenderFunction = true, d2.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
      if (null === k4)
        throw Error(l$22(395));
      d2.push(k4);
      d2.push('"');
      if (m2 || n5 || q2) {
        d2.push(",");
        var C4 = Da$1(m2 || "");
        d2.push(C4);
      }
      if (n5 || q2) {
        d2.push(",");
        var D5 = Da$1(n5 || "");
        d2.push(D5);
      }
      if (q2) {
        d2.push(",");
        var z4 = Da$1(q2);
        d2.push(z4);
      }
      if (!d2.push(")<\/script>")) {
        a2.destination = null;
        e2++;
        f3.splice(0, e2);
        return;
      }
    }
    f3.splice(0, e2);
    var ba2 = a2.completedBoundaries;
    for (e2 = 0; e2 < ba2.length; e2++)
      if (!Pb$1(a2, b2, ba2[e2])) {
        a2.destination = null;
        e2++;
        ba2.splice(0, e2);
        return;
      }
    ba2.splice(0, e2);
    var ca4 = a2.partialBoundaries;
    for (e2 = 0; e2 < ca4.length; e2++) {
      var mb3 = ca4[e2];
      a: {
        f3 = a2;
        g = b2;
        var da3 = mb3.completedSegments;
        for (h2 = 0; h2 < da3.length; h2++)
          if (!Qb$1(f3, g, mb3, da3[h2])) {
            h2++;
            da3.splice(0, h2);
            var nb3 = false;
            break a;
          }
        da3.splice(0, h2);
        nb3 = true;
      }
      if (!nb3) {
        a2.destination = null;
        e2++;
        ca4.splice(0, e2);
        return;
      }
    }
    ca4.splice(0, e2);
    var ea3 = a2.completedBoundaries;
    for (e2 = 0; e2 < ea3.length; e2++)
      if (!Pb$1(a2, b2, ea3[e2])) {
        a2.destination = null;
        e2++;
        ea3.splice(0, e2);
        return;
      }
    ea3.splice(0, e2);
  } finally {
    0 === a2.allPendingTasks && 0 === a2.pingedTasks.length && 0 === a2.clientRenderedBoundaries.length && 0 === a2.completedBoundaries.length && b2.push(null);
  }
}
function Rb$1(a2, b2) {
  try {
    var c2 = a2.abortableTasks;
    c2.forEach(function(c3) {
      return Lb$1(c3, a2, b2);
    });
    c2.clear();
    null !== a2.destination && Mb$1(a2, a2.destination);
  } catch (d2) {
    V$12(a2, d2), W$12(a2, d2);
  }
}
function Sb$1() {
}
function Tb$1(a2, b2, c2, d2) {
  var f3 = false, e2 = null, g = "", h2 = { push: function(a3) {
    null !== a3 && (g += a3);
    return true;
  }, destroy: function(a3) {
    f3 = true;
    e2 = a3;
  } }, k4 = false;
  a2 = Ab$1(a2, Ea$1(c2, b2 ? b2.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, Infinity, Sb$1, void 0, function() {
    k4 = true;
  }, void 0, void 0);
  Cb$1(a2);
  Rb$1(a2, d2);
  if (1 === a2.status)
    a2.status = 2, h2.destroy(a2.fatalError);
  else if (2 !== a2.status && null === a2.destination) {
    a2.destination = h2;
    try {
      Mb$1(a2, h2);
    } catch (m2) {
      V$12(a2, m2), W$12(a2, m2);
    }
  }
  if (f3)
    throw e2;
  if (!k4)
    throw Error(l$22(426));
  return g;
}
function k3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function p3(a2, b2) {
  if (0 !== b2.length)
    if (512 < b2.length)
      0 < n3 && (a2.enqueue(new Uint8Array(l$12.buffer, 0, n3)), l$12 = new Uint8Array(512), n3 = 0), a2.enqueue(b2);
    else {
      var c2 = l$12.length - n3;
      c2 < b2.length && (0 === c2 ? a2.enqueue(l$12) : (l$12.set(b2.subarray(0, c2), n3), a2.enqueue(l$12), b2 = b2.subarray(c2)), l$12 = new Uint8Array(512), n3 = 0);
      l$12.set(b2, n3);
      n3 += b2.length;
    }
}
function t3(a2, b2) {
  p3(a2, b2);
  return true;
}
function ba(a2) {
  l$12 && 0 < n3 && (a2.enqueue(new Uint8Array(l$12.buffer, 0, n3)), l$12 = null, n3 = 0);
}
function u3(a2) {
  return ca3.encode(a2);
}
function w4(a2) {
  return ca3.encode(a2);
}
function da2(a2, b2) {
  "function" === typeof a2.error ? a2.error(b2) : a2.close();
}
function ia2(a2) {
  if (x3.call(ha2, a2))
    return true;
  if (x3.call(fa2, a2))
    return false;
  if (ea2.test(a2))
    return ha2[a2] = true;
  fa2[a2] = true;
  return false;
}
function y2(a2, b2, c2, d2, f3, e2, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = f3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = e2;
  this.removeEmptyString = g;
}
function ka2(a2) {
  return a2[1].toUpperCase();
}
function C3(a2) {
  if ("boolean" === typeof a2 || "number" === typeof a2)
    return "" + a2;
  a2 = "" + a2;
  var b2 = oa2.exec(a2);
  if (b2) {
    var c2 = "", d2, f3 = 0;
    for (d2 = b2.index; d2 < a2.length; d2++) {
      switch (a2.charCodeAt(d2)) {
        case 34:
          b2 = "&quot;";
          break;
        case 38:
          b2 = "&amp;";
          break;
        case 39:
          b2 = "&#x27;";
          break;
        case 60:
          b2 = "&lt;";
          break;
        case 62:
          b2 = "&gt;";
          break;
        default:
          continue;
      }
      f3 !== d2 && (c2 += a2.substring(f3, d2));
      f3 = d2 + 1;
      c2 += b2;
    }
    a2 = f3 !== d2 ? c2 + a2.substring(f3, d2) : c2;
  }
  return a2;
}
function ya2(a2, b2, c2, d2) {
  return "" + b2 + ("s" === c2 ? "\\u0073" : "\\u0053") + d2;
}
function za2(a2, b2, c2, d2, f3) {
  a2 = void 0 === a2 ? "" : a2;
  b2 = void 0 === b2 ? sa2 : w4('<script nonce="' + C3(b2) + '">');
  var e2 = [];
  void 0 !== c2 && e2.push(b2, u3(("" + c2).replace(xa, ya2)), ta2);
  if (void 0 !== d2)
    for (c2 = 0; c2 < d2.length; c2++)
      e2.push(ua2, u3(C3(d2[c2])), wa2);
  if (void 0 !== f3)
    for (d2 = 0; d2 < f3.length; d2++)
      e2.push(va2, u3(C3(f3[d2])), wa2);
  return { bootstrapChunks: e2, startInlineScript: b2, placeholderPrefix: w4(a2 + "P:"), segmentPrefix: w4(a2 + "S:"), boundaryPrefix: a2 + "B:", idPrefix: a2, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false };
}
function D4(a2, b2) {
  return { insertionMode: a2, selectedValue: b2 };
}
function Aa2(a2) {
  return D4("http://www.w3.org/2000/svg" === a2 ? 2 : "http://www.w3.org/1998/Math/MathML" === a2 ? 3 : 0, null);
}
function Ba2(a2, b2, c2) {
  switch (b2) {
    case "select":
      return D4(1, null != c2.value ? c2.value : c2.defaultValue);
    case "svg":
      return D4(2, null);
    case "math":
      return D4(3, null);
    case "foreignObject":
      return D4(1, null);
    case "table":
      return D4(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return D4(5, null);
    case "colgroup":
      return D4(7, null);
    case "tr":
      return D4(6, null);
  }
  return 4 <= a2.insertionMode || 0 === a2.insertionMode ? D4(1, null) : a2;
}
function Da2(a2, b2, c2, d2) {
  if ("" === b2)
    return d2;
  d2 && a2.push(Ca2);
  a2.push(u3(C3(b2)));
  return true;
}
function Ia2(a2, b2, c2) {
  if ("object" !== typeof c2)
    throw Error(k3(62));
  b2 = true;
  for (var d2 in c2)
    if (x3.call(c2, d2)) {
      var f3 = c2[d2];
      if (null != f3 && "boolean" !== typeof f3 && "" !== f3) {
        if (0 === d2.indexOf("--")) {
          var e2 = u3(C3(d2));
          f3 = u3(C3(("" + f3).trim()));
        } else {
          e2 = d2;
          var g = Ea2.get(e2);
          void 0 !== g ? e2 = g : (g = w4(C3(e2.replace(pa2, "-$1").toLowerCase().replace(qa2, "-ms-"))), Ea2.set(e2, g), e2 = g);
          f3 = "number" === typeof f3 ? 0 === f3 || x3.call(B3, d2) ? u3("" + f3) : u3(f3 + "px") : u3(C3(("" + f3).trim()));
        }
        b2 ? (b2 = false, a2.push(Fa2, e2, Ga2, f3)) : a2.push(Ha2, e2, Ga2, f3);
      }
    }
  b2 || a2.push(E3);
}
function J2(a2, b2, c2, d2) {
  switch (c2) {
    case "style":
      Ia2(a2, b2, d2);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
    if (b2 = z3.hasOwnProperty(c2) ? z3[c2] : null, null !== b2) {
      switch (typeof d2) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b2.acceptsBooleans)
            return;
      }
      c2 = u3(b2.attributeName);
      switch (b2.type) {
        case 3:
          d2 && a2.push(H2, c2, Ja2);
          break;
        case 4:
          true === d2 ? a2.push(H2, c2, Ja2) : false !== d2 && a2.push(H2, c2, I3, u3(C3(d2)), E3);
          break;
        case 5:
          isNaN(d2) || a2.push(H2, c2, I3, u3(C3(d2)), E3);
          break;
        case 6:
          !isNaN(d2) && 1 <= d2 && a2.push(H2, c2, I3, u3(C3(d2)), E3);
          break;
        default:
          b2.sanitizeURL && (d2 = "" + d2), a2.push(H2, c2, I3, u3(C3(d2)), E3);
      }
    } else if (ia2(c2)) {
      switch (typeof d2) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b2 = c2.toLowerCase().slice(0, 5), "data-" !== b2 && "aria-" !== b2)
            return;
      }
      a2.push(H2, u3(c2), I3, u3(C3(d2)), E3);
    }
  }
}
function L3(a2, b2, c2) {
  if (null != b2) {
    if (null != c2)
      throw Error(k3(60));
    if ("object" !== typeof b2 || !("__html" in b2))
      throw Error(k3(61));
    b2 = b2.__html;
    null !== b2 && void 0 !== b2 && a2.push(u3("" + b2));
  }
}
function La2(a2) {
  var b2 = "";
  aa2.Children.forEach(a2, function(a3) {
    null != a3 && (b2 += a3);
  });
  return b2;
}
function Na2(a2, b2, c2, d2) {
  a2.push(M2(c2));
  var f3 = c2 = null, e2;
  for (e2 in b2)
    if (x3.call(b2, e2)) {
      var g = b2[e2];
      if (null != g)
        switch (e2) {
          case "children":
            c2 = g;
            break;
          case "dangerouslySetInnerHTML":
            f3 = g;
            break;
          default:
            J2(a2, d2, e2, g);
        }
    }
  a2.push(K2);
  L3(a2, f3, c2);
  return "string" === typeof c2 ? (a2.push(u3(C3(c2))), null) : c2;
}
function M2(a2) {
  var b2 = Qa2.get(a2);
  if (void 0 === b2) {
    if (!Pa2.test(a2))
      throw Error(k3(65, a2));
    b2 = w4("<" + a2);
    Qa2.set(a2, b2);
  }
  return b2;
}
function Sa2(a2, b2, c2, d2, f3) {
  switch (b2) {
    case "select":
      a2.push(M2("select"));
      var e2 = null, g = null;
      for (r5 in c2)
        if (x3.call(c2, r5)) {
          var h2 = c2[r5];
          if (null != h2)
            switch (r5) {
              case "children":
                e2 = h2;
                break;
              case "dangerouslySetInnerHTML":
                g = h2;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                J2(a2, d2, r5, h2);
            }
        }
      a2.push(K2);
      L3(a2, g, e2);
      return e2;
    case "option":
      g = f3.selectedValue;
      a2.push(M2("option"));
      var m2 = h2 = null, q2 = null;
      var r5 = null;
      for (e2 in c2)
        if (x3.call(c2, e2)) {
          var v4 = c2[e2];
          if (null != v4)
            switch (e2) {
              case "children":
                h2 = v4;
                break;
              case "selected":
                q2 = v4;
                break;
              case "dangerouslySetInnerHTML":
                r5 = v4;
                break;
              case "value":
                m2 = v4;
              default:
                J2(a2, d2, e2, v4);
            }
        }
      if (null != g)
        if (c2 = null !== m2 ? "" + m2 : La2(h2), ra2(g))
          for (d2 = 0; d2 < g.length; d2++) {
            if ("" + g[d2] === c2) {
              a2.push(Ma2);
              break;
            }
          }
        else
          "" + g === c2 && a2.push(Ma2);
      else
        q2 && a2.push(Ma2);
      a2.push(K2);
      L3(a2, r5, h2);
      return h2;
    case "textarea":
      a2.push(M2("textarea"));
      r5 = g = e2 = null;
      for (h2 in c2)
        if (x3.call(c2, h2) && (m2 = c2[h2], null != m2))
          switch (h2) {
            case "children":
              r5 = m2;
              break;
            case "value":
              e2 = m2;
              break;
            case "defaultValue":
              g = m2;
              break;
            case "dangerouslySetInnerHTML":
              throw Error(k3(91));
            default:
              J2(a2, d2, h2, m2);
          }
      null === e2 && null !== g && (e2 = g);
      a2.push(K2);
      if (null != r5) {
        if (null != e2)
          throw Error(k3(92));
        if (ra2(r5) && 1 < r5.length)
          throw Error(k3(93));
        e2 = "" + r5;
      }
      "string" === typeof e2 && "\n" === e2[0] && a2.push(Oa2);
      null !== e2 && a2.push(u3(C3("" + e2)));
      return null;
    case "input":
      a2.push(M2("input"));
      m2 = r5 = h2 = e2 = null;
      for (g in c2)
        if (x3.call(c2, g) && (q2 = c2[g], null != q2))
          switch (g) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(k3(399, "input"));
            case "defaultChecked":
              m2 = q2;
              break;
            case "defaultValue":
              h2 = q2;
              break;
            case "checked":
              r5 = q2;
              break;
            case "value":
              e2 = q2;
              break;
            default:
              J2(a2, d2, g, q2);
          }
      null !== r5 ? J2(
        a2,
        d2,
        "checked",
        r5
      ) : null !== m2 && J2(a2, d2, "checked", m2);
      null !== e2 ? J2(a2, d2, "value", e2) : null !== h2 && J2(a2, d2, "value", h2);
      a2.push(Ka2);
      return null;
    case "menuitem":
      a2.push(M2("menuitem"));
      for (var A4 in c2)
        if (x3.call(c2, A4) && (e2 = c2[A4], null != e2))
          switch (A4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(k3(400));
            default:
              J2(a2, d2, A4, e2);
          }
      a2.push(K2);
      return null;
    case "title":
      a2.push(M2("title"));
      e2 = null;
      for (v4 in c2)
        if (x3.call(c2, v4) && (g = c2[v4], null != g))
          switch (v4) {
            case "children":
              e2 = g;
              break;
            case "dangerouslySetInnerHTML":
              throw Error(k3(434));
            default:
              J2(a2, d2, v4, g);
          }
      a2.push(K2);
      return e2;
    case "listing":
    case "pre":
      a2.push(M2(b2));
      g = e2 = null;
      for (m2 in c2)
        if (x3.call(c2, m2) && (h2 = c2[m2], null != h2))
          switch (m2) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g = h2;
              break;
            default:
              J2(a2, d2, m2, h2);
          }
      a2.push(K2);
      if (null != g) {
        if (null != e2)
          throw Error(k3(60));
        if ("object" !== typeof g || !("__html" in g))
          throw Error(k3(61));
        c2 = g.__html;
        null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a2.push(Oa2, u3(c2)) : a2.push(u3("" + c2)));
      }
      "string" === typeof e2 && "\n" === e2[0] && a2.push(Oa2);
      return e2;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a2.push(M2(b2));
      for (var F4 in c2)
        if (x3.call(c2, F4) && (e2 = c2[F4], null != e2))
          switch (F4) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(k3(399, b2));
            default:
              J2(a2, d2, F4, e2);
          }
      a2.push(Ka2);
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return Na2(a2, c2, b2, d2);
    case "html":
      return 0 === f3.insertionMode && a2.push(Ra2), Na2(a2, c2, b2, d2);
    default:
      if (-1 === b2.indexOf("-") && "string" !== typeof c2.is)
        return Na2(a2, c2, b2, d2);
      a2.push(M2(b2));
      g = e2 = null;
      for (q2 in c2)
        if (x3.call(c2, q2) && (h2 = c2[q2], null != h2))
          switch (q2) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g = h2;
              break;
            case "style":
              Ia2(a2, d2, h2);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ia2(q2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a2.push(H2, u3(q2), I3, u3(C3(h2)), E3);
          }
      a2.push(K2);
      L3(a2, g, e2);
      return e2;
  }
}
function fb2(a2, b2, c2) {
  p3(a2, Ya2);
  if (null === c2)
    throw Error(k3(395));
  p3(a2, c2);
  return t3(a2, Za2);
}
function Bb2(a2, b2, c2, d2) {
  switch (c2.insertionMode) {
    case 0:
    case 1:
      return p3(a2, gb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, hb2);
    case 2:
      return p3(a2, jb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, kb2);
    case 3:
      return p3(a2, mb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, nb2);
    case 4:
      return p3(a2, pb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, qb2);
    case 5:
      return p3(a2, sb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, tb2);
    case 6:
      return p3(a2, vb2), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, wb2);
    case 7:
      return p3(
        a2,
        yb2
      ), p3(a2, b2.segmentPrefix), p3(a2, u3(d2.toString(16))), t3(a2, zb2);
    default:
      throw Error(k3(397));
  }
}
function Cb2(a2, b2) {
  switch (b2.insertionMode) {
    case 0:
    case 1:
      return t3(a2, ib2);
    case 2:
      return t3(a2, lb2);
    case 3:
      return t3(a2, ob2);
    case 4:
      return t3(a2, rb2);
    case 5:
      return t3(a2, ub2);
    case 6:
      return t3(a2, xb2);
    case 7:
      return t3(a2, Ab2);
    default:
      throw Error(k3(397));
  }
}
function Sb2(a2) {
  return JSON.stringify(a2).replace(Rb2, function(a3) {
    switch (a3) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function jc2(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case Vb2:
      return "Fragment";
    case Ub2:
      return "Portal";
    case Xb2:
      return "Profiler";
    case Wb2:
      return "StrictMode";
    case ac2:
      return "Suspense";
    case bc2:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Zb2:
        return (a2.displayName || "Context") + ".Consumer";
      case Yb2:
        return (a2._context.displayName || "Context") + ".Provider";
      case $b2:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case cc2:
        return b2 = a2.displayName || null, null !== b2 ? b2 : jc2(a2.type) || "Memo";
      case dc2:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return jc2(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function lc2(a2, b2) {
  a2 = a2.contextTypes;
  if (!a2)
    return kc2;
  var c2 = {}, d2;
  for (d2 in a2)
    c2[d2] = b2[d2];
  return c2;
}
function P4(a2, b2) {
  if (a2 !== b2) {
    a2.context._currentValue = a2.parentValue;
    a2 = a2.parent;
    var c2 = b2.parent;
    if (null === a2) {
      if (null !== c2)
        throw Error(k3(401));
    } else {
      if (null === c2)
        throw Error(k3(401));
      P4(a2, c2);
    }
    b2.context._currentValue = b2.value;
  }
}
function mc2(a2) {
  a2.context._currentValue = a2.parentValue;
  a2 = a2.parent;
  null !== a2 && mc2(a2);
}
function nc2(a2) {
  var b2 = a2.parent;
  null !== b2 && nc2(b2);
  a2.context._currentValue = a2.value;
}
function oc2(a2, b2) {
  a2.context._currentValue = a2.parentValue;
  a2 = a2.parent;
  if (null === a2)
    throw Error(k3(402));
  a2.depth === b2.depth ? P4(a2, b2) : oc2(a2, b2);
}
function pc2(a2, b2) {
  var c2 = b2.parent;
  if (null === c2)
    throw Error(k3(402));
  a2.depth === c2.depth ? P4(a2, c2) : pc2(a2, c2);
  b2.context._currentValue = b2.value;
}
function Q2(a2) {
  var b2 = O3;
  b2 !== a2 && (null === b2 ? nc2(a2) : null === a2 ? mc2(b2) : b2.depth === a2.depth ? P4(b2, a2) : b2.depth > a2.depth ? oc2(b2, a2) : pc2(b2, a2), O3 = a2);
}
function rc2(a2, b2, c2, d2) {
  var f3 = void 0 !== a2.state ? a2.state : null;
  a2.updater = qc2;
  a2.props = c2;
  a2.state = f3;
  var e2 = { queue: [], replace: false };
  a2._reactInternals = e2;
  var g = b2.contextType;
  a2.context = "object" === typeof g && null !== g ? g._currentValue : d2;
  g = b2.getDerivedStateFromProps;
  "function" === typeof g && (g = g(c2, f3), f3 = null === g || void 0 === g ? f3 : N3({}, f3, g), a2.state = f3);
  if ("function" !== typeof b2.getDerivedStateFromProps && "function" !== typeof a2.getSnapshotBeforeUpdate && ("function" === typeof a2.UNSAFE_componentWillMount || "function" === typeof a2.componentWillMount))
    if (b2 = a2.state, "function" === typeof a2.componentWillMount && a2.componentWillMount(), "function" === typeof a2.UNSAFE_componentWillMount && a2.UNSAFE_componentWillMount(), b2 !== a2.state && qc2.enqueueReplaceState(a2, a2.state, null), null !== e2.queue && 0 < e2.queue.length)
      if (b2 = e2.queue, g = e2.replace, e2.queue = null, e2.replace = false, g && 1 === b2.length)
        a2.state = b2[0];
      else {
        e2 = g ? b2[0] : a2.state;
        f3 = true;
        for (g = g ? 1 : 0; g < b2.length; g++) {
          var h2 = b2[g];
          h2 = "function" === typeof h2 ? h2.call(a2, e2, c2, d2) : h2;
          null != h2 && (f3 ? (f3 = false, e2 = N3({}, e2, h2)) : N3(e2, h2));
        }
        a2.state = e2;
      }
    else
      e2.queue = null;
}
function tc2(a2, b2, c2) {
  var d2 = a2.id;
  a2 = a2.overflow;
  var f3 = 32 - uc2(d2) - 1;
  d2 &= ~(1 << f3);
  c2 += 1;
  var e2 = 32 - uc2(b2) + f3;
  if (30 < e2) {
    var g = f3 - f3 % 5;
    e2 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    f3 -= g;
    return { id: 1 << 32 - uc2(b2) + f3 | c2 << f3 | d2, overflow: e2 + a2 };
  }
  return { id: 1 << e2 | c2 << f3 | d2, overflow: a2 };
}
function vc2(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (wc2(a2) / xc2 | 0) | 0;
}
function yc2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
function W3() {
  if (null === R4)
    throw Error(k3(321));
  return R4;
}
function Ec2() {
  if (0 < Dc2)
    throw Error(k3(312));
  return { memoizedState: null, queue: null, next: null };
}
function Fc2() {
  null === S3 ? null === Bc2 ? (T3 = false, Bc2 = S3 = Ec2()) : (T3 = true, S3 = Bc2) : null === S3.next ? (T3 = false, S3 = S3.next = Ec2()) : (T3 = true, S3 = S3.next);
  return S3;
}
function Gc2() {
  Ac2 = R4 = null;
  Cc2 = false;
  Bc2 = null;
  Dc2 = 0;
  S3 = V2 = null;
}
function Hc2(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Ic2(a2, b2, c2) {
  R4 = W3();
  S3 = Fc2();
  if (T3) {
    var d2 = S3.queue;
    b2 = d2.dispatch;
    if (null !== V2 && (c2 = V2.get(d2), void 0 !== c2)) {
      V2.delete(d2);
      d2 = S3.memoizedState;
      do
        d2 = a2(d2, c2.action), c2 = c2.next;
      while (null !== c2);
      S3.memoizedState = d2;
      return [d2, b2];
    }
    return [S3.memoizedState, b2];
  }
  a2 = a2 === Hc2 ? "function" === typeof b2 ? b2() : b2 : void 0 !== c2 ? c2(b2) : b2;
  S3.memoizedState = a2;
  a2 = S3.queue = { last: null, dispatch: null };
  a2 = a2.dispatch = Jc2.bind(null, R4, a2);
  return [S3.memoizedState, a2];
}
function Kc2(a2, b2) {
  R4 = W3();
  S3 = Fc2();
  b2 = void 0 === b2 ? null : b2;
  if (null !== S3) {
    var c2 = S3.memoizedState;
    if (null !== c2 && null !== b2) {
      var d2 = c2[1];
      a:
        if (null === d2)
          d2 = false;
        else {
          for (var f3 = 0; f3 < d2.length && f3 < b2.length; f3++)
            if (!zc2(b2[f3], d2[f3])) {
              d2 = false;
              break a;
            }
          d2 = true;
        }
      if (d2)
        return c2[0];
    }
  }
  a2 = a2();
  S3.memoizedState = [a2, b2];
  return a2;
}
function Jc2(a2, b2, c2) {
  if (25 <= Dc2)
    throw Error(k3(301));
  if (a2 === R4)
    if (Cc2 = true, a2 = { action: c2, next: null }, null === V2 && (V2 = /* @__PURE__ */ new Map()), c2 = V2.get(b2), void 0 === c2)
      V2.set(b2, a2);
    else {
      for (b2 = c2; null !== b2.next; )
        b2 = b2.next;
      b2.next = a2;
    }
}
function Lc2() {
  throw Error(k3(394));
}
function Mc2() {
}
function Qc2(a2) {
  console.error(a2);
  return null;
}
function X2() {
}
function Rc2(a2, b2, c2, d2, f3, e2, g, h2, m2) {
  var q2 = [], r5 = /* @__PURE__ */ new Set();
  b2 = { destination: null, responseState: b2, progressiveChunkSize: void 0 === d2 ? 12800 : d2, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: r5, pingedTasks: q2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f3 ? Qc2 : f3, onAllReady: void 0 === e2 ? X2 : e2, onShellReady: void 0 === g ? X2 : g, onShellError: void 0 === h2 ? X2 : h2, onFatalError: void 0 === m2 ? X2 : m2 };
  c2 = Sc2(b2, 0, null, c2, false, false);
  c2.parentFlushed = true;
  a2 = Tc2(b2, a2, null, c2, r5, kc2, null, sc2);
  q2.push(a2);
  return b2;
}
function Tc2(a2, b2, c2, d2, f3, e2, g, h2) {
  a2.allPendingTasks++;
  null === c2 ? a2.pendingRootTasks++ : c2.pendingTasks++;
  var m2 = { node: b2, ping: function() {
    var b3 = a2.pingedTasks;
    b3.push(m2);
    1 === b3.length && Uc2(a2);
  }, blockedBoundary: c2, blockedSegment: d2, abortSet: f3, legacyContext: e2, context: g, treeContext: h2 };
  f3.add(m2);
  return m2;
}
function Sc2(a2, b2, c2, d2, f3, e2) {
  return { status: 0, id: -1, index: b2, parentFlushed: false, chunks: [], children: [], formatContext: d2, boundary: c2, lastPushedText: f3, textEmbedded: e2 };
}
function Y2(a2, b2) {
  a2 = a2.onError(b2);
  if (null != a2 && "string" !== typeof a2)
    throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a2 + '" instead');
  return a2;
}
function Vc2(a2, b2) {
  var c2 = a2.onShellError;
  c2(b2);
  c2 = a2.onFatalError;
  c2(b2);
  null !== a2.destination ? (a2.status = 2, da2(a2.destination, b2)) : (a2.status = 1, a2.fatalError = b2);
}
function Wc2(a2, b2, c2, d2, f3) {
  R4 = {};
  Ac2 = b2;
  U2 = 0;
  for (a2 = c2(d2, f3); Cc2; )
    Cc2 = false, U2 = 0, Dc2 += 1, S3 = null, a2 = c2(d2, f3);
  Gc2();
  return a2;
}
function Xc2(a2, b2, c2, d2) {
  var f3 = c2.render(), e2 = d2.childContextTypes;
  if (null !== e2 && void 0 !== e2) {
    var g = b2.legacyContext;
    if ("function" !== typeof c2.getChildContext)
      d2 = g;
    else {
      c2 = c2.getChildContext();
      for (var h2 in c2)
        if (!(h2 in e2))
          throw Error(k3(108, jc2(d2) || "Unknown", h2));
      d2 = N3({}, g, c2);
    }
    b2.legacyContext = d2;
    Z2(a2, b2, f3);
    b2.legacyContext = g;
  } else
    Z2(a2, b2, f3);
}
function Yc2(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = N3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Zc2(a2, b2, c2, d2, f3) {
  if ("function" === typeof c2)
    if (c2.prototype && c2.prototype.isReactComponent) {
      f3 = lc2(c2, b2.legacyContext);
      var e2 = c2.contextType;
      e2 = new c2(d2, "object" === typeof e2 && null !== e2 ? e2._currentValue : f3);
      rc2(e2, c2, d2, f3);
      Xc2(a2, b2, e2, c2);
    } else {
      e2 = lc2(c2, b2.legacyContext);
      f3 = Wc2(a2, b2, c2, d2, e2);
      var g = 0 !== U2;
      if ("object" === typeof f3 && null !== f3 && "function" === typeof f3.render && void 0 === f3.$$typeof)
        rc2(f3, c2, d2, e2), Xc2(a2, b2, f3, c2);
      else if (g) {
        d2 = b2.treeContext;
        b2.treeContext = tc2(d2, 1, 0);
        try {
          Z2(a2, b2, f3);
        } finally {
          b2.treeContext = d2;
        }
      } else
        Z2(a2, b2, f3);
    }
  else if ("string" === typeof c2) {
    f3 = b2.blockedSegment;
    e2 = Sa2(f3.chunks, c2, d2, a2.responseState, f3.formatContext);
    f3.lastPushedText = false;
    g = f3.formatContext;
    f3.formatContext = Ba2(g, c2, d2);
    $c2(a2, b2, e2);
    f3.formatContext = g;
    switch (c2) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f3.chunks.push(Ta2, u3(c2), Ua2);
    }
    f3.lastPushedText = false;
  } else {
    switch (c2) {
      case gc2:
      case fc2:
      case Wb2:
      case Xb2:
      case Vb2:
        Z2(a2, b2, d2.children);
        return;
      case bc2:
        Z2(a2, b2, d2.children);
        return;
      case ec2:
        throw Error(k3(343));
      case ac2:
        a: {
          c2 = b2.blockedBoundary;
          f3 = b2.blockedSegment;
          e2 = d2.fallback;
          d2 = d2.children;
          g = /* @__PURE__ */ new Set();
          var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, m2 = Sc2(a2, f3.chunks.length, h2, f3.formatContext, false, false);
          f3.children.push(m2);
          f3.lastPushedText = false;
          var q2 = Sc2(a2, 0, null, f3.formatContext, false, false);
          q2.parentFlushed = true;
          b2.blockedBoundary = h2;
          b2.blockedSegment = q2;
          try {
            if ($c2(
              a2,
              b2,
              d2
            ), q2.lastPushedText && q2.textEmbedded && q2.chunks.push(Ca2), q2.status = 1, ad2(h2, q2), 0 === h2.pendingTasks)
              break a;
          } catch (r5) {
            q2.status = 4, h2.forceClientRender = true, h2.errorDigest = Y2(a2, r5);
          } finally {
            b2.blockedBoundary = c2, b2.blockedSegment = f3;
          }
          b2 = Tc2(a2, e2, c2, m2, g, b2.legacyContext, b2.context, b2.treeContext);
          a2.pingedTasks.push(b2);
        }
        return;
    }
    if ("object" === typeof c2 && null !== c2)
      switch (c2.$$typeof) {
        case $b2:
          d2 = Wc2(a2, b2, c2.render, d2, f3);
          if (0 !== U2) {
            c2 = b2.treeContext;
            b2.treeContext = tc2(c2, 1, 0);
            try {
              Z2(a2, b2, d2);
            } finally {
              b2.treeContext = c2;
            }
          } else
            Z2(a2, b2, d2);
          return;
        case cc2:
          c2 = c2.type;
          d2 = Yc2(c2, d2);
          Zc2(a2, b2, c2, d2, f3);
          return;
        case Yb2:
          f3 = d2.children;
          c2 = c2._context;
          d2 = d2.value;
          e2 = c2._currentValue;
          c2._currentValue = d2;
          g = O3;
          O3 = d2 = { parent: g, depth: null === g ? 0 : g.depth + 1, context: c2, parentValue: e2, value: d2 };
          b2.context = d2;
          Z2(a2, b2, f3);
          a2 = O3;
          if (null === a2)
            throw Error(k3(403));
          d2 = a2.parentValue;
          a2.context._currentValue = d2 === hc2 ? a2.context._defaultValue : d2;
          a2 = O3 = a2.parent;
          b2.context = a2;
          return;
        case Zb2:
          d2 = d2.children;
          d2 = d2(c2._currentValue);
          Z2(a2, b2, d2);
          return;
        case dc2:
          f3 = c2._init;
          c2 = f3(c2._payload);
          d2 = Yc2(c2, d2);
          Zc2(a2, b2, c2, d2, void 0);
          return;
      }
    throw Error(k3(
      130,
      null == c2 ? c2 : typeof c2,
      ""
    ));
  }
}
function Z2(a2, b2, c2) {
  b2.node = c2;
  if ("object" === typeof c2 && null !== c2) {
    switch (c2.$$typeof) {
      case Tb2:
        Zc2(a2, b2, c2.type, c2.props, c2.ref);
        return;
      case Ub2:
        throw Error(k3(257));
      case dc2:
        var d2 = c2._init;
        c2 = d2(c2._payload);
        Z2(a2, b2, c2);
        return;
    }
    if (ra2(c2)) {
      bd2(a2, b2, c2);
      return;
    }
    null === c2 || "object" !== typeof c2 ? d2 = null : (d2 = ic2 && c2[ic2] || c2["@@iterator"], d2 = "function" === typeof d2 ? d2 : null);
    if (d2 && (d2 = d2.call(c2))) {
      c2 = d2.next();
      if (!c2.done) {
        var f3 = [];
        do
          f3.push(c2.value), c2 = d2.next();
        while (!c2.done);
        bd2(a2, b2, f3);
      }
      return;
    }
    a2 = Object.prototype.toString.call(c2);
    throw Error(k3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a2));
  }
  "string" === typeof c2 ? (d2 = b2.blockedSegment, d2.lastPushedText = Da2(b2.blockedSegment.chunks, c2, a2.responseState, d2.lastPushedText)) : "number" === typeof c2 && (d2 = b2.blockedSegment, d2.lastPushedText = Da2(b2.blockedSegment.chunks, "" + c2, a2.responseState, d2.lastPushedText));
}
function bd2(a2, b2, c2) {
  for (var d2 = c2.length, f3 = 0; f3 < d2; f3++) {
    var e2 = b2.treeContext;
    b2.treeContext = tc2(e2, d2, f3);
    try {
      $c2(a2, b2, c2[f3]);
    } finally {
      b2.treeContext = e2;
    }
  }
}
function $c2(a2, b2, c2) {
  var d2 = b2.blockedSegment.formatContext, f3 = b2.legacyContext, e2 = b2.context;
  try {
    return Z2(a2, b2, c2);
  } catch (m2) {
    if (Gc2(), "object" === typeof m2 && null !== m2 && "function" === typeof m2.then) {
      c2 = m2;
      var g = b2.blockedSegment, h2 = Sc2(a2, g.chunks.length, null, g.formatContext, g.lastPushedText, true);
      g.children.push(h2);
      g.lastPushedText = false;
      a2 = Tc2(a2, b2.node, b2.blockedBoundary, h2, b2.abortSet, b2.legacyContext, b2.context, b2.treeContext).ping;
      c2.then(a2, a2);
      b2.blockedSegment.formatContext = d2;
      b2.legacyContext = f3;
      b2.context = e2;
      Q2(e2);
    } else
      throw b2.blockedSegment.formatContext = d2, b2.legacyContext = f3, b2.context = e2, Q2(e2), m2;
  }
}
function cd2(a2) {
  var b2 = a2.blockedBoundary;
  a2 = a2.blockedSegment;
  a2.status = 3;
  dd2(this, b2, a2);
}
function ed2(a2, b2, c2) {
  var d2 = a2.blockedBoundary;
  a2.blockedSegment.status = 3;
  null === d2 ? (b2.allPendingTasks--, 2 !== b2.status && (b2.status = 2, null !== b2.destination && b2.destination.close())) : (d2.pendingTasks--, d2.forceClientRender || (d2.forceClientRender = true, a2 = void 0 === c2 ? Error(k3(432)) : c2, d2.errorDigest = b2.onError(a2), d2.parentFlushed && b2.clientRenderedBoundaries.push(d2)), d2.fallbackAbortableTasks.forEach(function(a3) {
    return ed2(a3, b2, c2);
  }), d2.fallbackAbortableTasks.clear(), b2.allPendingTasks--, 0 === b2.allPendingTasks && (d2 = b2.onAllReady, d2()));
}
function ad2(a2, b2) {
  if (0 === b2.chunks.length && 1 === b2.children.length && null === b2.children[0].boundary) {
    var c2 = b2.children[0];
    c2.id = b2.id;
    c2.parentFlushed = true;
    1 === c2.status && ad2(a2, c2);
  } else
    a2.completedSegments.push(b2);
}
function dd2(a2, b2, c2) {
  if (null === b2) {
    if (c2.parentFlushed) {
      if (null !== a2.completedRootSegment)
        throw Error(k3(389));
      a2.completedRootSegment = c2;
    }
    a2.pendingRootTasks--;
    0 === a2.pendingRootTasks && (a2.onShellError = X2, b2 = a2.onShellReady, b2());
  } else
    b2.pendingTasks--, b2.forceClientRender || (0 === b2.pendingTasks ? (c2.parentFlushed && 1 === c2.status && ad2(b2, c2), b2.parentFlushed && a2.completedBoundaries.push(b2), b2.fallbackAbortableTasks.forEach(cd2, a2), b2.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (ad2(b2, c2), 1 === b2.completedSegments.length && b2.parentFlushed && a2.partialBoundaries.push(b2)));
  a2.allPendingTasks--;
  0 === a2.allPendingTasks && (a2 = a2.onAllReady, a2());
}
function Uc2(a2) {
  if (2 !== a2.status) {
    var b2 = O3, c2 = Pc2.current;
    Pc2.current = Oc2;
    var d2 = Nc2;
    Nc2 = a2.responseState;
    try {
      var f3 = a2.pingedTasks, e2;
      for (e2 = 0; e2 < f3.length; e2++) {
        var g = f3[e2];
        var h2 = a2, m2 = g.blockedSegment;
        if (0 === m2.status) {
          Q2(g.context);
          try {
            Z2(h2, g, g.node), m2.lastPushedText && m2.textEmbedded && m2.chunks.push(Ca2), g.abortSet.delete(g), m2.status = 1, dd2(h2, g.blockedBoundary, m2);
          } catch (G4) {
            if (Gc2(), "object" === typeof G4 && null !== G4 && "function" === typeof G4.then) {
              var q2 = g.ping;
              G4.then(q2, q2);
            } else {
              g.abortSet.delete(g);
              m2.status = 4;
              var r5 = g.blockedBoundary, v4 = G4, A4 = Y2(h2, v4);
              null === r5 ? Vc2(h2, v4) : (r5.pendingTasks--, r5.forceClientRender || (r5.forceClientRender = true, r5.errorDigest = A4, r5.parentFlushed && h2.clientRenderedBoundaries.push(r5)));
              h2.allPendingTasks--;
              if (0 === h2.allPendingTasks) {
                var F4 = h2.onAllReady;
                F4();
              }
            }
          } finally {
          }
        }
      }
      f3.splice(0, e2);
      null !== a2.destination && fd2(a2, a2.destination);
    } catch (G4) {
      Y2(a2, G4), Vc2(a2, G4);
    } finally {
      Nc2 = d2, Pc2.current = c2, c2 === Oc2 && Q2(b2);
    }
  }
}
function gd2(a2, b2, c2) {
  c2.parentFlushed = true;
  switch (c2.status) {
    case 0:
      var d2 = c2.id = a2.nextSegmentId++;
      c2.lastPushedText = false;
      c2.textEmbedded = false;
      a2 = a2.responseState;
      p3(b2, Va2);
      p3(b2, a2.placeholderPrefix);
      a2 = u3(d2.toString(16));
      p3(b2, a2);
      return t3(b2, Wa2);
    case 1:
      c2.status = 2;
      var f3 = true;
      d2 = c2.chunks;
      var e2 = 0;
      c2 = c2.children;
      for (var g = 0; g < c2.length; g++) {
        for (f3 = c2[g]; e2 < f3.index; e2++)
          p3(b2, d2[e2]);
        f3 = hd2(a2, b2, f3);
      }
      for (; e2 < d2.length - 1; e2++)
        p3(b2, d2[e2]);
      e2 < d2.length && (f3 = t3(b2, d2[e2]));
      return f3;
    default:
      throw Error(k3(390));
  }
}
function hd2(a2, b2, c2) {
  var d2 = c2.boundary;
  if (null === d2)
    return gd2(a2, b2, c2);
  d2.parentFlushed = true;
  if (d2.forceClientRender)
    d2 = d2.errorDigest, t3(b2, $a), p3(b2, bb2), d2 && (p3(b2, db3), p3(b2, u3(C3(d2))), p3(b2, cb2)), t3(b2, eb2), gd2(a2, b2, c2);
  else if (0 < d2.pendingTasks) {
    d2.rootSegmentID = a2.nextSegmentId++;
    0 < d2.completedSegments.length && a2.partialBoundaries.push(d2);
    var f3 = a2.responseState;
    var e2 = f3.nextSuspenseID++;
    f3 = w4(f3.boundaryPrefix + e2.toString(16));
    d2 = d2.id = f3;
    fb2(b2, a2.responseState, d2);
    gd2(a2, b2, c2);
  } else if (d2.byteSize > a2.progressiveChunkSize)
    d2.rootSegmentID = a2.nextSegmentId++, a2.completedBoundaries.push(d2), fb2(b2, a2.responseState, d2.id), gd2(a2, b2, c2);
  else {
    t3(b2, Xa2);
    c2 = d2.completedSegments;
    if (1 !== c2.length)
      throw Error(k3(391));
    hd2(a2, b2, c2[0]);
  }
  return t3(b2, ab2);
}
function id2(a2, b2, c2) {
  Bb2(b2, a2.responseState, c2.formatContext, c2.id);
  hd2(a2, b2, c2);
  return Cb2(b2, c2.formatContext);
}
function jd2(a2, b2, c2) {
  for (var d2 = c2.completedSegments, f3 = 0; f3 < d2.length; f3++)
    kd2(a2, b2, c2, d2[f3]);
  d2.length = 0;
  a2 = a2.responseState;
  d2 = c2.id;
  c2 = c2.rootSegmentID;
  p3(b2, a2.startInlineScript);
  a2.sentCompleteBoundaryFunction ? p3(b2, Jb2) : (a2.sentCompleteBoundaryFunction = true, p3(b2, Ib2));
  if (null === d2)
    throw Error(k3(395));
  c2 = u3(c2.toString(16));
  p3(b2, d2);
  p3(b2, Kb2);
  p3(b2, a2.segmentPrefix);
  p3(b2, c2);
  return t3(b2, Lb2);
}
function kd2(a2, b2, c2, d2) {
  if (2 === d2.status)
    return true;
  var f3 = d2.id;
  if (-1 === f3) {
    if (-1 === (d2.id = c2.rootSegmentID))
      throw Error(k3(392));
    return id2(a2, b2, d2);
  }
  id2(a2, b2, d2);
  a2 = a2.responseState;
  p3(b2, a2.startInlineScript);
  a2.sentCompleteSegmentFunction ? p3(b2, Eb2) : (a2.sentCompleteSegmentFunction = true, p3(b2, Db2));
  p3(b2, a2.segmentPrefix);
  f3 = u3(f3.toString(16));
  p3(b2, f3);
  p3(b2, Gb2);
  p3(b2, a2.placeholderPrefix);
  p3(b2, f3);
  return t3(b2, Hb2);
}
function fd2(a2, b2) {
  l$12 = new Uint8Array(512);
  n3 = 0;
  try {
    var c2 = a2.completedRootSegment;
    if (null !== c2 && 0 === a2.pendingRootTasks) {
      hd2(a2, b2, c2);
      a2.completedRootSegment = null;
      var d2 = a2.responseState.bootstrapChunks;
      for (c2 = 0; c2 < d2.length - 1; c2++)
        p3(b2, d2[c2]);
      c2 < d2.length && t3(b2, d2[c2]);
    }
    var f3 = a2.clientRenderedBoundaries, e2;
    for (e2 = 0; e2 < f3.length; e2++) {
      var g = f3[e2];
      d2 = b2;
      var h2 = a2.responseState, m2 = g.id, q2 = g.errorDigest, r5 = g.errorMessage, v4 = g.errorComponentStack;
      p3(d2, h2.startInlineScript);
      h2.sentClientRenderFunction ? p3(d2, Nb2) : (h2.sentClientRenderFunction = true, p3(
        d2,
        Mb
      ));
      if (null === m2)
        throw Error(k3(395));
      p3(d2, m2);
      p3(d2, Ob2);
      if (q2 || r5 || v4)
        p3(d2, Qb2), p3(d2, u3(Sb2(q2 || "")));
      if (r5 || v4)
        p3(d2, Qb2), p3(d2, u3(Sb2(r5 || "")));
      v4 && (p3(d2, Qb2), p3(d2, u3(Sb2(v4))));
      if (!t3(d2, Pb2))
        ;
    }
    f3.splice(0, e2);
    var A4 = a2.completedBoundaries;
    for (e2 = 0; e2 < A4.length; e2++)
      if (!jd2(a2, b2, A4[e2]))
        ;
    A4.splice(0, e2);
    ba(b2);
    l$12 = new Uint8Array(512);
    n3 = 0;
    var F4 = a2.partialBoundaries;
    for (e2 = 0; e2 < F4.length; e2++) {
      var G4 = F4[e2];
      a: {
        f3 = a2;
        g = b2;
        var ma3 = G4.completedSegments;
        for (h2 = 0; h2 < ma3.length; h2++)
          if (!kd2(
            f3,
            g,
            G4,
            ma3[h2]
          )) {
            h2++;
            ma3.splice(0, h2);
            var Fb3 = false;
            break a;
          }
        ma3.splice(0, h2);
        Fb3 = true;
      }
      if (!Fb3) {
        a2.destination = null;
        e2++;
        F4.splice(0, e2);
        return;
      }
    }
    F4.splice(0, e2);
    var na2 = a2.completedBoundaries;
    for (e2 = 0; e2 < na2.length; e2++)
      if (!jd2(a2, b2, na2[e2]))
        ;
    na2.splice(0, e2);
  } finally {
    ba(b2), 0 === a2.allPendingTasks && 0 === a2.pingedTasks.length && 0 === a2.clientRenderedBoundaries.length && 0 === a2.completedBoundaries.length && b2.close();
  }
}
function ld2(a2, b2) {
  try {
    var c2 = a2.abortableTasks;
    c2.forEach(function(c3) {
      return ed2(c3, a2, b2);
    });
    c2.clear();
    null !== a2.destination && fd2(a2, a2.destination);
  } catch (d2) {
    Y2(a2, d2), Vc2(a2, d2);
  }
}
function getContext(rendererContextResult) {
  if (contexts.has(rendererContextResult)) {
    return contexts.get(rendererContextResult);
  }
  const ctx = {
    currentIndex: 0,
    get id() {
      return ID_PREFIX + this.currentIndex.toString();
    }
  };
  contexts.set(rendererContextResult, ctx);
  return ctx;
}
function incrementId(rendererContextResult) {
  const ctx = getContext(rendererContextResult);
  const id3 = ctx.id;
  ctx.currentIndex++;
  return id3;
}
function errorIsComingFromPreactComponent(err) {
  return err.message && (err.message.startsWith("Cannot read property '__H'") || err.message.includes("(reading '__H')"));
}
async function check(Component, props, children) {
  if (typeof Component === "object") {
    return Component["$$typeof"].toString().slice("Symbol(".length).startsWith("react");
  }
  if (typeof Component !== "function")
    return false;
  if (Component.name === "QwikComponent")
    return false;
  if (typeof Component === "function" && Component["$$typeof"] === Symbol.for("react.forward_ref"))
    return false;
  if (Component.prototype != null && typeof Component.prototype.render === "function") {
    return React.Component.isPrototypeOf(Component) || React.PureComponent.isPrototypeOf(Component);
  }
  let error2 = null;
  let isReactComponent2 = false;
  function Tester(...args) {
    try {
      const vnode = Component(...args);
      if (vnode && vnode["$$typeof"] === reactTypeof) {
        isReactComponent2 = true;
      }
    } catch (err) {
      if (!errorIsComingFromPreactComponent(err)) {
        error2 = err;
      }
    }
    return React.createElement("div");
  }
  await renderToStaticMarkup(Tester, props, children, {});
  if (error2) {
    throw error2;
  }
  return isReactComponent2;
}
async function getNodeWritable() {
  let nodeStreamBuiltinModuleName = "node:stream";
  let { Writable } = await import(
    /* @vite-ignore */
    nodeStreamBuiltinModuleName
  );
  return Writable;
}
function needsHydration(metadata) {
  return metadata.astroStaticSlot ? !!metadata.hydrate : true;
}
async function renderToStaticMarkup(Component, props, { default: children, ...slotted }, metadata) {
  let prefix;
  if (this && this.result) {
    prefix = incrementId(this.result);
  }
  const attrs = { prefix };
  delete props["class"];
  const slots = {};
  for (const [key, value] of Object.entries(slotted)) {
    const name = slotName(key);
    slots[name] = React.createElement(StaticHtml, {
      hydrate: needsHydration(metadata),
      value,
      name
    });
  }
  const newProps = {
    ...props,
    ...slots
  };
  const newChildren = children ?? props.children;
  if (children && opts.experimentalReactChildren) {
    attrs["data-react-children"] = true;
    const convert2 = await init_vnode_children_Gh7ykD0n().then(() => vnode_children_Gh7ykD0n_exports).then((mod) => mod.default);
    newProps.children = convert2(children);
  } else if (newChildren != null) {
    newProps.children = React.createElement(StaticHtml, {
      hydrate: needsHydration(metadata),
      value: newChildren
    });
  }
  const vnode = React.createElement(Component, newProps);
  const renderOptions = {
    identifierPrefix: prefix
  };
  let html;
  if (metadata?.hydrate) {
    if ("renderToReadableStream" in server_browser) {
      html = await renderToReadableStreamAsync(vnode, renderOptions);
    } else {
      html = await renderToPipeableStreamAsync(vnode, renderOptions);
    }
  } else {
    if ("renderToReadableStream" in server_browser) {
      html = await renderToReadableStreamAsync(vnode, renderOptions);
    } else {
      html = await renderToStaticNodeStreamAsync(vnode, renderOptions);
    }
  }
  return { html, attrs };
}
async function renderToPipeableStreamAsync(vnode, options) {
  const Writable = await getNodeWritable();
  let html = "";
  return new Promise((resolve, reject) => {
    let error2 = void 0;
    let stream = server_browser.renderToPipeableStream(vnode, {
      ...options,
      onError(err) {
        error2 = err;
        reject(error2);
      },
      onAllReady() {
        stream.pipe(
          new Writable({
            write(chunk, _encoding, callback) {
              html += chunk.toString("utf-8");
              callback();
            },
            destroy() {
              resolve(html);
            }
          })
        );
      }
    });
  });
}
async function renderToStaticNodeStreamAsync(vnode, options) {
  const Writable = await getNodeWritable();
  let html = "";
  return new Promise((resolve, reject) => {
    let stream = server_browser.renderToStaticNodeStream(vnode, options);
    stream.on("error", (err) => {
      reject(err);
    });
    stream.pipe(
      new Writable({
        write(chunk, _encoding, callback) {
          html += chunk.toString("utf-8");
          callback();
        },
        destroy() {
          resolve(html);
        }
      })
    );
  });
}
async function readResult(stream) {
  const reader = stream.getReader();
  let result = "";
  const decoder3 = new TextDecoder("utf-8");
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      if (value) {
        result += decoder3.decode(value);
      } else {
        decoder3.decode(new Uint8Array());
      }
      return result;
    }
    result += decoder3.decode(value, { stream: true });
  }
}
async function renderToReadableStreamAsync(vnode, options) {
  return await readResult(await server_browser.renderToReadableStream(vnode, options));
}
var server_browser, reactDomServerLegacy_browser_production_min, aa$1, p$12, fa$1, ha$1, ia$1, t$13, ka$1, u$12, ma2, na, oa$1, pa$1, qa$1, sa$1, wa$1, xa$1, Ca$1, B$12, Ga$1, Ha$1, Ia$1, Ja$1, Ka$1, La$1, Ma$1, Na$1, Oa$1, Pa$1, Qa$1, Ra$1, Sa$1, Ta$1, Ua$1, Va$1, Wa$1, Ya$1, E$12, db$1, fb$1, H$12, ib$1, jb$1, lb$1, I$12, ob$1, J$1, K$12, L$12, M$12, N$12, O$12, P$12, xb$1, S$12, yb$1, reactDomServer_browser_production_min, aa2, l$12, n3, ca3, x3, ea2, fa2, ha2, z3, ja2, B3, la2, oa2, pa2, qa2, ra2, sa2, ta2, ua2, va2, wa2, xa, Ca2, Ea2, Fa2, Ga2, Ha2, H2, I3, E3, Ja2, K2, Ka2, Ma2, Oa2, Pa2, Qa2, Ra2, Ta2, Ua2, Va2, Wa2, Xa2, Ya2, Za2, $a, ab2, bb2, cb2, db3, eb2, gb2, hb2, ib2, jb2, kb2, lb2, mb2, nb2, ob2, pb2, qb2, rb2, sb2, tb2, ub2, vb2, wb2, xb2, yb2, zb2, Ab2, Db2, Eb2, Gb2, Hb2, Ib2, Jb2, Kb2, Lb2, Mb, Nb2, Ob2, Pb2, Qb2, Rb2, N3, Tb2, Ub2, Vb2, Wb2, Xb2, Yb2, Zb2, $b2, ac2, bc2, cc2, dc2, ec2, fc2, gc2, hc2, ic2, kc2, O3, qc2, sc2, uc2, wc2, xc2, zc2, R4, Ac2, Bc2, S3, T3, Cc2, U2, V2, Dc2, Oc2, Nc2, Pc2, l3, s2, contexts, ID_PREFIX, StaticHtml, opts, slotName, reactTypeof, _renderer0, renderers;
var init_renderers = __esm({
  async ".wrangler/tmp/pages-KkpaTB/renderers.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_cvs_qudRXU8T();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    server_browser = {};
    reactDomServerLegacy_browser_production_min = {};
    aa$1 = reactExports;
    p$12 = Object.prototype.hasOwnProperty;
    fa$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    ha$1 = {};
    ia$1 = {};
    t$13 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      t$13[a2] = new r4(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      t$13[b2] = new r4(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      t$13[a2] = new r4(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    ka$1 = /[\-:]([a-z])/g;
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        ka$1,
        la$1
      );
      t$13[b2] = new r4(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(ka$1, la$1);
      t$13[b2] = new r4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(ka$1, la$1);
      t$13[b2] = new r4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    t$13.xlinkHref = new r4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      t$13[a2] = new r4(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    u$12 = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    ma2 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(u$12).forEach(function(a2) {
      ma2.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        u$12[b2] = u$12[a2];
      });
    });
    na = /["'&<>]/;
    oa$1 = /([A-Z])/g;
    pa$1 = /^ms-/;
    qa$1 = Array.isArray;
    sa$1 = /* @__PURE__ */ new Map();
    wa$1 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    xa$1 = /* @__PURE__ */ new Map();
    Ca$1 = /[<\u2028\u2029]/g;
    B$12 = Object.assign;
    Ga$1 = Symbol.for("react.element");
    Ha$1 = Symbol.for("react.portal");
    Ia$1 = Symbol.for("react.fragment");
    Ja$1 = Symbol.for("react.strict_mode");
    Ka$1 = Symbol.for("react.profiler");
    La$1 = Symbol.for("react.provider");
    Ma$1 = Symbol.for("react.context");
    Na$1 = Symbol.for("react.forward_ref");
    Oa$1 = Symbol.for("react.suspense");
    Pa$1 = Symbol.for("react.suspense_list");
    Qa$1 = Symbol.for("react.memo");
    Ra$1 = Symbol.for("react.lazy");
    Sa$1 = Symbol.for("react.scope");
    Ta$1 = Symbol.for("react.debug_trace_mode");
    Ua$1 = Symbol.for("react.legacy_hidden");
    Va$1 = Symbol.for("react.default_value");
    Wa$1 = Symbol.iterator;
    Ya$1 = {};
    E$12 = null;
    db$1 = { isMounted: function() {
      return false;
    }, enqueueSetState: function(a2, b2) {
      a2 = a2._reactInternals;
      null !== a2.queue && a2.queue.push(b2);
    }, enqueueReplaceState: function(a2, b2) {
      a2 = a2._reactInternals;
      a2.replace = true;
      a2.queue = [b2];
    }, enqueueForceUpdate: function() {
    } };
    fb$1 = { id: 1, overflow: "" };
    H$12 = Math.clz32 ? Math.clz32 : hb$1;
    ib$1 = Math.log;
    jb$1 = Math.LN2;
    lb$1 = "function" === typeof Object.is ? Object.is : kb$1;
    I$12 = null;
    ob$1 = null;
    J$1 = null;
    K$12 = null;
    L$12 = false;
    M$12 = false;
    N$12 = 0;
    O$12 = null;
    P$12 = 0;
    xb$1 = { readContext: function(a2) {
      return a2._currentValue2;
    }, useContext: function(a2) {
      Q$12();
      return a2._currentValue2;
    }, useMemo: vb$1, useReducer: tb$1, useRef: function(a2) {
      I$12 = Q$12();
      K$12 = qb$1();
      var b2 = K$12.memoizedState;
      return null === b2 ? (a2 = { current: a2 }, K$12.memoizedState = a2) : b2;
    }, useState: function(a2) {
      return tb$1(sb$1, a2);
    }, useInsertionEffect: R$12, useLayoutEffect: function() {
    }, useCallback: function(a2, b2) {
      return vb$1(function() {
        return a2;
      }, b2);
    }, useImperativeHandle: R$12, useEffect: R$12, useDebugValue: R$12, useDeferredValue: function(a2) {
      Q$12();
      return a2;
    }, useTransition: function() {
      Q$12();
      return [
        false,
        wb$1
      ];
    }, useId: function() {
      var a2 = ob$1.treeContext;
      var b2 = a2.overflow;
      a2 = a2.id;
      a2 = (a2 & ~(1 << 32 - H$12(a2) - 1)).toString(32) + b2;
      var c2 = S$12;
      if (null === c2)
        throw Error(l$22(404));
      b2 = N$12++;
      a2 = ":" + c2.idPrefix + "R" + a2;
      0 < b2 && (a2 += "H" + b2.toString(32));
      return a2 + ":";
    }, useMutableSource: function(a2, b2) {
      Q$12();
      return b2(a2._source);
    }, useSyncExternalStore: function(a2, b2, c2) {
      if (void 0 === c2)
        throw Error(l$22(407));
      return c2();
    } };
    S$12 = null;
    yb$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    reactDomServerLegacy_browser_production_min.renderToNodeStream = function() {
      throw Error(l$22(207));
    };
    reactDomServerLegacy_browser_production_min.renderToStaticMarkup = function(a2, b2) {
      return Tb$1(a2, b2, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    reactDomServerLegacy_browser_production_min.renderToStaticNodeStream = function() {
      throw Error(l$22(208));
    };
    reactDomServerLegacy_browser_production_min.renderToString = function(a2, b2) {
      return Tb$1(a2, b2, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    reactDomServerLegacy_browser_production_min.version = "18.2.0";
    reactDomServer_browser_production_min = {};
    aa2 = reactExports;
    l$12 = null;
    n3 = 0;
    ca3 = new TextEncoder();
    x3 = Object.prototype.hasOwnProperty;
    ea2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    fa2 = {};
    ha2 = {};
    z3 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z3[a2] = new y2(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      z3[b2] = new y2(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z3[a2] = new y2(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z3[a2] = new y2(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z3[a2] = new y2(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z3[a2] = new y2(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z3[a2] = new y2(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z3[a2] = new y2(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z3[a2] = new y2(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    ja2 = /[\-:]([a-z])/g;
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        ja2,
        ka2
      );
      z3[b2] = new y2(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(ja2, ka2);
      z3[b2] = new y2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(ja2, ka2);
      z3[b2] = new y2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z3[a2] = new y2(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z3.xlinkHref = new y2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z3[a2] = new y2(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    B3 = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    la2 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(B3).forEach(function(a2) {
      la2.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        B3[b2] = B3[a2];
      });
    });
    oa2 = /["'&<>]/;
    pa2 = /([A-Z])/g;
    qa2 = /^ms-/;
    ra2 = Array.isArray;
    sa2 = w4("<script>");
    ta2 = w4("<\/script>");
    ua2 = w4('<script src="');
    va2 = w4('<script type="module" src="');
    wa2 = w4('" async=""><\/script>');
    xa = /(<\/|<)(s)(cript)/gi;
    Ca2 = w4("<!-- -->");
    Ea2 = /* @__PURE__ */ new Map();
    Fa2 = w4(' style="');
    Ga2 = w4(":");
    Ha2 = w4(";");
    H2 = w4(" ");
    I3 = w4('="');
    E3 = w4('"');
    Ja2 = w4('=""');
    K2 = w4(">");
    Ka2 = w4("/>");
    Ma2 = w4(' selected=""');
    Oa2 = w4("\n");
    Pa2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    Qa2 = /* @__PURE__ */ new Map();
    Ra2 = w4("<!DOCTYPE html>");
    Ta2 = w4("</");
    Ua2 = w4(">");
    Va2 = w4('<template id="');
    Wa2 = w4('"></template>');
    Xa2 = w4("<!--$-->");
    Ya2 = w4('<!--$?--><template id="');
    Za2 = w4('"></template>');
    $a = w4("<!--$!-->");
    ab2 = w4("<!--/$-->");
    bb2 = w4("<template");
    cb2 = w4('"');
    db3 = w4(' data-dgst="');
    w4(' data-msg="');
    w4(' data-stck="');
    eb2 = w4("></template>");
    gb2 = w4('<div hidden id="');
    hb2 = w4('">');
    ib2 = w4("</div>");
    jb2 = w4('<svg aria-hidden="true" style="display:none" id="');
    kb2 = w4('">');
    lb2 = w4("</svg>");
    mb2 = w4('<math aria-hidden="true" style="display:none" id="');
    nb2 = w4('">');
    ob2 = w4("</math>");
    pb2 = w4('<table hidden id="');
    qb2 = w4('">');
    rb2 = w4("</table>");
    sb2 = w4('<table hidden><tbody id="');
    tb2 = w4('">');
    ub2 = w4("</tbody></table>");
    vb2 = w4('<table hidden><tr id="');
    wb2 = w4('">');
    xb2 = w4("</tr></table>");
    yb2 = w4('<table hidden><colgroup id="');
    zb2 = w4('">');
    Ab2 = w4("</colgroup></table>");
    Db2 = w4('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("');
    Eb2 = w4('$RS("');
    Gb2 = w4('","');
    Hb2 = w4('")<\/script>');
    Ib2 = w4('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("');
    Jb2 = w4('$RC("');
    Kb2 = w4('","');
    Lb2 = w4('")<\/script>');
    Mb = w4('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("');
    Nb2 = w4('$RX("');
    Ob2 = w4('"');
    Pb2 = w4(")<\/script>");
    Qb2 = w4(",");
    Rb2 = /[<\u2028\u2029]/g;
    N3 = Object.assign;
    Tb2 = Symbol.for("react.element");
    Ub2 = Symbol.for("react.portal");
    Vb2 = Symbol.for("react.fragment");
    Wb2 = Symbol.for("react.strict_mode");
    Xb2 = Symbol.for("react.profiler");
    Yb2 = Symbol.for("react.provider");
    Zb2 = Symbol.for("react.context");
    $b2 = Symbol.for("react.forward_ref");
    ac2 = Symbol.for("react.suspense");
    bc2 = Symbol.for("react.suspense_list");
    cc2 = Symbol.for("react.memo");
    dc2 = Symbol.for("react.lazy");
    ec2 = Symbol.for("react.scope");
    fc2 = Symbol.for("react.debug_trace_mode");
    gc2 = Symbol.for("react.legacy_hidden");
    hc2 = Symbol.for("react.default_value");
    ic2 = Symbol.iterator;
    kc2 = {};
    O3 = null;
    qc2 = { isMounted: function() {
      return false;
    }, enqueueSetState: function(a2, b2) {
      a2 = a2._reactInternals;
      null !== a2.queue && a2.queue.push(b2);
    }, enqueueReplaceState: function(a2, b2) {
      a2 = a2._reactInternals;
      a2.replace = true;
      a2.queue = [b2];
    }, enqueueForceUpdate: function() {
    } };
    sc2 = { id: 1, overflow: "" };
    uc2 = Math.clz32 ? Math.clz32 : vc2;
    wc2 = Math.log;
    xc2 = Math.LN2;
    zc2 = "function" === typeof Object.is ? Object.is : yc2;
    R4 = null;
    Ac2 = null;
    Bc2 = null;
    S3 = null;
    T3 = false;
    Cc2 = false;
    U2 = 0;
    V2 = null;
    Dc2 = 0;
    Oc2 = { readContext: function(a2) {
      return a2._currentValue;
    }, useContext: function(a2) {
      W3();
      return a2._currentValue;
    }, useMemo: Kc2, useReducer: Ic2, useRef: function(a2) {
      R4 = W3();
      S3 = Fc2();
      var b2 = S3.memoizedState;
      return null === b2 ? (a2 = { current: a2 }, S3.memoizedState = a2) : b2;
    }, useState: function(a2) {
      return Ic2(Hc2, a2);
    }, useInsertionEffect: Mc2, useLayoutEffect: function() {
    }, useCallback: function(a2, b2) {
      return Kc2(function() {
        return a2;
      }, b2);
    }, useImperativeHandle: Mc2, useEffect: Mc2, useDebugValue: Mc2, useDeferredValue: function(a2) {
      W3();
      return a2;
    }, useTransition: function() {
      W3();
      return [false, Lc2];
    }, useId: function() {
      var a2 = Ac2.treeContext;
      var b2 = a2.overflow;
      a2 = a2.id;
      a2 = (a2 & ~(1 << 32 - uc2(a2) - 1)).toString(32) + b2;
      var c2 = Nc2;
      if (null === c2)
        throw Error(k3(404));
      b2 = U2++;
      a2 = ":" + c2.idPrefix + "R" + a2;
      0 < b2 && (a2 += "H" + b2.toString(32));
      return a2 + ":";
    }, useMutableSource: function(a2, b2) {
      W3();
      return b2(a2._source);
    }, useSyncExternalStore: function(a2, b2, c2) {
      if (void 0 === c2)
        throw Error(k3(407));
      return c2();
    } };
    Nc2 = null;
    Pc2 = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    reactDomServer_browser_production_min.renderToReadableStream = function(a2, b2) {
      return new Promise(function(c2, d2) {
        var f3, e2, g = new Promise(function(a3, b3) {
          e2 = a3;
          f3 = b3;
        }), h2 = Rc2(a2, za2(b2 ? b2.identifierPrefix : void 0, b2 ? b2.nonce : void 0, b2 ? b2.bootstrapScriptContent : void 0, b2 ? b2.bootstrapScripts : void 0, b2 ? b2.bootstrapModules : void 0), Aa2(b2 ? b2.namespaceURI : void 0), b2 ? b2.progressiveChunkSize : void 0, b2 ? b2.onError : void 0, e2, function() {
          var a3 = new ReadableStream({ type: "bytes", pull: function(a4) {
            if (1 === h2.status)
              h2.status = 2, da2(a4, h2.fatalError);
            else if (2 !== h2.status && null === h2.destination) {
              h2.destination = a4;
              try {
                fd2(h2, a4);
              } catch (A4) {
                Y2(h2, A4), Vc2(h2, A4);
              }
            }
          }, cancel: function() {
            ld2(h2);
          } }, { highWaterMark: 0 });
          a3.allReady = g;
          c2(a3);
        }, function(a3) {
          g.catch(function() {
          });
          d2(a3);
        }, f3);
        if (b2 && b2.signal) {
          var m2 = b2.signal, q2 = function() {
            ld2(h2, m2.reason);
            m2.removeEventListener("abort", q2);
          };
          m2.addEventListener("abort", q2);
        }
        Uc2(h2);
      });
    };
    reactDomServer_browser_production_min.version = "18.2.0";
    {
      l3 = reactDomServerLegacy_browser_production_min;
      s2 = reactDomServer_browser_production_min;
    }
    server_browser.version = l3.version;
    server_browser.renderToString = l3.renderToString;
    server_browser.renderToStaticMarkup = l3.renderToStaticMarkup;
    server_browser.renderToNodeStream = l3.renderToNodeStream;
    server_browser.renderToStaticNodeStream = l3.renderToStaticNodeStream;
    server_browser.renderToReadableStream = s2.renderToReadableStream;
    contexts = /* @__PURE__ */ new WeakMap();
    ID_PREFIX = "r";
    StaticHtml = ({ value, name, hydrate = true }) => {
      if (!value)
        return null;
      const tagName = hydrate ? "astro-slot" : "astro-static-slot";
      return reactExports.createElement(tagName, {
        name,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: { __html: value }
      });
    };
    StaticHtml.shouldComponentUpdate = () => false;
    opts = {
      experimentalReactChildren: false
    };
    slotName = (str) => str.trim().replace(/[-_]([a-z])/g, (_3, w5) => w5.toUpperCase());
    reactTypeof = Symbol.for("react.element");
    _renderer0 = {
      check,
      renderToStaticMarkup,
      supportsAstroStaticSlot: true
    };
    renderers = [Object.assign({ "name": "@astrojs/react", "clientEntrypoint": "@astrojs/react/client.js", "serverEntrypoint": "@astrojs/react/server.js" }, { ssr: _renderer0 })];
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/astro/assets-service_i7oLR0nI.mjs
var assets_service_i7oLR0nI_exports = {};
__export(assets_service_i7oLR0nI_exports, {
  D: () => DEFAULT_HASH_PROPS,
  a: () => isESMImportedImage,
  b: () => isLocalService,
  c: () => isRemotePath,
  d: () => isRemoteAllowed,
  e: () => appendForwardSlash,
  f: () => fileExtension,
  g: () => removeTrailingForwardSlash,
  h: () => collapseDuplicateSlashes,
  i: () => isRemoteImage,
  j: () => joinPaths,
  n: () => noop4,
  p: () => prependForwardSlash,
  r: () => resolveSrc,
  s: () => slash,
  t: () => trimSlashes2
});
function appendForwardSlash(path) {
  return path.endsWith("/") ? path : path + "/";
}
function prependForwardSlash(path) {
  return path[0] === "/" ? path : "/" + path;
}
function collapseDuplicateSlashes(path) {
  return path.replace(/(?<!:)\/{2,}/g, "/");
}
function removeTrailingForwardSlash(path) {
  return path.endsWith("/") ? path.slice(0, path.length - 1) : path;
}
function removeLeadingForwardSlash(path) {
  return path.startsWith("/") ? path.substring(1) : path;
}
function trimSlashes2(path) {
  return path.replace(/^\/|\/$/g, "");
}
function isString(path) {
  return typeof path === "string" || path instanceof String;
}
function joinPaths(...paths) {
  return paths.filter(isString).map((path, i2) => {
    if (i2 === 0) {
      return removeTrailingForwardSlash(path);
    } else if (i2 === paths.length - 1) {
      return removeLeadingForwardSlash(path);
    } else {
      return trimSlashes2(path);
    }
  }).join("/");
}
function isRemotePath(src) {
  return /^(?:http|ftp|https|ws):?\/\//.test(src) || src.startsWith("data:");
}
function slash(path) {
  return path.replace(/\\/g, "/");
}
function fileExtension(path) {
  const ext = path.split(".").pop();
  return ext !== path ? `.${ext}` : "";
}
function isESMImportedImage(src) {
  return typeof src === "object";
}
function isRemoteImage(src) {
  return typeof src === "string";
}
async function resolveSrc(src) {
  return typeof src === "object" && "then" in src ? (await src).default ?? await src : src;
}
function matchPattern(url, remotePattern) {
  return matchProtocol(url, remotePattern.protocol) && matchHostname(url, remotePattern.hostname, true) && matchPort(url, remotePattern.port) && matchPathname(url, remotePattern.pathname, true);
}
function matchPort(url, port) {
  return !port || port === url.port;
}
function matchProtocol(url, protocol) {
  return !protocol || protocol === url.protocol.slice(0, -1);
}
function matchHostname(url, hostname, allowWildcard) {
  if (!hostname) {
    return true;
  } else if (!allowWildcard || !hostname.startsWith("*")) {
    return hostname === url.hostname;
  } else if (hostname.startsWith("**.")) {
    const slicedHostname = hostname.slice(2);
    return slicedHostname !== url.hostname && url.hostname.endsWith(slicedHostname);
  } else if (hostname.startsWith("*.")) {
    const slicedHostname = hostname.slice(1);
    const additionalSubdomains = url.hostname.replace(slicedHostname, "").split(".").filter(Boolean);
    return additionalSubdomains.length === 1;
  }
  return false;
}
function matchPathname(url, pathname, allowWildcard) {
  if (!pathname) {
    return true;
  } else if (!allowWildcard || !pathname.endsWith("*")) {
    return pathname === url.pathname;
  } else if (pathname.endsWith("/**")) {
    const slicedPathname = pathname.slice(0, -2);
    return slicedPathname !== url.pathname && url.pathname.startsWith(slicedPathname);
  } else if (pathname.endsWith("/*")) {
    const slicedPathname = pathname.slice(0, -1);
    const additionalPathChunks = url.pathname.replace(slicedPathname, "").split("/").filter(Boolean);
    return additionalPathChunks.length === 1;
  }
  return false;
}
function isRemoteAllowed(src, {
  domains = [],
  remotePatterns = []
}) {
  if (!isRemotePath(src))
    return false;
  const url = new URL(src);
  return domains.some((domain) => matchHostname(url, domain)) || remotePatterns.some((remotePattern) => matchPattern(url, remotePattern));
}
function isLocalService(service) {
  if (!service) {
    return false;
  }
  return "transform" in service;
}
function getTargetDimensions(options) {
  let targetWidth = options.width;
  let targetHeight = options.height;
  if (isESMImportedImage(options.src)) {
    const aspectRatio = options.src.width / options.src.height;
    if (targetHeight && !targetWidth) {
      targetWidth = Math.round(targetHeight * aspectRatio);
    } else if (targetWidth && !targetHeight) {
      targetHeight = Math.round(targetWidth / aspectRatio);
    } else if (!targetWidth && !targetHeight) {
      targetWidth = options.src.width;
      targetHeight = options.src.height;
    }
  }
  return {
    targetWidth,
    targetHeight
  };
}
var VALID_SUPPORTED_FORMATS, DEFAULT_OUTPUT_FORMAT, DEFAULT_HASH_PROPS, baseService, noopService, noop_default, noop4;
var init_assets_service_i7oLR0nI = __esm({
  ".wrangler/tmp/pages-KkpaTB/chunks/astro/assets-service_i7oLR0nI.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_astro_BO0wYrHs();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    VALID_SUPPORTED_FORMATS = [
      "jpeg",
      "jpg",
      "png",
      "tiff",
      "webp",
      "gif",
      "svg",
      "avif"
    ];
    DEFAULT_OUTPUT_FORMAT = "webp";
    DEFAULT_HASH_PROPS = ["src", "width", "height", "format", "quality"];
    baseService = {
      propertiesToHash: DEFAULT_HASH_PROPS,
      validateOptions(options) {
        if (!options.src || typeof options.src !== "string" && typeof options.src !== "object") {
          throw new AstroError({
            ...ExpectedImage,
            message: ExpectedImage.message(
              JSON.stringify(options.src),
              typeof options.src,
              JSON.stringify(options, (_3, v4) => v4 === void 0 ? null : v4)
            )
          });
        }
        if (!isESMImportedImage(options.src)) {
          if (options.src.startsWith("/@fs/") || !isRemotePath(options.src) && !options.src.startsWith("/")) {
            throw new AstroError({
              ...LocalImageUsedWrongly,
              message: LocalImageUsedWrongly.message(options.src)
            });
          }
          let missingDimension;
          if (!options.width && !options.height) {
            missingDimension = "both";
          } else if (!options.width && options.height) {
            missingDimension = "width";
          } else if (options.width && !options.height) {
            missingDimension = "height";
          }
          if (missingDimension) {
            throw new AstroError({
              ...MissingImageDimension,
              message: MissingImageDimension.message(missingDimension, options.src)
            });
          }
        } else {
          if (!VALID_SUPPORTED_FORMATS.includes(options.src.format)) {
            throw new AstroError({
              ...UnsupportedImageFormat,
              message: UnsupportedImageFormat.message(
                options.src.format,
                options.src.src,
                VALID_SUPPORTED_FORMATS
              )
            });
          }
          if (options.widths && options.densities) {
            throw new AstroError(IncompatibleDescriptorOptions);
          }
          if (options.src.format === "svg") {
            options.format = "svg";
          }
          if (options.src.format === "svg" && options.format !== "svg" || options.src.format !== "svg" && options.format === "svg") {
            throw new AstroError(UnsupportedImageConversion);
          }
        }
        if (!options.format) {
          options.format = DEFAULT_OUTPUT_FORMAT;
        }
        if (options.width)
          options.width = Math.round(options.width);
        if (options.height)
          options.height = Math.round(options.height);
        return options;
      },
      getHTMLAttributes(options) {
        const { targetWidth, targetHeight } = getTargetDimensions(options);
        const { src, width, height, format: format2, quality, densities, widths, formats, ...attributes } = options;
        return {
          ...attributes,
          width: targetWidth,
          height: targetHeight,
          loading: attributes.loading ?? "lazy",
          decoding: attributes.decoding ?? "async"
        };
      },
      getSrcSet(options) {
        const srcSet = [];
        const { targetWidth } = getTargetDimensions(options);
        const { widths, densities } = options;
        const targetFormat = options.format ?? DEFAULT_OUTPUT_FORMAT;
        let imageWidth = options.width;
        let maxWidth = Infinity;
        if (isESMImportedImage(options.src)) {
          imageWidth = options.src.width;
          maxWidth = imageWidth;
        }
        const {
          width: transformWidth,
          height: transformHeight,
          ...transformWithoutDimensions
        } = options;
        const allWidths = [];
        if (densities) {
          const densityValues = densities.map((density) => {
            if (typeof density === "number") {
              return density;
            } else {
              return parseFloat(density);
            }
          });
          const densityWidths = densityValues.sort().map((density) => Math.round(targetWidth * density));
          allWidths.push(
            ...densityWidths.map((width, index3) => ({
              maxTargetWidth: Math.min(width, maxWidth),
              descriptor: `${densityValues[index3]}x`
            }))
          );
        } else if (widths) {
          allWidths.push(
            ...widths.map((width) => ({
              maxTargetWidth: Math.min(width, maxWidth),
              descriptor: `${width}w`
            }))
          );
        }
        for (const { maxTargetWidth, descriptor } of allWidths) {
          const srcSetTransform = { ...transformWithoutDimensions };
          if (maxTargetWidth !== imageWidth) {
            srcSetTransform.width = maxTargetWidth;
          } else {
            if (options.width && options.height) {
              srcSetTransform.width = options.width;
              srcSetTransform.height = options.height;
            }
          }
          srcSet.push({
            transform: srcSetTransform,
            descriptor,
            attributes: {
              type: `image/${targetFormat}`
            }
          });
        }
        return srcSet;
      },
      getURL(options, imageConfig2) {
        const searchParams = new URLSearchParams();
        if (isESMImportedImage(options.src)) {
          searchParams.append("href", options.src.src);
        } else if (isRemoteAllowed(options.src, imageConfig2)) {
          searchParams.append("href", options.src);
        } else {
          return options.src;
        }
        const params = {
          w: "width",
          h: "height",
          q: "quality",
          f: "format"
        };
        Object.entries(params).forEach(([param, key]) => {
          options[key] && searchParams.append(param, options[key].toString());
        });
        const imageEndpoint = joinPaths("/", "/_image");
        return `${imageEndpoint}?${searchParams}`;
      },
      parseURL(url) {
        const params = url.searchParams;
        if (!params.has("href")) {
          return void 0;
        }
        const transform = {
          src: params.get("href"),
          width: params.has("w") ? parseInt(params.get("w")) : void 0,
          height: params.has("h") ? parseInt(params.get("h")) : void 0,
          format: params.get("f"),
          quality: params.get("q")
        };
        return transform;
      }
    };
    noopService = {
      ...baseService,
      propertiesToHash: ["src"],
      async transform(inputBuffer, transformOptions) {
        return {
          data: inputBuffer,
          format: transformOptions.format
        };
      }
    };
    noop_default = noopService;
    noop4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: noop_default
    }, Symbol.toStringTag, { value: "Module" }));
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/pages/generic_Dk8lQKaX.mjs
var generic_Dk8lQKaX_exports = {};
__export(generic_Dk8lQKaX_exports, {
  GET: () => GET
});
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null);
  this._extensions = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < arguments.length; i2++) {
    this.define(arguments[i2]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
function readUInt(input, bits, offset2, isBigEndian) {
  offset2 = offset2 || 0;
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = "readUInt" + bits + endian;
  return methods[methodName](input, offset2);
}
function readBox(buffer, offset2) {
  if (buffer.length - offset2 < 4)
    return;
  const boxSize = readUInt32BE(buffer, offset2);
  if (buffer.length - offset2 < boxSize)
    return;
  return {
    name: toUTF8String(buffer, 4 + offset2, 8 + offset2),
    offset: offset2,
    size: boxSize
  };
}
function findBox(buffer, boxName, offset2) {
  while (offset2 < buffer.length) {
    const box = readBox(buffer, offset2);
    if (!box)
      break;
    if (box.name === boxName)
      return box;
    offset2 += box.size;
  }
}
function getSizeFromOffset(input, offset2) {
  const value = input[offset2];
  return value === 0 ? 256 : value;
}
function getImageSize$1(input, imageIndex) {
  const offset2 = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset2 + 1),
    width: getSizeFromOffset(input, offset2)
  };
}
function detectBrands(buffer, start, end) {
  let brandsDetected = {};
  for (let i2 = start; i2 <= end; i2 += 4) {
    const brand = toUTF8String(buffer, i2, i2 + 4);
    if (brand in brandMap) {
      brandsDetected[brand] = 1;
    }
  }
  if ("avif" in brandsDetected) {
    return "avif";
  } else if ("heic" in brandsDetected || "heix" in brandsDetected || "hevc" in brandsDetected || "hevx" in brandsDetected) {
    return "heic";
  } else if ("mif1" in brandsDetected || "msf1" in brandsDetected) {
    return "heif";
  }
}
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize(type) {
  const size2 = ICON_TYPE_SIZE[type];
  return { width: size2, height: size2, type };
}
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index3) {
  return {
    height: readUInt16BE(input, index3),
    width: readUInt16BE(input, index3 + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset2 = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset2, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset2 + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index3) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index3);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index3) {
  if (index3 > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
function parseLength(len) {
  const m2 = unitsReg.exec(len);
  if (!m2) {
    return void 0;
  }
  return Math.round(Number(m2[1]) * (units[m2[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = root.match(extractorRegExps.width);
  const height = root.match(extractorRegExps.height);
  const viewbox = root.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
function readIFD(input, isBigEndian) {
  const ifdOffset = readUInt(input, 32, 4, isBigEndian);
  return input.slice(ifdOffset + 2);
}
function readValue(input, isBigEndian) {
  const low = readUInt(input, 16, 8, isBigEndian);
  const high = readUInt(input, 16, 10, isBigEndian);
  return (high << 16) + low;
}
function nextTag(input) {
  if (input.length > 24) {
    return input.slice(12);
  }
}
function extractTags(input, isBigEndian) {
  const tags = {};
  let temp = input;
  while (temp && temp.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type = readUInt(temp, 16, 2, isBigEndian);
    const length = readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) {
      break;
    } else {
      if (length === 1 && (type === 3 || type === 4)) {
        tags[code] = readValue(temp, isBigEndian);
      }
      temp = nextTag(temp);
    }
  }
  return tags;
}
function determineEndianness(input) {
  const signature = toUTF8String(input, 0, 2);
  if ("II" === signature) {
    return "LE";
  } else if ("MM" === signature) {
    return "BE";
  }
}
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
function detector(input) {
  const byte = input[0];
  const type = firstBytes.get(byte);
  if (type && typeHandlers.get(type).validate(input)) {
    return type;
  }
  return types2.find((fileType) => typeHandlers.get(fileType).validate(input));
}
function lookup2(input) {
  const type = detector(input);
  if (typeof type !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type) > -1) {
      throw new TypeError("disabled file type: " + type);
    }
    const size2 = typeHandlers.get(type).calculate(input);
    if (size2 !== void 0) {
      size2.type = size2.type ?? type;
      return size2;
    }
  }
  throw new TypeError("unsupported file type: " + type);
}
async function probe(url) {
  const response = await fetch(url);
  if (!response.body || !response.ok) {
    throw new Error("Failed to fetch image");
  }
  const reader = response.body.getReader();
  let done, value;
  let accumulatedChunks = new Uint8Array();
  while (!done) {
    const readResult2 = await reader.read();
    done = readResult2.done;
    if (done)
      break;
    if (readResult2.value) {
      value = readResult2.value;
      let tmp = new Uint8Array(accumulatedChunks.length + value.length);
      tmp.set(accumulatedChunks, 0);
      tmp.set(value, accumulatedChunks.length);
      accumulatedChunks = tmp;
      try {
        const dimensions = lookup2(accumulatedChunks);
        if (dimensions) {
          await reader.cancel();
          return dimensions;
        }
      } catch (error2) {
      }
    }
  }
  throw new Error("Failed to parse the size");
}
async function getConfiguredImageService() {
  if (!globalThis?.astroAsset?.imageService) {
    const { default: service } = await Promise.resolve().then(() => (init_assets_service_i7oLR0nI(), assets_service_i7oLR0nI_exports)).then((n5) => n5.n).catch((e2) => {
      const error2 = new AstroError(InvalidImageService);
      error2.cause = e2;
      throw error2;
    });
    if (!globalThis.astroAsset)
      globalThis.astroAsset = {};
    globalThis.astroAsset.imageService = service;
    return service;
  }
  return globalThis.astroAsset.imageService;
}
async function getImage$1(options, imageConfig2) {
  if (!options || typeof options !== "object") {
    throw new AstroError({
      ...ExpectedImageOptions,
      message: ExpectedImageOptions.message(JSON.stringify(options))
    });
  }
  if (typeof options.src === "undefined") {
    throw new AstroError({
      ...ExpectedImage,
      message: ExpectedImage.message(
        options.src,
        "undefined",
        JSON.stringify(options)
      )
    });
  }
  const service = await getConfiguredImageService();
  const resolvedOptions = {
    ...options,
    src: await resolveSrc(options.src)
  };
  if (options.inferSize && isRemoteImage(resolvedOptions.src)) {
    try {
      const result = await probe(resolvedOptions.src);
      resolvedOptions.width ??= result.width;
      resolvedOptions.height ??= result.height;
      delete resolvedOptions.inferSize;
    } catch {
      throw new AstroError({
        ...FailedToFetchRemoteImageDimensions,
        message: FailedToFetchRemoteImageDimensions.message(resolvedOptions.src)
      });
    }
  }
  const originalFilePath = isESMImportedImage(resolvedOptions.src) ? resolvedOptions.src.fsPath : void 0;
  const clonedSrc = isESMImportedImage(resolvedOptions.src) ? (
    // @ts-expect-error - clone is a private, hidden prop
    resolvedOptions.src.clone ?? resolvedOptions.src
  ) : resolvedOptions.src;
  resolvedOptions.src = clonedSrc;
  const validatedOptions = service.validateOptions ? await service.validateOptions(resolvedOptions, imageConfig2) : resolvedOptions;
  const srcSetTransforms = service.getSrcSet ? await service.getSrcSet(validatedOptions, imageConfig2) : [];
  let imageURL = await service.getURL(validatedOptions, imageConfig2);
  let srcSets = await Promise.all(
    srcSetTransforms.map(async (srcSet) => ({
      transform: srcSet.transform,
      url: await service.getURL(srcSet.transform, imageConfig2),
      descriptor: srcSet.descriptor,
      attributes: srcSet.attributes
    }))
  );
  if (isLocalService(service) && globalThis.astroAsset.addStaticImage && !(isRemoteImage(validatedOptions.src) && imageURL === validatedOptions.src)) {
    const propsToHash = service.propertiesToHash ?? DEFAULT_HASH_PROPS;
    imageURL = globalThis.astroAsset.addStaticImage(
      validatedOptions,
      propsToHash,
      originalFilePath
    );
    srcSets = srcSetTransforms.map((srcSet) => ({
      transform: srcSet.transform,
      url: globalThis.astroAsset.addStaticImage(srcSet.transform, propsToHash, originalFilePath),
      descriptor: srcSet.descriptor,
      attributes: srcSet.attributes
    }));
  }
  return {
    rawOptions: resolvedOptions,
    options: validatedOptions,
    src: imageURL,
    srcSet: {
      values: srcSets,
      attribute: srcSets.map((srcSet) => `${srcSet.url} ${srcSet.descriptor}`).join(", ")
    },
    attributes: service.getHTMLAttributes !== void 0 ? await service.getHTMLAttributes(validatedOptions, imageConfig2) : {}
  };
}
async function loadRemoteImage(src) {
  try {
    const res = await fetch(src);
    if (!res.ok) {
      return void 0;
    }
    return await res.arrayBuffer();
  } catch (err) {
    return void 0;
  }
}
var Mime_1, standard, Mime, lite, mime, decoder2, toUTF8String, toHexString, readInt16LE, readUInt16BE, readUInt16LE, readUInt24LE, readInt32LE, readUInt32BE, readUInt32LE, methods, BMP, TYPE_ICON, SIZE_HEADER$1, SIZE_IMAGE_ENTRY, ICO, TYPE_CURSOR, CUR, DDS, gifRegexp, GIF, brandMap, HEIF, SIZE_HEADER, FILE_LENGTH_OFFSET, ENTRY_LENGTH_OFFSET, ICON_TYPE_SIZE, ICNS, J2C, JP2, EXIF_MARKER, APP1_DATA_SIZE_BYTES, EXIF_HEADER_BYTES, TIFF_BYTE_ALIGN_BYTES, BIG_ENDIAN_BYTE_ALIGN, LITTLE_ENDIAN_BYTE_ALIGN, IDF_ENTRY_BYTES, NUM_DIRECTORY_ENTRIES_BYTES, JPG, KTX, pngSignature, pngImageHeaderChunkName, pngFriedChunkName, PNG, PNMTypes, handlers, PNM, PSD, svgReg, extractorRegExps, INCH_CM, units, unitsReg, SVG, TGA, signatures, TIFF, WEBP, typeHandlers, types2, firstBytes, globalOptions, fnv1a52, etag, $$Astro$12, $$Image, $$Astro2, $$Picture, imageConfig, getImage, GET;
var init_generic_Dk8lQKaX = __esm({
  ".wrangler/tmp/pages-KkpaTB/chunks/pages/generic_Dk8lQKaX.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_assets_service_i7oLR0nI();
    init_astro_BO0wYrHs();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    Mime$1.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions2 = typeMap[type].map(function(t5) {
          return t5.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i2 = 0; i2 < extensions2.length; i2++) {
          const ext = extensions2[i2];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions2[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime$1.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime$1.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    Mime_1 = Mime$1;
    standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    Mime = Mime_1;
    lite = new Mime(standard);
    mime = /* @__PURE__ */ getDefaultExportFromCjs(lite);
    decoder2 = new TextDecoder();
    toUTF8String = (input, start = 0, end = input.length) => decoder2.decode(input.slice(start, end));
    toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo2, i2) => memo2 + ("0" + i2.toString(16)).slice(-2), "");
    readInt16LE = (input, offset2 = 0) => {
      const val = input[offset2] + input[offset2 + 1] * 2 ** 8;
      return val | (val & 2 ** 15) * 131070;
    };
    readUInt16BE = (input, offset2 = 0) => input[offset2] * 2 ** 8 + input[offset2 + 1];
    readUInt16LE = (input, offset2 = 0) => input[offset2] + input[offset2 + 1] * 2 ** 8;
    readUInt24LE = (input, offset2 = 0) => input[offset2] + input[offset2 + 1] * 2 ** 8 + input[offset2 + 2] * 2 ** 16;
    readInt32LE = (input, offset2 = 0) => input[offset2] + input[offset2 + 1] * 2 ** 8 + input[offset2 + 2] * 2 ** 16 + (input[offset2 + 3] << 24);
    readUInt32BE = (input, offset2 = 0) => input[offset2] * 2 ** 24 + input[offset2 + 1] * 2 ** 16 + input[offset2 + 2] * 2 ** 8 + input[offset2 + 3];
    readUInt32LE = (input, offset2 = 0) => input[offset2] + input[offset2 + 1] * 2 ** 8 + input[offset2 + 2] * 2 ** 16 + input[offset2 + 3] * 2 ** 24;
    methods = {
      readUInt16BE,
      readUInt16LE,
      readUInt32BE,
      readUInt32LE
    };
    BMP = {
      validate: (input) => toUTF8String(input, 0, 2) === "BM",
      calculate: (input) => ({
        height: Math.abs(readInt32LE(input, 22)),
        width: readUInt32LE(input, 18)
      })
    };
    TYPE_ICON = 1;
    SIZE_HEADER$1 = 2 + 2 + 2;
    SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
    ICO = {
      validate(input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0)
          return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_ICON;
      },
      calculate(input) {
        const nbImages = readUInt16LE(input, 4);
        const imageSize = getImageSize$1(input, 0);
        if (nbImages === 1)
          return imageSize;
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
          imgs.push(getImageSize$1(input, imageIndex));
        }
        return {
          height: imageSize.height,
          images: imgs,
          width: imageSize.width
        };
      }
    };
    TYPE_CURSOR = 2;
    CUR = {
      validate(input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0)
          return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_CURSOR;
      },
      calculate: (input) => ICO.calculate(input)
    };
    DDS = {
      validate: (input) => readUInt32LE(input, 0) === 542327876,
      calculate: (input) => ({
        height: readUInt32LE(input, 12),
        width: readUInt32LE(input, 16)
      })
    };
    gifRegexp = /^GIF8[79]a/;
    GIF = {
      validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
      calculate: (input) => ({
        height: readUInt16LE(input, 8),
        width: readUInt16LE(input, 6)
      })
    };
    brandMap = {
      avif: "avif",
      mif1: "heif",
      msf1: "heif",
      // hief-sequence
      heic: "heic",
      heix: "heic",
      hevc: "heic",
      // heic-sequence
      hevx: "heic"
      // heic-sequence
    };
    HEIF = {
      validate(buffer) {
        const ftype = toUTF8String(buffer, 4, 8);
        const brand = toUTF8String(buffer, 8, 12);
        return "ftyp" === ftype && brand in brandMap;
      },
      calculate(buffer) {
        const metaBox = findBox(buffer, "meta", 0);
        const iprpBox = metaBox && findBox(buffer, "iprp", metaBox.offset + 12);
        const ipcoBox = iprpBox && findBox(buffer, "ipco", iprpBox.offset + 8);
        const ispeBox = ipcoBox && findBox(buffer, "ispe", ipcoBox.offset + 8);
        if (ispeBox) {
          return {
            height: readUInt32BE(buffer, ispeBox.offset + 16),
            width: readUInt32BE(buffer, ispeBox.offset + 12),
            type: detectBrands(buffer, 8, metaBox.offset)
          };
        }
        throw new TypeError("Invalid HEIF, no size found");
      }
    };
    SIZE_HEADER = 4 + 4;
    FILE_LENGTH_OFFSET = 4;
    ENTRY_LENGTH_OFFSET = 4;
    ICON_TYPE_SIZE = {
      ICON: 32,
      "ICN#": 32,
      // m => 16 x 16
      "icm#": 16,
      icm4: 16,
      icm8: 16,
      // s => 16 x 16
      "ics#": 16,
      ics4: 16,
      ics8: 16,
      is32: 16,
      s8mk: 16,
      icp4: 16,
      // l => 32 x 32
      icl4: 32,
      icl8: 32,
      il32: 32,
      l8mk: 32,
      icp5: 32,
      ic11: 32,
      // h => 48 x 48
      ich4: 48,
      ich8: 48,
      ih32: 48,
      h8mk: 48,
      // . => 64 x 64
      icp6: 64,
      ic12: 32,
      // t => 128 x 128
      it32: 128,
      t8mk: 128,
      ic07: 128,
      // . => 256 x 256
      ic08: 256,
      ic13: 256,
      // . => 512 x 512
      ic09: 512,
      ic14: 512,
      // . => 1024 x 1024
      ic10: 1024
    };
    ICNS = {
      validate: (input) => toUTF8String(input, 0, 4) === "icns",
      calculate(input) {
        const inputLength = input.length;
        const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(input, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength)
          return imageSize;
        const result = {
          height: imageSize.height,
          images: [imageSize],
          width: imageSize.width
        };
        while (imageOffset < fileLength && imageOffset < inputLength) {
          imageHeader = readImageHeader(input, imageOffset);
          imageSize = getImageSize(imageHeader[0]);
          imageOffset += imageHeader[1];
          result.images.push(imageSize);
        }
        return result;
      }
    };
    J2C = {
      // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
      validate: (input) => toHexString(input, 0, 4) === "ff4fff51",
      calculate: (input) => ({
        height: readUInt32BE(input, 12),
        width: readUInt32BE(input, 8)
      })
    };
    JP2 = {
      validate(input) {
        if (readUInt32BE(input, 4) !== 1783636e3 || readUInt32BE(input, 0) < 1)
          return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox)
          return false;
        return readUInt32BE(input, ftypBox.offset + 4) === 1718909296;
      },
      calculate(input) {
        const jp2hBox = findBox(input, "jp2h", 0);
        const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
        if (ihdrBox) {
          return {
            height: readUInt32BE(input, ihdrBox.offset + 8),
            width: readUInt32BE(input, ihdrBox.offset + 12)
          };
        }
        throw new TypeError("Unsupported JPEG 2000 format");
      }
    };
    EXIF_MARKER = "45786966";
    APP1_DATA_SIZE_BYTES = 2;
    EXIF_HEADER_BYTES = 6;
    TIFF_BYTE_ALIGN_BYTES = 2;
    BIG_ENDIAN_BYTE_ALIGN = "4d4d";
    LITTLE_ENDIAN_BYTE_ALIGN = "4949";
    IDF_ENTRY_BYTES = 12;
    NUM_DIRECTORY_ENTRIES_BYTES = 2;
    JPG = {
      validate: (input) => toHexString(input, 0, 2) === "ffd8",
      calculate(input) {
        input = input.slice(4);
        let orientation;
        let next;
        while (input.length) {
          const i2 = readUInt16BE(input, 0);
          if (input[i2] !== 255) {
            input = input.slice(1);
            continue;
          }
          if (isEXIF(input)) {
            orientation = validateExifBlock(input, i2);
          }
          validateInput(input, i2);
          next = input[i2 + 1];
          if (next === 192 || next === 193 || next === 194) {
            const size2 = extractSize(input, i2 + 5);
            if (!orientation) {
              return size2;
            }
            return {
              height: size2.height,
              orientation,
              width: size2.width
            };
          }
          input = input.slice(i2 + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
    };
    KTX = {
      validate: (input) => {
        const signature = toUTF8String(input, 1, 7);
        return ["KTX 11", "KTX 20"].includes(signature);
      },
      calculate: (input) => {
        const type = input[5] === 49 ? "ktx" : "ktx2";
        const offset2 = type === "ktx" ? 36 : 20;
        return {
          height: readUInt32LE(input, offset2 + 4),
          width: readUInt32LE(input, offset2),
          type
        };
      }
    };
    pngSignature = "PNG\r\n\n";
    pngImageHeaderChunkName = "IHDR";
    pngFriedChunkName = "CgBI";
    PNG = {
      validate(input) {
        if (pngSignature === toUTF8String(input, 1, 8)) {
          let chunkName = toUTF8String(input, 12, 16);
          if (chunkName === pngFriedChunkName) {
            chunkName = toUTF8String(input, 28, 32);
          }
          if (chunkName !== pngImageHeaderChunkName) {
            throw new TypeError("Invalid PNG");
          }
          return true;
        }
        return false;
      },
      calculate(input) {
        if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
          return {
            height: readUInt32BE(input, 36),
            width: readUInt32BE(input, 32)
          };
        }
        return {
          height: readUInt32BE(input, 20),
          width: readUInt32BE(input, 16)
        };
      }
    };
    PNMTypes = {
      P1: "pbm/ascii",
      P2: "pgm/ascii",
      P3: "ppm/ascii",
      P4: "pbm",
      P5: "pgm",
      P6: "ppm",
      P7: "pam",
      PF: "pfm"
    };
    handlers = {
      default: (lines) => {
        let dimensions = [];
        while (lines.length > 0) {
          const line = lines.shift();
          if (line[0] === "#") {
            continue;
          }
          dimensions = line.split(" ");
          break;
        }
        if (dimensions.length === 2) {
          return {
            height: parseInt(dimensions[1], 10),
            width: parseInt(dimensions[0], 10)
          };
        } else {
          throw new TypeError("Invalid PNM");
        }
      },
      pam: (lines) => {
        const size2 = {};
        while (lines.length > 0) {
          const line = lines.shift();
          if (line.length > 16 || line.charCodeAt(0) > 128) {
            continue;
          }
          const [key, value] = line.split(" ");
          if (key && value) {
            size2[key.toLowerCase()] = parseInt(value, 10);
          }
          if (size2.height && size2.width) {
            break;
          }
        }
        if (size2.height && size2.width) {
          return {
            height: size2.height,
            width: size2.width
          };
        } else {
          throw new TypeError("Invalid PAM");
        }
      }
    };
    PNM = {
      validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
      calculate(input) {
        const signature = toUTF8String(input, 0, 2);
        const type = PNMTypes[signature];
        const lines = toUTF8String(input, 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
      }
    };
    PSD = {
      validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
      calculate: (input) => ({
        height: readUInt32BE(input, 14),
        width: readUInt32BE(input, 18)
      })
    };
    svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
    extractorRegExps = {
      height: /\sheight=(['"])([^%]+?)\1/,
      root: svgReg,
      viewbox: /\sviewBox=(['"])(.+?)\1/i,
      width: /\swidth=(['"])([^%]+?)\1/
    };
    INCH_CM = 2.54;
    units = {
      in: 96,
      cm: 96 / INCH_CM,
      em: 16,
      ex: 8,
      m: 96 / INCH_CM * 100,
      mm: 96 / INCH_CM / 10,
      pc: 96 / 72 / 12,
      pt: 96 / 72,
      px: 1
    };
    unitsReg = new RegExp(
      `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
    );
    SVG = {
      // Scan only the first kilo-byte to speed up the check on larger files
      validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
      calculate(input) {
        const root = toUTF8String(input).match(extractorRegExps.root);
        if (root) {
          const attrs = parseAttributes(root[0]);
          if (attrs.width && attrs.height) {
            return calculateByDimensions(attrs);
          }
          if (attrs.viewbox) {
            return calculateByViewbox(attrs, attrs.viewbox);
          }
        }
        throw new TypeError("Invalid SVG");
      }
    };
    TGA = {
      validate(input) {
        return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
      },
      calculate(input) {
        return {
          height: readUInt16LE(input, 14),
          width: readUInt16LE(input, 12)
        };
      }
    };
    signatures = [
      // '492049', // currently not supported
      "49492a00",
      // Little endian
      "4d4d002a"
      // Big Endian
      // '4d4d002a', // BigTIFF > 4GB. currently not supported
    ];
    TIFF = {
      validate: (input) => signatures.includes(toHexString(input, 0, 4)),
      calculate(input) {
        const isBigEndian = determineEndianness(input) === "BE";
        const ifdBuffer = readIFD(input, isBigEndian);
        const tags = extractTags(ifdBuffer, isBigEndian);
        const width = tags[256];
        const height = tags[257];
        if (!width || !height) {
          throw new TypeError("Invalid Tiff. Missing tags");
        }
        return { height, width };
      }
    };
    WEBP = {
      validate(input) {
        const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
        const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
        const vp8Header = "VP8" === toUTF8String(input, 12, 15);
        return riffHeader && webpHeader && vp8Header;
      },
      calculate(input) {
        const chunkHeader = toUTF8String(input, 12, 16);
        input = input.slice(20, 30);
        if (chunkHeader === "VP8X") {
          const extendedHeader = input[0];
          const validStart = (extendedHeader & 192) === 0;
          const validEnd = (extendedHeader & 1) === 0;
          if (validStart && validEnd) {
            return calculateExtended(input);
          } else {
            throw new TypeError("Invalid WebP");
          }
        }
        if (chunkHeader === "VP8 " && input[0] !== 47) {
          return calculateLossy(input);
        }
        const signature = toHexString(input, 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
          return calculateLossless(input);
        }
        throw new TypeError("Invalid WebP");
      }
    };
    typeHandlers = /* @__PURE__ */ new Map([
      ["bmp", BMP],
      ["cur", CUR],
      ["dds", DDS],
      ["gif", GIF],
      ["heif", HEIF],
      ["icns", ICNS],
      ["ico", ICO],
      ["j2c", J2C],
      ["jp2", JP2],
      ["jpg", JPG],
      ["ktx", KTX],
      ["png", PNG],
      ["pnm", PNM],
      ["psd", PSD],
      ["svg", SVG],
      ["tga", TGA],
      ["tiff", TIFF],
      ["webp", WEBP]
    ]);
    types2 = Array.from(typeHandlers.keys());
    firstBytes = /* @__PURE__ */ new Map([
      [56, "psd"],
      [66, "bmp"],
      [68, "dds"],
      [71, "gif"],
      [73, "tiff"],
      [77, "tiff"],
      [82, "webp"],
      [105, "icns"],
      [137, "png"],
      [255, "jpg"]
    ]);
    globalOptions = {
      disabledTypes: []
    };
    fnv1a52 = (str) => {
      const len = str.length;
      let i2 = 0, t0 = 0, v0 = 8997, t1 = 0, v1 = 33826, t22 = 0, v22 = 40164, t32 = 0, v32 = 52210;
      while (i2 < len) {
        v0 ^= str.charCodeAt(i2++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t22 = v22 * 435;
        t32 = v32 * 435;
        t22 += v0 << 8;
        t32 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t22 += t1 >>> 16;
        v1 = t1 & 65535;
        v32 = t32 + (t22 >>> 16) & 65535;
        v22 = t22 & 65535;
      }
      return (v32 & 15) * 281474976710656 + v22 * 4294967296 + v1 * 65536 + (v0 ^ v32 >> 4);
    };
    etag = (payload, weak = false) => {
      const prefix = weak ? 'W/"' : '"';
      return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
    };
    $$Astro$12 = createAstro();
    $$Image = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$12, $$props, $$slots);
      Astro2.self = $$Image;
      const props = Astro2.props;
      if (props.alt === void 0 || props.alt === null) {
        throw new AstroError(ImageMissingAlt);
      }
      if (typeof props.width === "string") {
        props.width = parseInt(props.width);
      }
      if (typeof props.height === "string") {
        props.height = parseInt(props.height);
      }
      const image = await getImage(props);
      const additionalAttributes = {};
      if (image.srcSet.values.length > 0) {
        additionalAttributes.srcset = image.srcSet.attribute;
      }
      return renderTemplate`${maybeRenderHead()}<img${addAttribute(image.src, "src")}${spreadAttributes(additionalAttributes)}${spreadAttributes(image.attributes)}>`;
    }, "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/node_modules/astro/components/Image.astro", void 0);
    $$Astro2 = createAstro();
    $$Picture = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro2, $$props, $$slots);
      Astro2.self = $$Picture;
      const defaultFormats = ["webp"];
      const defaultFallbackFormat = "png";
      const specialFormatsFallback = ["gif", "svg", "jpg", "jpeg"];
      const { formats = defaultFormats, pictureAttributes = {}, fallbackFormat, ...props } = Astro2.props;
      if (props.alt === void 0 || props.alt === null) {
        throw new AstroError(ImageMissingAlt);
      }
      const originalSrc = await resolveSrc(props.src);
      const optimizedImages = await Promise.all(
        formats.map(
          async (format2) => await getImage({
            ...props,
            src: originalSrc,
            format: format2,
            widths: props.widths,
            densities: props.densities
          })
        )
      );
      let resultFallbackFormat = fallbackFormat ?? defaultFallbackFormat;
      if (!fallbackFormat && isESMImportedImage(originalSrc) && originalSrc.format in specialFormatsFallback) {
        resultFallbackFormat = originalSrc.format;
      }
      const fallbackImage = await getImage({
        ...props,
        format: resultFallbackFormat,
        widths: props.widths,
        densities: props.densities
      });
      const imgAdditionalAttributes = {};
      const sourceAdditionalAttributes = {};
      if (props.sizes) {
        sourceAdditionalAttributes.sizes = props.sizes;
      }
      if (fallbackImage.srcSet.values.length > 0) {
        imgAdditionalAttributes.srcset = fallbackImage.srcSet.attribute;
      }
      return renderTemplate`${maybeRenderHead()}<picture${spreadAttributes(pictureAttributes)}> ${Object.entries(optimizedImages).map(([_3, image]) => {
        const srcsetAttribute = props.densities || !props.densities && !props.widths ? `${image.src}${image.srcSet.values.length > 0 ? ", " + image.srcSet.attribute : ""}` : image.srcSet.attribute;
        return renderTemplate`<source${addAttribute(srcsetAttribute, "srcset")}${addAttribute("image/" + image.options.format, "type")}${spreadAttributes(sourceAdditionalAttributes)}>`;
      })} <img${addAttribute(fallbackImage.src, "src")}${spreadAttributes(imgAdditionalAttributes)}${spreadAttributes(fallbackImage.attributes)}> </picture>`;
    }, "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/node_modules/astro/components/Picture.astro", void 0);
    imageConfig = { "service": { "entrypoint": "astro/assets/services/noop", "config": {} }, "domains": [], "remotePatterns": [] };
    getImage = async (options) => await getImage$1(options, imageConfig);
    GET = async ({ request }) => {
      try {
        const imageService = await getConfiguredImageService();
        if (!("transform" in imageService)) {
          throw new Error("Configured image service is not a local service");
        }
        const url = new URL(request.url);
        const transform = await imageService.parseURL(url, imageConfig);
        if (!transform?.src) {
          throw new Error("Incorrect transform returned by `parseURL`");
        }
        let inputBuffer = void 0;
        const sourceUrl = isRemotePath(transform.src) ? new URL(transform.src) : new URL(transform.src, url.origin);
        if (isRemotePath(transform.src) && isRemoteAllowed(transform.src, imageConfig) === false) {
          return new Response("Forbidden", { status: 403 });
        }
        inputBuffer = await loadRemoteImage(sourceUrl);
        if (!inputBuffer) {
          return new Response("Not Found", { status: 404 });
        }
        const { data, format: format2 } = await imageService.transform(
          new Uint8Array(inputBuffer),
          transform,
          imageConfig
        );
        return new Response(data, {
          status: 200,
          headers: {
            "Content-Type": mime.getType(format2) ?? `image/${format2}`,
            "Cache-Control": "public, max-age=31536000",
            ETag: etag(data.toString()),
            Date: (/* @__PURE__ */ new Date()).toUTCString()
          }
        });
      } catch (err) {
        console.error("Could not process image request:", err);
        return new Response(`Server Error: ${err}`, { status: 500 });
      }
    };
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/generic_DuQmGclJ.mjs
var generic_DuQmGclJ_exports = {};
__export(generic_DuQmGclJ_exports, {
  page: () => page,
  renderers: () => renderers
});
var page;
var init_generic_DuQmGclJ = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/generic_DuQmGclJ.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_renderers();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    page = () => Promise.resolve().then(() => (init_generic_Dk8lQKaX(), generic_Dk8lQKaX_exports));
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/_trpc__LU1rZ36Q.mjs
var trpc_LU1rZ36Q_exports = {};
__export(trpc_LU1rZ36Q_exports, {
  page: () => page2,
  renderers: () => renderers
});
var page2;
var init_trpc_LU1rZ36Q = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/_trpc__LU1rZ36Q.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_renderers();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    page2 = () => init_trpc_GIzfMcGy().then(() => trpc_GIzfMcGy_exports).then((n5) => n5._);
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/pages/uploadthing_B1mybNP8.mjs
var uploadthing_B1mybNP8_exports = {};
__export(uploadthing_B1mybNP8_exports, {
  GET: () => GET2,
  POST: () => POST
});
var f2, uploadRouter, GET2, POST;
var init_uploadthing_B1mybNP8 = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/pages/uploadthing_B1mybNP8.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_trpc_GIzfMcGy();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    f2 = createUploadthing({
      /**
       * Log out more information about the error, but don't return it to the client
       * @see https://docs.uploadthing.com/errors#error-formatting
       */
      errorFormatter: (err) => {
        console.log("Error uploading file", err.message);
        console.log("  - Above error caused by:", err.cause);
        return { message: err.message };
      }
    });
    uploadRouter = {
      pdfAndVideo: f2({
        pdf: {
          maxFileSize: "4MB",
          maxFileCount: 4
        },
        video: {
          maxFileSize: "64MB",
          maxFileCount: 1
        }
      }).middleware(({ req }) => {
        return { foo: "bar" };
      }).onUploadComplete((data) => {
        return {
          url: data.file.url,
          key: data.file.key,
          name: data.file.name,
          size: data.file.size,
          type: data.file.type
        };
      })
    };
    ({ GET: GET2, POST } = createRouteHandler({
      router: uploadRouter,
      config: {
        uploadthingSecret: "sk_live_41657a9ccbef098cf6fbd0e2bd8ee6171bcfa90d890a19945436aff2c7f4d6d0"
      }
    }));
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/uploadthing_ByMMhEFg.mjs
var uploadthing_ByMMhEFg_exports = {};
__export(uploadthing_ByMMhEFg_exports, {
  page: () => page3,
  renderers: () => renderers
});
var page3;
var init_uploadthing_ByMMhEFg = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/uploadthing_ByMMhEFg.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_renderers();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    page3 = () => init_uploadthing_B1mybNP8().then(() => uploadthing_B1mybNP8_exports);
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/cvs_Dmiwg382.mjs
var cvs_Dmiwg382_exports = {};
__export(cvs_Dmiwg382_exports, {
  page: () => page4,
  renderers: () => renderers
});
var page4;
var init_cvs_Dmiwg382 = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/cvs_Dmiwg382.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_renderers();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    page4 = () => init_cvs_qudRXU8T().then(() => cvs_qudRXU8T_exports).then((n5) => n5.O);
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/pages/index_TRNjimg9.mjs
var index_TRNjimg9_exports = {};
__export(index_TRNjimg9_exports, {
  default: () => $$Index,
  file: () => $$file2,
  url: () => $$url2
});
async function uploadPartWithProgress(opts2, retryCount = 0) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("PUT", opts2.url, true);
    xhr.setRequestHeader("Content-Type", opts2.fileType);
    xhr.setRequestHeader("Content-Disposition", contentDisposition(opts2.contentDisposition, opts2.fileName));
    xhr.onload = async () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        const etag2 = xhr.getResponseHeader("Etag");
        etag2 ? resolve(etag2) : reject("NO ETAG");
      } else if (retryCount < opts2.maxRetries) {
        const delay = Math.pow(2, retryCount) * 1e3;
        await new Promise((res) => setTimeout(res, delay));
        resolve(await uploadPartWithProgress(opts2, retryCount + 1));
      } else {
        reject("Max retries exceeded");
      }
    };
    let lastProgress = 0;
    xhr.onerror = async () => {
      lastProgress = 0;
      if (retryCount < opts2.maxRetries) {
        const delay = Math.pow(2, retryCount) * 100;
        await new Promise((res) => setTimeout(res, delay));
        await uploadPartWithProgress(opts2, retryCount + 1);
      } else {
        reject("Max retries exceeded");
      }
    };
    xhr.upload.onprogress = (e2) => {
      const delta = e2.loaded - lastProgress;
      lastProgress += delta;
      opts2.onProgress(delta);
    };
    xhr.send(opts2.chunk);
  });
}
async function uploadMultipart2(file, presigned, opts2) {
  let etags;
  let uploadedBytes = 0;
  try {
    etags = await Promise.all(presigned.urls.map(async (url, index3) => {
      const offset2 = presigned.chunkSize * index3;
      const end = Math.min(offset2 + presigned.chunkSize, file.size);
      const chunk = file.slice(offset2, end);
      const etag2 = await uploadPartWithProgress({
        url,
        chunk,
        contentDisposition: presigned.contentDisposition,
        fileType: file.type,
        fileName: file.name,
        maxRetries: 10,
        onProgress: (delta) => {
          uploadedBytes += delta;
          const percent = uploadedBytes / file.size * 100;
          opts2.onUploadProgress?.({
            file: file.name,
            progress: percent
          });
        }
      });
      return {
        tag: etag2,
        partNumber: index3 + 1
      };
    }));
  } catch (error2) {
    await opts2.reportEventToUT("failure", {
      fileKey: presigned.key,
      uploadId: presigned.uploadId,
      fileName: file.name,
      s3Error: error2.toString()
    });
    throw "unreachable";
  }
  await opts2.reportEventToUT("multipart-complete", {
    uploadId: presigned.uploadId,
    fileKey: presigned.key,
    etags
  }).catch((res) => {
    console.log("Failed to alert UT of upload completion");
    throw new UploadThingError({
      code: "UPLOAD_FAILED",
      message: "Failed to alert UT of upload completion",
      cause: res
    });
  });
}
async function uploadPresignedPost2(file, presigned, opts2) {
  const formData = new FormData();
  Object.entries(presigned.fields).forEach(([k4, v4]) => formData.append(k4, v4));
  formData.append("file", file);
  const response = await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("POST", presigned.url);
    xhr.setRequestHeader("Accept", "application/xml");
    xhr.upload.onprogress = (p4) => {
      opts2.onUploadProgress?.({
        file: file.name,
        progress: p4.loaded / p4.total * 100
      });
    };
    xhr.onload = () => resolve({
      status: xhr.status
    });
    xhr.onerror = (e2) => reject(e2);
    xhr.send(formData);
  }).catch(async (error2) => {
    await opts2.reportEventToUT("failure", {
      fileKey: presigned.key,
      uploadId: null,
      fileName: file.name,
      s3Error: error2.toString()
    });
    throw "unreachable";
  });
  if (response.status > 299 || response.status < 200) {
    await opts2.reportEventToUT("failure", {
      fileKey: presigned.key,
      uploadId: null,
      fileName: file.name
    });
  }
}
function useEvent(callback) {
  const latestRef = React.useRef(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    useEvent_shouldNotBeInvokedBeforeMount
  );
  useInsertionEffect(() => {
    latestRef.current = callback;
  }, [
    callback
  ]);
  const stableRef = React.useRef();
  if (!stableRef.current) {
    stableRef.current = function() {
      return latestRef.current.apply(this, arguments);
    };
  }
  return stableRef.current;
}
function useEvent_shouldNotBeInvokedBeforeMount() {
  throw new Error("INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.");
}
function useFetch(url, options) {
  const cache = reactExports.useRef({});
  const cancelRequest = reactExports.useRef(false);
  const initialState2 = {
    error: void 0,
    data: void 0
  };
  const fetchReducer = (state2, action) => {
    switch (action.type) {
      case "loading":
        return {
          ...initialState2
        };
      case "fetched":
        return {
          ...initialState2,
          data: action.payload
        };
      case "error":
        return {
          ...initialState2,
          error: action.payload
        };
      default:
        return state2;
    }
  };
  const [state, dispatch] = reactExports.useReducer(fetchReducer, initialState2);
  reactExports.useEffect(() => {
    if (!url)
      return;
    cancelRequest.current = false;
    const fetchData = async () => {
      dispatch({
        type: "loading"
      });
      if (cache.current[url]) {
        dispatch({
          type: "fetched",
          payload: cache.current[url]
        });
        return;
      }
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        const dataOrError = await safeParseJSON(response);
        if (dataOrError instanceof Error) {
          throw dataOrError;
        }
        cache.current[url] = dataOrError;
        if (cancelRequest.current)
          return;
        dispatch({
          type: "fetched",
          payload: dataOrError
        });
      } catch (error2) {
        if (cancelRequest.current)
          return;
        dispatch({
          type: "error",
          payload: error2
        });
      }
    };
    void fetchData();
    return () => {
      cancelRequest.current = true;
    };
  }, [
    url
  ]);
  return state;
}
function getFilesFromClipboardEvent(event) {
  const dataTransferItems = event.clipboardData?.items;
  if (!dataTransferItems)
    return;
  const files = Array.from(dataTransferItems).reduce((acc, curr) => {
    const f3 = curr.getAsFile();
    return f3 ? [
      ...acc,
      f3
    ] : acc;
  }, []);
  return files;
}
function Spinner() {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("svg", {
    className: "z-10 block h-5 w-5 animate-spin align-middle text-white",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 576 512",
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", {
      fill: "currentColor",
      d: "M256 32C256 14.33 270.3 0 288 0C429.4 0 544 114.6 544 256C544 302.6 531.5 346.4 509.7 384C500.9 399.3 481.3 404.6 465.1 395.7C450.7 386.9 445.5 367.3 454.3 351.1C470.6 323.8 480 291 480 255.1C480 149.1 394 63.1 288 63.1C270.3 63.1 256 49.67 256 31.1V32z"
    })
  });
}
function UploadButton(props) {
  const $props = props;
  const { mode = "auto", appendOnPaste = false } = $props.config ?? {};
  const useUploadThing2 = INTERNAL_uploadthingHookGen({
    url: resolveMaybeUrlArg($props.url)
  });
  const fileInputRef = reactExports.useRef(null);
  const labelRef = reactExports.useRef(null);
  const [uploadProgressState, setUploadProgress] = reactExports.useState($props.__internal_upload_progress ?? 0);
  const [files, setFiles] = reactExports.useState([]);
  const [isManualTriggerDisplayed, setIsManualTriggerDisplayed] = reactExports.useState(false);
  const uploadProgress = $props.__internal_upload_progress ?? uploadProgressState;
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing2($props.endpoint, {
    headers: $props.headers,
    skipPolling: !$props?.onClientUploadComplete ? true : $props?.skipPolling,
    onClientUploadComplete: (res) => {
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      setIsManualTriggerDisplayed(false);
      setFiles([]);
      $props.onClientUploadComplete?.(res);
      setUploadProgress(0);
    },
    onUploadProgress: (p4) => {
      setUploadProgress(p4);
      $props.onUploadProgress?.(p4);
    },
    onUploadError: $props.onUploadError,
    onUploadBegin: $props.onUploadBegin,
    onBeforeUploadBegin: $props.onBeforeUploadBegin
  });
  const { fileTypes, multiple } = generatePermittedFileTypes(permittedFileInfo?.config);
  const ready = $props.__internal_ready ?? ($props.__internal_state === "ready" || fileTypes.length > 0);
  reactExports.useEffect(() => {
    const handlePaste = (event) => {
      if (!appendOnPaste)
        return;
      if (document.activeElement !== labelRef.current)
        return;
      const pastedFiles = getFilesFromClipboardEvent(event);
      if (!pastedFiles)
        return;
      setFiles((prev) => [
        ...prev,
        ...pastedFiles
      ]);
      if (mode === "auto") {
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(files, input);
      }
    };
    window.addEventListener("paste", handlePaste);
    return () => {
      window.removeEventListener("paste", handlePaste);
    };
  }, [
    startUpload,
    appendOnPaste,
    $props,
    files,
    mode,
    fileTypes
  ]);
  const getUploadButtonText = (fileTypes2) => {
    if (isManualTriggerDisplayed)
      return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
    if (fileTypes2.length === 0)
      return "Loading...";
    return `Choose File${multiple ? `(s)` : ``}`;
  };
  const getUploadButtonContents = (fileTypes2) => {
    if (state !== "uploading") {
      return getUploadButtonText(fileTypes2);
    }
    if (uploadProgress === 100) {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Spinner, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("span", {
      className: "z-50",
      children: [
        uploadProgress,
        "%"
      ]
    });
  };
  const getInputProps = () => ({
    type: "file",
    ref: fileInputRef,
    multiple,
    accept: generateMimeTypes(fileTypes ?? [])?.join(", "),
    onChange: (e2) => {
      if (!e2.target.files)
        return;
      const selectedFiles = Array.from(e2.target.files);
      if (mode === "manual") {
        setFiles(selectedFiles);
        setIsManualTriggerDisplayed(true);
        return;
      }
      const input = "input" in $props ? $props.input : void 0;
      void startUpload(selectedFiles, input);
    },
    disabled: $props.__internal_button_disabled ?? !ready,
    ...!($props.__internal_button_disabled ?? !ready) ? {
      tabIndex: 0
    } : {}
  });
  const styleFieldArg = {
    ready,
    isUploading: $props.__internal_state === "uploading" || isUploading,
    uploadProgress,
    fileTypes
  };
  const state = (() => {
    if ($props.__internal_state)
      return $props.__internal_state;
    if (!ready)
      return "readying";
    if (ready && !isUploading)
      return "ready";
    return "uploading";
  })();
  const renderClearButton = () => /* @__PURE__ */ jsxRuntimeExports$1.jsx("button", {
    onClick: () => {
      setFiles([]);
      setIsManualTriggerDisplayed(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    },
    className: twMerge("h-[1.25rem] cursor-pointer rounded border-none bg-transparent text-gray-500 transition-colors hover:bg-slate-200 hover:text-gray-600", styleFieldToClassName($props.appearance?.clearBtn, styleFieldArg)),
    style: styleFieldToCssObject($props.appearance?.clearBtn, styleFieldArg),
    "data-state": state,
    "data-ut-element": "clear-btn",
    children: contentFieldToContent($props.content?.clearBtn, styleFieldArg) ?? "Clear"
  });
  const renderAllowedContent = () => /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", {
    className: twMerge("h-[1.25rem]  text-xs leading-5 text-gray-600", styleFieldToClassName($props.appearance?.allowedContent, styleFieldArg)),
    style: styleFieldToCssObject($props.appearance?.allowedContent, styleFieldArg),
    "data-state": state,
    "data-ut-element": "allowed-content",
    children: contentFieldToContent($props.content?.allowedContent, styleFieldArg) ?? allowedContentTextLabelGenerator(permittedFileInfo?.config)
  });
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", {
    className: twMerge("flex flex-col items-center justify-center gap-1", $props.className, styleFieldToClassName($props.appearance?.container, styleFieldArg)),
    style: styleFieldToCssObject($props.appearance?.container, styleFieldArg),
    "data-state": state,
    children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("label", {
        className: twMerge("relative flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2", state === "readying" && "cursor-not-allowed bg-blue-400", state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${progressWidths[uploadProgress]}`, state === "ready" && "bg-blue-600", styleFieldToClassName($props.appearance?.button, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.button, styleFieldArg),
        "data-state": state,
        "data-ut-element": "button",
        ref: labelRef,
        onClick: (e2) => {
          if (isManualTriggerDisplayed) {
            e2.preventDefault();
            e2.stopPropagation();
            const input = "input" in $props ? $props.input : void 0;
            void startUpload(files, input);
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("input", {
            ...getInputProps(),
            className: "sr-only"
          }),
          contentFieldToContent($props.content?.button, styleFieldArg) ?? getUploadButtonContents(fileTypes)
        ]
      }),
      mode === "manual" && files.length > 0 ? renderClearButton() : renderAllowedContent()
    ]
  });
}
function toFileWithPath(file, path) {
  var f3 = withMimeType(file);
  if (typeof f3.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f3, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f3;
}
function withMimeType(file) {
  var name = file.name;
  var hasExtension = name && name.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a78) {
      if (isObject$12(evt) && isDataTransfer(evt.dataTransfer)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value) {
  return isObject$12(value);
}
function isChangeEvt(value) {
  return isObject$12(value) && isObject$12(value.target);
}
function isObject$12(v4) {
  return typeof v4 === "object" && v4 !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file) {
    return toFileWithPath(file);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a78) {
      switch (_a78.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h2) {
            return h2.getFile();
          }))];
        case 1:
          files = _a78.sent();
          return [2, files.map(function(file) {
            return toFileWithPath(file);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a78) {
      switch (_a78.label) {
        case 0:
          if (!dt.items)
            return [3, 2];
          items = fromList(dt.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a78.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i2 = 0; i2 < items.length; i2++) {
    var file = items[i2];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spreadArray$1(__spreadArray$1([], __read(acc), false), __read(Array.isArray(files) ? flatten(files) : [files]), false);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject("".concat(item, " is not a File"));
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a78) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a78) {
            switch (_a78.label) {
              case 0:
                if (!!batch.length)
                  return [3, 5];
                _a78.label = 1;
              case 1:
                _a78.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a78.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a78.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch.map(fromEntry));
                entries.push(items);
                readEntries();
                _a78.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a78) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}
function accepts(file, acceptedFiles) {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name ?? "";
    const mimeType = (file.type ?? "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.startsWith(".")) {
        return fileName.toLowerCase().endsWith(validType);
      } else if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isFileAccepted(file, accept) {
  return file.type === "application/x-moz-file" || accepts(file, accept);
}
function isEnterOrSpace(event) {
  return "key" in event && (event.key === " " || event.key === "Enter") || "keyCode" in event && (event.keyCode === 32 || event.keyCode === 13);
}
function isValidSize(file, minSize, maxSize) {
  if (!isDefined(file.size))
    return true;
  if (isDefined(minSize) && isDefined(maxSize)) {
    return file.size >= minSize && file.size <= maxSize;
  }
  if (isDefined(minSize) && file.size < minSize)
    return false;
  if (isDefined(maxSize) && file.size > maxSize)
    return false;
  return true;
}
function isValidQuantity(files, multiple, maxFiles) {
  if (!multiple && files.length > 1)
    return false;
  if (multiple && maxFiles >= 1 && files.length > maxFiles)
    return false;
  return true;
}
function allFilesAccepted({ files, accept, minSize, maxSize, multiple, maxFiles }) {
  if (!isValidQuantity(files, multiple, maxFiles))
    return false;
  return files.every((file) => isFileAccepted(file, accept) && isValidSize(file, minSize, maxSize));
}
function isEventWithFiles(event) {
  if (!("dataTransfer" in event && event.dataTransfer !== null)) {
    return !!event.target && "files" in event.target && !!event.target.files;
  }
  return Array.prototype.some.call(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    event.dataTransfer?.types,
    (type) => type === "Files" || type === "application/x-moz-file"
  );
}
function isIeOrEdge(ua3 = window.navigator.userAgent) {
  return ua3.indexOf("MSIE ") > -1 || ua3.indexOf("Trident/") > -1 || ua3.indexOf("Edge/") > -1;
}
function isMIMEType(v4) {
  return v4 === "audio/*" || v4 === "video/*" || v4 === "image/*" || v4 === "text/*" || /\w+\/[-+.\w]+/g.test(v4);
}
function isExt(v4) {
  return /^.*\.[\w]+$/.test(v4);
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined(accept)) {
    return Object.entries(accept).reduce((a2, [mimeType, ext]) => [
      ...a2,
      mimeType,
      ...ext
    ], []).filter((v4) => isMIMEType(v4) || isExt(v4)).join(",");
  }
  return void 0;
}
function noop5() {
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return {
        ...state,
        isFocused: true
      };
    case "blur":
      return {
        ...state,
        isFocused: false
      };
    case "openDialog":
      return {
        ...initialState,
        isFileDialogActive: true
      };
    case "closeDialog":
      return {
        ...state,
        isFileDialogActive: false
      };
    case "setDraggedFiles":
      return {
        ...state,
        ...action.payload
      };
    case "setFiles":
      return {
        ...state,
        ...action.payload
      };
    case "reset":
      return initialState;
    default:
      return state;
  }
}
function useDropzone({ accept, disabled = false, maxSize = Number.POSITIVE_INFINITY, minSize = 0, multiple = true, maxFiles = 0, onDrop }) {
  const acceptAttr = reactExports.useMemo(() => acceptPropAsAcceptAttr(accept), [
    accept
  ]);
  const rootRef = reactExports.useRef(null);
  const inputRef = reactExports.useRef(null);
  const dragTargetsRef = reactExports.useRef([]);
  const [state, dispatch] = reactExports.useReducer(reducer, initialState);
  reactExports.useEffect(() => {
    const onWindowFocus = () => {
      if (state.isFileDialogActive) {
        setTimeout(() => {
          if (inputRef.current) {
            const { files } = inputRef.current;
            if (!files?.length) {
              dispatch({
                type: "closeDialog"
              });
            }
          }
        }, 300);
      }
    };
    window.addEventListener("focus", onWindowFocus, false);
    return () => {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [
    state.isFileDialogActive
  ]);
  reactExports.useEffect(() => {
    const onDocumentDrop = (event) => {
      if (rootRef.current?.contains(event.target))
        return;
      event.preventDefault();
      dragTargetsRef.current = [];
    };
    const onDocumentDragOver = (e2) => e2.preventDefault();
    document.addEventListener("dragover", onDocumentDragOver, false);
    document.addEventListener("drop", onDocumentDrop, false);
    return () => {
      document.removeEventListener("dragover", onDocumentDragOver);
      document.removeEventListener("drop", onDocumentDrop);
    };
  }, []);
  const onDragEnter = reactExports.useCallback((event) => {
    event.preventDefault();
    event.persist();
    dragTargetsRef.current = [
      ...dragTargetsRef.current,
      event.target
    ];
    if (isEventWithFiles(event)) {
      Promise.resolve(fromEvent(event)).then((files) => {
        if (event.isPropagationStopped())
          return;
        const fileCount = files.length;
        const isDragAccept = fileCount > 0 && allFilesAccepted({
          files,
          accept: acceptAttr,
          minSize,
          maxSize,
          multiple,
          maxFiles
        });
        const isDragReject = fileCount > 0 && !isDragAccept;
        dispatch({
          type: "setDraggedFiles",
          payload: {
            isDragAccept,
            isDragReject,
            isDragActive: true
          }
        });
      }).catch(noop5);
    }
  }, [
    acceptAttr,
    maxFiles,
    maxSize,
    minSize,
    multiple
  ]);
  const onDragOver = reactExports.useCallback((event) => {
    event.preventDefault();
    event.persist();
    const hasFiles = isEventWithFiles(event);
    if (hasFiles && event.dataTransfer !== null) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch {
      }
    }
    return false;
  }, []);
  const onDragLeave = reactExports.useCallback((event) => {
    event.preventDefault();
    event.persist();
    const targets = dragTargetsRef.current.filter((target) => rootRef.current?.contains(target));
    const targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1)
      targets.splice(targetIdx, 1);
    dragTargetsRef.current = targets;
    if (targets.length > 0)
      return;
    dispatch({
      type: "setDraggedFiles",
      payload: {
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false
      }
    });
  }, []);
  const setFiles = reactExports.useCallback((files) => {
    const acceptedFiles = [];
    files.forEach((file) => {
      const accepted = isFileAccepted(file, acceptAttr);
      const sizeMatch = isValidSize(file, minSize, maxSize);
      if (accepted && sizeMatch) {
        acceptedFiles.push(file);
      }
    });
    if (!isValidQuantity(acceptedFiles, multiple, maxFiles)) {
      acceptedFiles.splice(0);
    }
    dispatch({
      type: "setFiles",
      payload: {
        acceptedFiles
      }
    });
    onDrop(acceptedFiles);
  }, [
    acceptAttr,
    maxFiles,
    maxSize,
    minSize,
    multiple,
    onDrop
  ]);
  const onDropCb = reactExports.useCallback((event) => {
    event.preventDefault();
    event.persist();
    dragTargetsRef.current = [];
    if (isEventWithFiles(event)) {
      Promise.resolve(fromEvent(event)).then((files) => {
        if (event.isPropagationStopped())
          return;
        setFiles(files);
      }).catch(noop5);
    }
    dispatch({
      type: "reset"
    });
  }, [
    setFiles
  ]);
  const openFileDialog = reactExports.useCallback(() => {
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      inputRef.current.value = "";
      inputRef.current.click();
    }
  }, []);
  const onKeyDown = reactExports.useCallback((event) => {
    if (!rootRef.current?.isEqualNode(event.target))
      return;
    if (isEnterOrSpace(event)) {
      event.preventDefault();
      openFileDialog();
    }
  }, [
    openFileDialog
  ]);
  const onInputElementClick = reactExports.useCallback((e2) => {
    e2.stopPropagation();
  }, []);
  const onFocus = reactExports.useCallback(() => dispatch({
    type: "focus"
  }), []);
  const onBlur = reactExports.useCallback(() => dispatch({
    type: "blur"
  }), []);
  const onClick = reactExports.useCallback(() => {
    isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
  }, [
    openFileDialog
  ]);
  const getRootProps = reactExports.useMemo(() => () => ({
    ref: rootRef,
    role: "presentation",
    ...!disabled ? {
      tabIndex: 0,
      onKeyDown,
      onFocus,
      onBlur,
      onClick,
      onDragEnter,
      onDragOver,
      onDragLeave,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      onDrop: onDropCb
    } : {}
  }), [
    disabled,
    onBlur,
    onClick,
    onDragEnter,
    onDragLeave,
    onDragOver,
    onDropCb,
    onFocus,
    onKeyDown
  ]);
  const getInputProps = reactExports.useMemo(() => () => ({
    ref: inputRef,
    type: "file",
    style: {
      display: "none"
    },
    accept: acceptAttr,
    multiple,
    tabIndex: -1,
    ...!disabled ? {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      onChange: onDropCb,
      onClick: onInputElementClick
    } : {}
  }), [
    acceptAttr,
    multiple,
    onDropCb,
    onInputElementClick,
    disabled
  ]);
  return {
    ...state,
    getRootProps,
    getInputProps,
    rootRef
  };
}
function UploadDropzone(props) {
  const $props = props;
  const { mode = "manual", appendOnPaste = false } = $props.config ?? {};
  const useUploadThing2 = INTERNAL_uploadthingHookGen({
    url: resolveMaybeUrlArg($props.url)
  });
  const [files, setFiles] = reactExports.useState([]);
  const [uploadProgressState, setUploadProgress] = reactExports.useState($props.__internal_upload_progress ?? 0);
  const uploadProgress = $props.__internal_upload_progress ?? uploadProgressState;
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing2($props.endpoint, {
    headers: $props.headers,
    skipPolling: !$props?.onClientUploadComplete ? true : $props?.skipPolling,
    onClientUploadComplete: (res) => {
      setFiles([]);
      $props.onClientUploadComplete?.(res);
      setUploadProgress(0);
    },
    onUploadProgress: (p4) => {
      setUploadProgress(p4);
      $props.onUploadProgress?.(p4);
    },
    onUploadError: $props.onUploadError,
    onUploadBegin: $props.onUploadBegin,
    onBeforeUploadBegin: $props.onBeforeUploadBegin
  });
  const { fileTypes, multiple } = generatePermittedFileTypes(permittedFileInfo?.config);
  const onDrop = reactExports.useCallback((acceptedFiles) => {
    setFiles(acceptedFiles);
    if (mode === "auto") {
      const input = "input" in $props ? $props.input : void 0;
      void startUpload(acceptedFiles, input);
      return;
    }
  }, [
    $props,
    mode,
    startUpload
  ]);
  const { getRootProps, getInputProps, isDragActive, rootRef } = useDropzone({
    onDrop,
    multiple,
    accept: fileTypes ? generateClientDropzoneAccept(fileTypes) : void 0,
    disabled: $props.__internal_dropzone_disabled
  });
  const ready = $props.__internal_ready ?? ($props.__internal_state === "ready" || fileTypes.length > 0);
  const onUploadClick = (e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    if (!files)
      return;
    const input = "input" in $props ? $props.input : void 0;
    void startUpload(files, input);
  };
  reactExports.useEffect(() => {
    const handlePaste = (event) => {
      if (!appendOnPaste)
        return;
      if (document.activeElement !== rootRef.current)
        return;
      const pastedFiles = getFilesFromClipboardEvent(event);
      if (!pastedFiles?.length)
        return;
      let filesToUpload = pastedFiles;
      setFiles((prev) => {
        filesToUpload = [
          ...prev,
          ...pastedFiles
        ];
        return filesToUpload;
      });
      if (mode === "auto") {
        const input = "input" in $props ? $props.input : void 0;
        void startUpload(filesToUpload, input);
      }
    };
    window.addEventListener("paste", handlePaste);
    return () => {
      window.removeEventListener("paste", handlePaste);
    };
  }, [
    startUpload,
    $props,
    appendOnPaste,
    mode,
    fileTypes,
    rootRef,
    files
  ]);
  const getUploadButtonText = (fileTypes2) => {
    if (files.length > 0)
      return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
    if (fileTypes2.length === 0)
      return "Loading...";
    return `Choose File${multiple ? `(s)` : ``}`;
  };
  const getUploadButtonContents = (fileTypes2) => {
    if (state !== "uploading") {
      return getUploadButtonText(fileTypes2);
    }
    if (uploadProgress === 100) {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Spinner, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("span", {
      className: "z-50",
      children: [
        uploadProgress,
        "%"
      ]
    });
  };
  const styleFieldArg = {
    fileTypes,
    isDragActive,
    isUploading,
    ready,
    uploadProgress
  };
  const state = (() => {
    if ($props.__internal_state)
      return $props.__internal_state;
    if (!ready)
      return "readying";
    if (ready && !isUploading)
      return "ready";
    return "uploading";
  })();
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", {
    className: twMerge("mt-2 flex flex-col items-center justify-center rounded-lg border border-dashed border-gray-900/25 px-6 py-10 text-center", isDragActive && "bg-blue-600/10", $props.className, styleFieldToClassName($props.appearance?.container, styleFieldArg)),
    ...getRootProps(),
    style: styleFieldToCssObject($props.appearance?.container, styleFieldArg),
    "data-state": state,
    children: [
      contentFieldToContent($props.content?.uploadIcon, styleFieldArg) ?? /* @__PURE__ */ jsxRuntimeExports$1.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        className: twMerge("mx-auto block h-12 w-12 align-middle text-gray-400", styleFieldToClassName($props.appearance?.uploadIcon, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.uploadIcon, styleFieldArg),
        "data-ut-element": "upload-icon",
        "data-state": state,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M5.5 17a4.5 4.5 0 0 1-1.44-8.765a4.5 4.5 0 0 1 8.302-3.046a3.5 3.5 0 0 1 4.504 4.272A4 4 0 0 1 15 17H5.5Zm3.75-2.75a.75.75 0 0 0 1.5 0V9.66l1.95 2.1a.75.75 0 1 0 1.1-1.02l-3.25-3.5a.75.75 0 0 0-1.1 0l-3.25 3.5a.75.75 0 1 0 1.1 1.02l1.95-2.1v4.59Z",
          clipRule: "evenodd"
        })
      }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("label", {
        className: twMerge("relative mt-4 flex w-64 cursor-pointer items-center justify-center text-sm font-semibold leading-6 text-gray-600 focus-within:outline-none focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2 hover:text-blue-500", ready ? "text-blue-600" : "text-gray-500", styleFieldToClassName($props.appearance?.label, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.label, styleFieldArg),
        "data-ut-element": "label",
        "data-state": state,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("input", {
            className: "sr-only",
            ...getInputProps()
          }),
          contentFieldToContent($props.content?.label, styleFieldArg) ?? (ready ? `Choose files or drag and drop` : `Loading...`)
        ]
      }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", {
        className: twMerge("m-0 h-[1.25rem] text-xs leading-5 text-gray-600", styleFieldToClassName($props.appearance?.allowedContent, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.allowedContent, styleFieldArg),
        "data-ut-element": "allowed-content",
        "data-state": state,
        children: contentFieldToContent($props.content?.allowedContent, styleFieldArg) ?? allowedContentTextLabelGenerator(permittedFileInfo?.config)
      }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("button", {
        className: twMerge("relative mt-4 flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md border-none text-base text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2", state === "readying" && "cursor-not-allowed bg-blue-400", state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${progressWidths[uploadProgress]}`, state === "ready" && "bg-blue-600", "disabled:pointer-events-none", styleFieldToClassName($props.appearance?.button, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.button, styleFieldArg),
        onClick: onUploadClick,
        "data-ut-element": "button",
        "data-state": state,
        type: "button",
        disabled: $props.__internal_button_disabled ?? (!files.length || state === "uploading"),
        children: contentFieldToContent($props.content?.button, styleFieldArg) ?? getUploadButtonContents(fileTypes)
      })
    ]
  });
}
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject3(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject3(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods2 = useFormContext();
  const { control = methods2.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return getProxyFormState(formState, control, _localProxyFormState.current, false);
}
function useWatch(props) {
  const methods2 = useFormContext();
  const { control = methods2.control, name, defaultValue, disabled, exact } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));
  React.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods2 = useFormContext();
  const { name, disabled, control = methods2.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name
  });
  const _registerProps = React.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name2, value2) => {
      const field = get(control._fields, name2);
      if (field) {
        field._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    if (get(control._fields, name)) {
      control._updateDisabledField({
        disabled,
        fields: control._fields,
        name,
        value: get(control._fields, name)._f.value
      });
    }
  }, [disabled, name, control]);
  return {
    field: {
      name,
      value,
      ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
      onChange: React.useCallback((event) => _registerProps.current.onChange({
        target: {
          value: getEventValue(event),
          name
        },
        type: EVENTS.CHANGE
      }), [name]),
      onBlur: React.useCallback(() => _registerProps.current.onBlur({
        target: {
          value: get(control._formValues, name),
          name
        },
        type: EVENTS.BLUR
      }), [name, control]),
      ref: (elm) => {
        const field = get(control._fields, name);
        if (field && elm) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message2) => elm.setCustomValidity(message2),
            reportValidity: () => elm.reportValidity()
          };
        }
      }
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: true,
        get: () => !!get(formState.errors, name)
      },
      isDirty: {
        enumerable: true,
        get: () => !!get(formState.dirtyFields, name)
      },
      isTouched: {
        enumerable: true,
        get: () => !!get(formState.touchedFields, name)
      },
      isValidating: {
        enumerable: true,
        get: () => !!get(formState.validatingFields, name)
      },
      error: {
        enumerable: true,
        get: () => get(formState.errors, name)
      }
    })
  };
}
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
function baseGet(object2, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index3 = 0;
  while (index3 < length) {
    object2 = isUndefined(object2) ? index3++ : object2[updatePath[index3++]];
  }
  return object2;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object2, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object2 : baseGet(object2, paths);
  const index3 = paths.length - 1;
  const key = paths[index3];
  if (childObject) {
    delete childObject[key];
  }
  if (index3 !== 0 && (isObject3(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object2, paths.slice(0, -1));
  }
  return object2;
}
function deepEqual2(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject3(val1) && isObject3(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual2(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject3(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject3(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject3(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject3(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual2(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
function getFieldValue(_f) {
  const ref = _f.ref;
  if (_f.refs ? _f.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
function schemaErrorLookup(errors, _fields, name) {
  const error2 = get(errors, name);
  if (error2 || isKey(name)) {
    return {
      error: error2,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions2,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction2(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject3(_options.defaultValues) || isObject3(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (_proxyFormState.isValid || shouldUpdateValid) {
      const isValid3 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid3 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid3
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (_proxyFormState.isValidating || _proxyFormState.validatingFields) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error2) => {
    set(_formState.errors, name, error2);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    const disabledField = !!(get(_fields, name) && get(_fields, name)._f.disabled);
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }
      const isCurrentFieldPristine = disabledField || deepEqual2(get(_defaultValues, name), fieldValue);
      isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));
      isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
    }
    if (isBlurEvent) {
      const isPreviousFieldTouched = get(_formState.touchedFields, name);
      if (!isPreviousFieldTouched) {
        set(_formState.touchedFields, name, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
      }
    }
    shouldUpdateField && shouldRender && _subjects.state.next(output);
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid3, error2, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid3) && _formState.isValid !== isValid3;
    if (props.delayError && error2) {
      delayErrorCallback = debounce(() => updateErrors(name, error2));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error2 ? set(_formState.errors, name, error2) : unset(_formState.errors, name);
    }
    if ((error2 ? !deepEqual2(previousFieldError, error2) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid3) ? { isValid: isValid3 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error2 = get(errors, name);
        error2 ? set(_formState.errors, name, error2) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          _updateIsValidating([name], true);
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          _updateIsValidating([name]);
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => (name && data && set(_formValues, name, data), !deepEqual2(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString2(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement2(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || fieldValue === get(_formValues, name, fieldValue);
    };
    if (field) {
      let error2;
      let isValid3;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        _proxyFormState.isValid && _updateValid();
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error2 = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid3 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error2 = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error2) {
            isValid3 = false;
          } else if (_proxyFormState.isValid) {
            isValid3 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid3, error2, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid3;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid3 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid3;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid3 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString2(name) || _proxyFormState.isValid && isValid3 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid3 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._defaultValues,
      ..._state.mount ? _formValues : {}
    };
    return isUndefined(fieldNames) ? values : isString2(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name),
    isValidating: !!get((formState || _formState).validatingFields, name),
    error: get((formState || _formState).errors, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error2, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    set(_formState.errors, name, {
      ...error2,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction2(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name, field, fields, value }) => {
    if (isBoolean(disabled)) {
      const inputValue = disabled ? void 0 : isUndefined(value) ? getFieldValue(field ? field._f : get(fields, name)._f) : value;
      set(_formValues, name, inputValue);
      updateTouchAndDirty(name, inputValue, false, false, true);
    }
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: options.disabled,
        name,
        value: options.value
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        let requiredDisabledState = disabled;
        const currentField = get(_fields, name);
        if (currentField && isBoolean(currentField._f.disabled)) {
          requiredDisabledState || (requiredDisabledState = currentField._f.disabled);
        }
        ref.disabled = requiredDisabledState;
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error2) {
        onValidError = error2;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        for (const fieldName of _names.mount) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement2(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.values.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual2(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? [] : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction2(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction2(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const _values = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction2(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction2(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty2 = control._getDirty();
      if (isDirty2 !== formState.isDirty) {
        control._subjects.state.next({
          isDirty: isDirty2
        });
      }
    }
  }, [control, formState.isDirty]);
  React.useEffect(() => {
    if (props.values && !deepEqual2(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  React.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
function createStore(store2) {
  return (stateUpdater, callbacks) => {
    return new Proxy(store2, {
      get(target, prop, receiver) {
        if (prop === "size") {
          return target.size;
        }
        const value = Reflect.get(target, prop, receiver);
        if (value instanceof Function) {
          return function(...args) {
            var _a210;
            const result = value.apply(target, args);
            const shouldTriggerUpdate = args[args.length - 1] === true;
            if (shouldTriggerUpdate) {
              stateUpdater((prev) => prev + 1);
            }
            if (prop === "set") {
              return result.get(args[0]);
            }
            if (callbacks && callbacks[prop]) {
              (_a210 = callbacks[prop]) == null ? void 0 : _a210.call(callbacks, result);
            }
            return result;
          };
        }
        return value;
      }
    });
  };
}
function useStore(store2, callbacks) {
  const [, forceUpdate] = reactExports.useState(0);
  const triggerUpdate = reactExports.useCallback(() => forceUpdate((prev) => prev + 1), []);
  const state = reactExports.useMemo(() => store2(triggerUpdate, callbacks), []);
  return {
    state
  };
}
function getSupportedMediaFormats(containers, codecs, type) {
  return containers.reduce(
    (acc, container) => {
      codecs.forEach((codec) => {
        const mimeType = `${type}/${container};codecs=${codec}`;
        if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported(mimeType)) {
          acc.mimeType.push(mimeType);
          acc.codec.push(codec);
          acc.container.push(container);
        }
      });
      return acc;
    },
    { mimeType: [], codec: [], container: [] }
  );
}
function createRecording({
  videoId,
  audioId,
  videoLabel,
  audioLabel
}) {
  const recordingId = `${videoId}-${audioId}`;
  const recording = {
    id: recordingId,
    audioId,
    audioLabel,
    blobChunks: [],
    fileName: String((/* @__PURE__ */ new Date()).getTime()),
    fileType: "webm",
    isMuted: false,
    mimeType: defaultCodec,
    objectURL: null,
    previewRef: reactExports.createRef(),
    recorder: null,
    status: STATUS.INITIAL,
    videoId,
    videoLabel,
    webcamRef: reactExports.createRef()
  };
  return recording;
}
function useRecordingStore() {
  var _a210;
  const { state } = useStore(store);
  const activeRecordings = Array.from((_a210 = recordingMap == null ? void 0 : recordingMap.values) == null ? void 0 : _a210.call(recordingMap));
  const clearAllRecordings = () => __async(this, null, function* () {
    Array.from(state.values()).forEach((recording) => {
      var _a310;
      const stream = (_a310 = recording.webcamRef.current) == null ? void 0 : _a310.srcObject;
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
      }
    });
    state.clear(true);
  });
  const isRecordingCreated = (recordingId) => {
    const isCreated = state.get(recordingId);
    return Boolean(isCreated);
  };
  const getRecording = (recordingId) => {
    const recording = state.get(recordingId);
    if (!recording) {
      throw new Error(ERROR_MESSAGES.NO_RECORDING_WITH_ID);
    }
    return recording;
  };
  const setRecording = (params) => __async(this, null, function* () {
    const recording = createRecording(params);
    const newRecording = state.set(recording.id, recording, true);
    return newRecording;
  });
  const updateRecording = (recordingId, updatedValues) => __async(this, null, function* () {
    const recording = state.get(recordingId);
    const updatedRecording = state.set(
      recordingId,
      __spreadValues(__spreadValues({}, recording), updatedValues),
      true
    );
    return updatedRecording;
  });
  const deleteRecording = (recordingId) => __async(this, null, function* () {
    state.delete(recordingId, true);
  });
  return {
    activeRecordings,
    clearAllRecordings,
    deleteRecording,
    getRecording,
    isRecordingCreated,
    setRecording,
    updateRecording
  };
}
function byId(devices) {
  return devices.reduce(
    (result, { deviceId, kind, label }) => {
      if (kind === "videoinput" || kind === "audioinput") {
        result[deviceId] = {
          label,
          type: kind
        };
      }
      return result;
    },
    {}
  );
}
function byType(devices) {
  return devices.reduce(
    (result, { deviceId, kind, label }) => {
      if (kind === "videoinput") {
        result.video.push({ label, deviceId });
      }
      if (kind === "audioinput") {
        result.audio.push({ label, deviceId });
      }
      return result;
    },
    {
      video: [],
      audio: []
    }
  );
}
function getUserPermission() {
  return __async(this, null, function* () {
    try {
      const stream = yield navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true
      });
      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();
      stream.getTracks().forEach((track) => {
        track.stop();
      });
      return mediaDevices;
    } catch (error2) {
      throw new Error(ERROR_MESSAGES.NO_USER_PERMISSION);
    }
  });
}
function getDevices() {
  return __async(this, null, function* () {
    let devicesByType = {
      video: [],
      audio: []
    };
    let devicesById = {};
    let initialDevices = {
      video: null,
      audio: null
    };
    if (typeof window !== "undefined") {
      const mediaDevices = yield getUserPermission();
      devicesById = byId(mediaDevices);
      devicesByType = byType(mediaDevices);
      initialDevices = {
        video: {
          deviceId: devicesByType.video[0].deviceId,
          label: devicesByType.video[0].label
        },
        audio: {
          deviceId: devicesByType.audio[0].deviceId,
          label: devicesByType.audio[0].label
        }
      };
    }
    return { devicesByType, devicesById, initialDevices };
  });
}
function useRecorder({
  mediaRecorderOptions,
  options,
  devices,
  handleError
}) {
  const {
    activeRecordings,
    clearAllRecordings,
    deleteRecording,
    getRecording,
    isRecordingCreated,
    setRecording,
    updateRecording
  } = useRecordingStore();
  const recorderOptions = reactExports.useMemo(
    () => __spreadValues(__spreadValues({}, DEFAULT_RECORDER_OPTIONS), mediaRecorderOptions),
    [mediaRecorderOptions]
  );
  const startRecording = (recordingId) => __async(this, null, function* () {
    var _a210;
    try {
      const recording = getRecording(recordingId);
      const stream = (_a210 = recording.webcamRef.current) == null ? void 0 : _a210.srcObject;
      recording.mimeType = recorderOptions.mimeType || recording.mimeType;
      const isCodecSupported = MediaRecorder.isTypeSupported(
        recording.mimeType
      );
      if (!isCodecSupported) {
        console.warn("Codec not supported: ", recording.mimeType);
        handleError("startRecording", ERROR_MESSAGES.CODEC_NOT_SUPPORTED);
      }
      recording.recorder = new MediaRecorder(stream, recorderOptions);
      return yield new Promise((resolve) => {
        var _a310;
        if (recording.recorder) {
          recording.recorder.ondataavailable = (event) => {
            if (event.data.size) {
              recording.blobChunks.push(event.data);
            }
          };
          recording.recorder.onstart = () => __async(this, null, function* () {
            recording.status = STATUS.RECORDING;
            const updated = yield updateRecording(recording.id, recording);
            resolve(updated);
          });
          recording.recorder.onerror = (error2) => {
            if (recordingId) {
              const recording2 = getRecording(recordingId);
              if (recording2)
                recording2.status = STATUS.ERROR;
            }
            handleError("startRecording", error2);
          };
          (_a310 = recording.recorder) == null ? void 0 : _a310.start(options == null ? void 0 : options.timeSlice);
        }
      });
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("startRecording", error2);
    }
  });
  const pauseRecording = (recordingId) => __async(this, null, function* () {
    var _a210, _b;
    try {
      const recording = getRecording(recordingId);
      (_a210 = recording.recorder) == null ? void 0 : _a210.pause();
      if (((_b = recording.recorder) == null ? void 0 : _b.state) === "paused") {
        recording.status = STATUS.PAUSED;
        const updated = yield updateRecording(recording.id, recording);
        return updated;
      }
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("pauseRecording", error2);
    }
  });
  const resumeRecording = (recordingId) => __async(this, null, function* () {
    var _a210, _b;
    try {
      const recording = getRecording(recordingId);
      (_a210 = recording.recorder) == null ? void 0 : _a210.resume();
      if (((_b = recording.recorder) == null ? void 0 : _b.state) === "recording") {
        recording.status = STATUS.RECORDING;
        const updated = yield updateRecording(recording.id, recording);
        return updated;
      }
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("resumeRecording", error2);
    }
  });
  const stopRecording = (recordingId) => __async(this, null, function* () {
    var _a210;
    try {
      const recording = getRecording(recordingId);
      (_a210 = recording.recorder) == null ? void 0 : _a210.stop();
      return yield new Promise((resolve) => {
        if (recording.recorder) {
          recording.recorder.onstop = () => __async(this, null, function* () {
            recording.status = STATUS.STOPPED;
            const blob = new Blob(recording.blobChunks, {
              type: recording.mimeType
            });
            const url = URL.createObjectURL(blob);
            recording.blob = blob;
            recording.objectURL = url;
            if (recording.previewRef.current) {
              recording.previewRef.current.src = url;
            }
            const updated = yield updateRecording(recording.id, recording);
            resolve(updated);
          });
        }
      });
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("stopRecording", error2);
    }
  });
  const muteRecording = (recordingId) => __async(this, null, function* () {
    var _a210;
    try {
      const recording = getRecording(recordingId);
      (_a210 = recording.recorder) == null ? void 0 : _a210.stream.getAudioTracks().forEach((track) => {
        track.enabled = !track.enabled;
      });
      recording.isMuted = !recording.isMuted;
      return yield updateRecording(recording.id, recording);
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("muteRecording", error2);
    }
  });
  const cancelRecording = (recordingId) => __async(this, null, function* () {
    var _a210, _b, _c;
    try {
      const recording = getRecording(recordingId);
      const tracks = (_a210 = recording == null ? void 0 : recording.recorder) == null ? void 0 : _a210.stream.getTracks();
      (_b = recording == null ? void 0 : recording.recorder) == null ? void 0 : _b.stop();
      tracks == null ? void 0 : tracks.forEach((track) => track.stop());
      ((_c = recording.recorder) == null ? void 0 : _c.ondataavailable) && (recording.recorder.ondataavailable = null);
      if (recording.webcamRef.current) {
        const stream = recording.webcamRef.current.srcObject;
        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());
        recording.webcamRef.current.srcObject = null;
        recording.webcamRef.current.load();
      }
      URL.revokeObjectURL(recording.objectURL);
      yield deleteRecording(recording.id);
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("cancelRecording", error2);
    }
  });
  const createRecording2 = (videoId, audioId) => __async(this, null, function* () {
    var _a210, _b, _c, _d, _e, _f;
    try {
      const { devicesById, initialDevices } = devices || {};
      const videoLabel = videoId ? devicesById == null ? void 0 : devicesById[videoId].label : (_a210 = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _a210.label;
      const audioLabel = audioId ? devicesById == null ? void 0 : devicesById[audioId].label : (_b = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _b.label;
      const recordingId = `${videoId || ((_c = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _c.deviceId)}-${audioId || ((_d = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _d.deviceId)}`;
      const isCreated = isRecordingCreated(recordingId);
      if (isCreated)
        throw new Error(ERROR_MESSAGES.SESSION_EXISTS);
      const recording = yield setRecording({
        videoId: videoId || ((_e = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _e.deviceId),
        audioId: audioId || ((_f = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _f.deviceId),
        videoLabel,
        audioLabel
      });
      return recording;
    } catch (error2) {
      handleError("createRecording", error2);
    }
  });
  const applyRecordingOptions = (recordingId) => __async(this, null, function* () {
    try {
      const recording = getRecording(recordingId);
      if (options == null ? void 0 : options.fileName) {
        recording.fileName = options.fileName;
      }
      if (options == null ? void 0 : options.fileType) {
        recording.fileType = options.fileType;
      }
      const updatedRecording = yield updateRecording(recording.id, recording);
      return updatedRecording;
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("applyRecordingOptions", error2);
    }
  });
  const clearPreview = (recordingId) => __async(this, null, function* () {
    try {
      const recording = getRecording(recordingId);
      if (recording.previewRef.current)
        recording.previewRef.current.src = "";
      recording.status = STATUS.INITIAL;
      URL.revokeObjectURL(recording.objectURL);
      recording.blobChunks = [];
      const updatedRecording = yield updateRecording(recording.id, recording);
      return updatedRecording;
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("clearPreview", error2);
    }
  });
  const download = (recordingId) => __async(this, null, function* () {
    try {
      const recording = getRecording(recordingId);
      const downloadElement = document.createElement("a");
      if (recording == null ? void 0 : recording.objectURL) {
        downloadElement.href = recording.objectURL;
      }
      downloadElement.download = `${recording.fileName}.${recording.fileType}`;
      downloadElement.click();
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("download", error2);
    }
  });
  return {
    activeRecordings,
    applyRecordingOptions,
    clearAllRecordings,
    clearPreview,
    download,
    cancelRecording,
    createRecording: createRecording2,
    muteRecording,
    pauseRecording,
    resumeRecording,
    startRecording,
    stopRecording
  };
}
function startStream(videoId, audioId, constraints) {
  return __async(this, null, function* () {
    const newStream = yield navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: videoId } },
      audio: {
        deviceId: { exact: audioId }
      }
    });
    const tracks = newStream.getTracks();
    tracks.forEach((track) => track.applyConstraints(constraints));
    return newStream;
  });
}
function useCamera({
  mediaTrackConstraints,
  handleError
}) {
  const { getRecording, updateRecording } = useRecordingStore();
  const constraints = reactExports.useMemo(
    () => __spreadValues(__spreadValues({}, DEFAULT_CONSTRAINTS), mediaTrackConstraints),
    [mediaTrackConstraints]
  );
  const applyConstraints = (recordingId, constraints2) => __async(this, null, function* () {
    var _a210, _b;
    try {
      const recording = getRecording(recordingId);
      if ((_a210 = recording.webcamRef.current) == null ? void 0 : _a210.srcObject) {
        const stream = (_b = recording.webcamRef.current) == null ? void 0 : _b.srcObject;
        const tracks = stream.getTracks() || [];
        tracks == null ? void 0 : tracks.forEach((track) => {
          track.applyConstraints(__spreadValues({}, constraints2));
        });
      }
      return recording;
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("applyConstraints", error2);
    }
  });
  const openCamera = (recordingId) => __async(this, null, function* () {
    try {
      const recording = getRecording(recordingId);
      const stream = yield startStream(
        recording.videoId,
        recording.audioId,
        constraints
      );
      if (recording.webcamRef.current) {
        recording.webcamRef.current.srcObject = stream;
        yield recording.webcamRef.current.play();
      }
      recording.status = STATUS.OPEN;
      const updatedRecording = yield updateRecording(recording.id, recording);
      return updatedRecording;
    } catch (error2) {
      handleError("openCamera", error2);
    }
  });
  const closeCamera = (recordingId) => __async(this, null, function* () {
    var _a210;
    try {
      const recording = getRecording(recordingId);
      if (recording.webcamRef.current) {
        const stream = recording.webcamRef.current.srcObject;
        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());
        ((_a210 = recording.recorder) == null ? void 0 : _a210.ondataavailable) && (recording.recorder.ondataavailable = null);
        recording.webcamRef.current.srcObject = null;
        recording.webcamRef.current.load();
      }
      recording.status = STATUS.CLOSED;
      const updatedRecording = yield updateRecording(recording.id, recording);
      return updatedRecording;
    } catch (error2) {
      if (recordingId) {
        const recording = getRecording(recordingId);
        if (recording)
          recording.status = STATUS.ERROR;
      }
      handleError("closeCamera", error2);
    }
  });
  return {
    applyConstraints,
    closeCamera,
    openCamera
  };
}
function useRecordWebcam({
  mediaRecorderOptions,
  mediaTrackConstraints,
  options
} = {}) {
  const [devices, setDevices] = reactExports.useState();
  const [errorMessage, setErrorMessage] = reactExports.useState(null);
  function handleError(functionName, error2) {
    const message2 = typeof error2 === "string" ? error2 : typeof error2.message === "string" ? error2.message : "";
    setErrorMessage(message2);
  }
  function clearError() {
    setErrorMessage(null);
  }
  const { applyConstraints, closeCamera, openCamera } = useCamera({
    mediaTrackConstraints,
    handleError
  });
  const {
    activeRecordings,
    applyRecordingOptions,
    cancelRecording,
    clearAllRecordings,
    clearPreview,
    createRecording: createRecording2,
    download,
    muteRecording,
    pauseRecording,
    resumeRecording,
    startRecording,
    stopRecording
  } = useRecorder({ mediaRecorderOptions, options, devices, handleError });
  function init2() {
    return __async(this, null, function* () {
      try {
        const devices2 = yield getDevices();
        setDevices(devices2);
      } catch (error2) {
        handleError("init", error2);
      }
    });
  }
  reactExports.useEffect(() => {
    init2();
    return () => {
      clearAllRecordings();
    };
  }, []);
  return {
    activeRecordings,
    applyConstraints,
    applyRecordingOptions,
    cancelRecording,
    clearAllRecordings,
    clearError,
    clearPreview,
    closeCamera,
    createRecording: createRecording2,
    devicesById: devices == null ? void 0 : devices.devicesById,
    devicesByType: devices == null ? void 0 : devices.devicesByType,
    download,
    errorMessage,
    muteRecording,
    openCamera,
    pauseRecording,
    resumeRecording,
    startRecording,
    stopRecording
  };
}
function VideoContainer({
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "space-y-2 w-[32rem] rounded-md mx-auto p-2 border border-border", children });
}
function $67824d98245208a0$var$defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function $67824d98245208a0$var$getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function $67824d98245208a0$var$isNumber(value) {
  return typeof value === "number";
}
function $67824d98245208a0$var$isValidMaxNumber(max2) {
  return $67824d98245208a0$var$isNumber(max2) && !isNaN(max2) && max2 > 0;
}
function $67824d98245208a0$var$isValidValueNumber(value, max2) {
  return $67824d98245208a0$var$isNumber(value) && !isNaN(value) && value <= max2 && value >= 0;
}
function $67824d98245208a0$var$getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${$67824d98245208a0$var$DEFAULT_MAX}\`.`;
}
function $67824d98245208a0$var$getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${$67824d98245208a0$var$DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
function $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "bottom":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      });
      break;
    case "left":
      paddedExitPoints.push({
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "right":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      });
      break;
  }
  return paddedExitPoints;
}
function $a093c7e1ec25a057$var$getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    {
      x: left,
      y: top
    },
    {
      x: right,
      y: top
    },
    {
      x: right,
      y: bottom
    },
    {
      x: left,
      y: bottom
    }
  ];
}
function $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {
  const { x: x4, y: y3 } = point;
  let inside = false;
  for (let i2 = 0, j3 = polygon.length - 1; i2 < polygon.length; j3 = i2++) {
    const xi2 = polygon[i2].x;
    const yi2 = polygon[i2].y;
    const xj2 = polygon[j3].x;
    const yj2 = polygon[j3].y;
    const intersect2 = yi2 > y3 !== yj2 > y3 && x4 < (xj2 - xi2) * (y3 - yi2) / (yj2 - yi2) + xi2;
    if (intersect2)
      inside = !inside;
  }
  return inside;
}
function $a093c7e1ec25a057$var$getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x)
      return -1;
    else if (a2.x > b2.x)
      return 1;
    else if (a2.y < b2.y)
      return -1;
    else if (a2.y > b2.y)
      return 1;
    else
      return 0;
  });
  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);
}
function $a093c7e1ec25a057$var$getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p4 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r5 = upperHull[upperHull.length - 2];
      if ((q2.x - r5.x) * (p4.y - r5.y) >= (q2.y - r5.y) * (p4.x - r5.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p4);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i1 = points.length - 1; i1 >= 0; i1--) {
    const p4 = points[i1];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r5 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r5.x) * (p4.y - r5.y) >= (q2.y - r5.y) * (p4.x - r5.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p4);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
function Video2({ onAddToForm }) {
  const [recordingID, setRecordingID] = reactExports.useState();
  const [progress, setProgress] = reactExports.useState(0);
  const [formattedTime, setFormattedTime] = reactExports.useState("00:00");
  const recordingTimeRef = reactExports.useRef({
    startTime: 0,
    elapsedTime: 0
  });
  const progressIntervalRef = reactExports.useRef();
  const {
    createRecording: createRecording2,
    activeRecordings,
    openCamera,
    startRecording,
    stopRecording,
    clearAllRecordings,
    resumeRecording,
    errorMessage,
    pauseRecording
  } = useRecordWebcam({
    options: {
      fileType: "webm",
      timeSlice: 1e3
    },
    mediaRecorderOptions: { mimeType: "video/webm; codecs=vp8" },
    mediaTrackConstraints: {}
  });
  reactExports.useEffect(() => {
    const startNewRecording = async () => await newRecording();
    startNewRecording();
  }, []);
  reactExports.useEffect(() => {
    const startCamera = async () => {
      if (recordingID) {
        await openCamera(recordingID);
      }
    };
    startCamera();
  }, [recordingID]);
  async function handleOnAddToForm() {
    const recording = activeRecordings.find((r5) => r5.id === recordingID);
    if (recording) {
      const fileName = `cv-video-${generateId(15)}.webm`;
      const file = new File([recording.blob], fileName, {
        type: "video/webm",
        lastModified: Date.now()
      });
      onAddToForm(file);
    }
  }
  async function pause() {
    if (recordingID) {
      await pauseRecording(recordingID);
      const now = Date.now();
      recordingTimeRef.current.elapsedTime += now - recordingTimeRef.current.startTime;
      recordingTimeRef.current.startTime = 0;
      clearInterval(progressIntervalRef.current);
    }
  }
  async function stop() {
    if (recordingID) {
      clearInterval(progressIntervalRef.current);
      await stopRecording(recordingID);
    }
  }
  async function resume() {
    if (recordingID) {
      await resumeRecording(recordingID);
      recordingTimeRef.current.startTime = Date.now();
      startNewRecordingInterval();
    }
  }
  async function newRecording() {
    clearAllRecordings();
    const recording = await createRecording2();
    if (recording) {
      setRecordingID(recording.id);
      setProgress(0);
      setFormattedTime("00:00");
      recordingTimeRef.current = { startTime: 0, elapsedTime: 0 };
    }
  }
  async function start() {
    if (recordingID) {
      await startRecording(recordingID);
      recordingTimeRef.current.startTime = Date.now();
      startNewRecordingInterval();
    }
  }
  function startNewRecordingInterval() {
    progressIntervalRef.current = setInterval(() => {
      const elapsedTime = Date.now() - recordingTimeRef.current.startTime + recordingTimeRef.current.elapsedTime;
      const progress2 = Math.min(100, elapsedTime / 6e4 * 100);
      setProgress(progress2);
      setFormattedTime(formatTime(elapsedTime));
      if (progress2 >= 99) {
        stop();
      }
    }, 1e3);
  }
  if (errorMessage) {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(VideoContainer, { children: "ERROR" });
  }
  return activeRecordings.map((r5, i2) => {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: `${r5.status !== "STOPPED" ? "hidden" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(VideoContainer, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        VideoPreview,
        {
          ref: r5.previewRef,
          onAddToForm: handleOnAddToForm,
          onNewRecording: newRecording
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: `${r5.status === "STOPPED" ? "hidden" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(VideoContainer, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        VideoRecorder,
        {
          ref: r5.webcamRef,
          formattedTime,
          progress,
          status: r5.status,
          onPause: pause,
          onResume: resume,
          onStart: start,
          onStop: stop
        }
      ) }) })
    ] }, `video-recording-${r5.id}`);
  });
}
function formatTime(milliseconds) {
  const totalSeconds = Math.floor(milliseconds / 1e3);
  const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, "0");
  const seconds = (totalSeconds % 60).toString().padStart(2, "0");
  return `${minutes}:${seconds}`;
}
function CVFormFields(props) {
  const [videoRecording, setVideoRecording] = reactExports.useState(false);
  const form = useForm({
    resolver: t4(formSchema),
    defaultValues: {
      name: "",
      email: "",
      place: "And\xFAjar",
      position: "Carnicer\xEDa"
    }
  });
  const videoRef = form.register("video");
  const pdfRef = form.register("pdf");
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Form, { ...form, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    "form",
    {
      onSubmit: form.handleSubmit(props.onSubmit),
      className: "space-y-4 max-w-lg mx-auto w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "name",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { children: "Nombre" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Input, { ...field }) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "email",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { children: "Email" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Input, { ...field }) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "place",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { children: "Lugar" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Select, { onValueChange: field.onChange, defaultValue: field.value, children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectValue, { placeholder: "Seleccione el lugar" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectContent, { children: places.map((place) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectItem, { value: place, children: place }, place)) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "position",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { children: "Puesto" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Select, { onValueChange: field.onChange, defaultValue: field.value, children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectValue, { placeholder: "Seleccione el puesto" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectContent, { children: positions.map((position) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(SelectItem, { value: position, children: position }, position)) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "pdf",
            render: () => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { children: "CV" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Input, { type: "file", ...pdfRef }) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          FormField,
          {
            control: form.control,
            name: "video",
            render: () => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormItem, { className: "w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormLabel, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                  Button$1,
                  {
                    variant: "link",
                    type: "button",
                    className: "p-0",
                    onClick: () => {
                      if (videoRecording) {
                        setVideoRecording(false);
                      }
                    },
                    children: "Video"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: "/" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
                  Button$1,
                  {
                    variant: "link",
                    className: "p-0 flex items-center gap-2",
                    type: "button",
                    onClick: () => {
                      if (!videoRecording) {
                        setVideoRecording(true);
                      }
                    },
                    children: [
                      "Grabacion",
                      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-red-400" })
                    ]
                  }
                )
              ] }) }),
              videoRecording ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                Video2,
                {
                  onAddToForm: (recording) => {
                    const fileList = new DataTransfer();
                    fileList.items.add(recording);
                    form.setValue("video", fileList.files, {
                      shouldDirty: true,
                      shouldTouch: true
                    });
                    setVideoRecording(false);
                  }
                }
              ) : /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Input, { type: "file", ...videoRef }) }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormMessage, {})
              ] })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button$1, { type: "submit", children: "Enviar" })
      ]
    }
  ) });
}
function CVForm() {
  const [mode, setMode] = reactExports.useState(
    "form"
  );
  const [params, setParams] = reactExports.useState(null);
  const [error2, setError] = reactExports.useState(null);
  const { mutate: insertCV } = trpcReact.insertCV.useMutation({
    onSuccess: () => setMode("success"),
    onError: (error22) => {
      setMode("error");
      setError(error22.message || "Upload failed");
    }
  });
  const { startUpload } = useUploadThing("pdfAndVideo", {
    onUploadError: (error22) => {
      setMode("error");
      setError(error22.message || "Upload failed");
    }
  });
  async function onSubmit(values) {
    setMode("loading");
    const uploadedFiles = await startUpload(
      [values.pdf[0], values.video[0]].filter(Boolean)
    );
    if (!uploadedFiles || uploadedFiles.length < MAX_FILES) {
      setMode("error");
      setError("Upload failed");
      return;
    }
    setParams({
      name: values.name,
      email: values.email,
      place: values.place,
      position: values.position,
      attachments: uploadedFiles
    });
    setMode("success");
  }
  function tryAgain() {
    setMode("form");
    setParams(null);
    setError(null);
  }
  reactExports.useEffect(() => {
    if (mode === "success" && params) {
      insertCV(params);
    }
  }, [mode, params, insertCV]);
  if (mode === "success") {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex flex-col items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { className: "font-semibold text-xl text-slate-800", children: "Hemos recibido tu CV" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("h2", { className: "text-lg text-slate-600", children: "\xA1Gracias por tu inter\xE9s!" })
    ] });
  }
  if (mode === "error") {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex flex-col items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { children: "Lamentablemente no pudimos recibir tu CV" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { children: error2 }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button$1, { onClick: tryAgain, children: "Int\xE9ntelo de nuevo" })
    ] });
  }
  if (mode === "loading") {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center flex-col gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(ReloadIcon, { className: "h-4 w-4 animate-spin mx-auto" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { children: "Estamos procesando tu CV..." })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(CVFormFields, { onSubmit });
}
function CVFormIsland() {
  const [queryClient] = reactExports.useState(() => new QueryClient());
  const [trpcClient] = reactExports.useState(
    () => trpcReact.createClient({
      links: [
        httpBatchLink({
          url: "http://localhost:4321/api/trpc"
        })
      ]
    })
  );
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(trpcReact.Provider, { client: trpcClient, queryClient, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(CVForm, {}) }) });
}
var version$1, maybeParseResponseXML2, DEFAULT_ERROR_CODE2, s3CodeToUploadThingCode2, createAPIRequestUrl, createUTReporter, version2, uploadFilesInternal2, genUploader, peerDependencies, noop$12, useInsertionEffect, useEndpointMetadata, INTERNAL_uploadthingHookGen, generateReactHelpers, progressWidths, COMMON_MIME_TYPES, FILES_TO_IGNORE, isDefined, initialState, generateUploadButton, generateUploadDropzone, useUploadThing, isCheckBoxInput, isDateObject, isNullOrUndefined, isObjectType, isObject3, getEventValue, getNodeParentName, isNameInFieldArray, isPlainObject3, isWeb, compact, isUndefined, get, isBoolean, EVENTS, VALIDATION_MODE, INPUT_VALIDATION_RULES, HookFormContext, useFormContext, FormProvider, getProxyFormState, isEmptyObject, shouldRenderFormState, convertToArrayPayload, shouldSubscribeByName, isString2, generateWatchOutput, isKey, stringToPath, set, Controller, appendErrors, getValidationModes, isWatched, iterateFieldsByAction, updateFieldArrayRootError, isFileInput, isFunction2, isHTMLElement2, isMessage, isRadioInput, isRegex, defaultResult, validResult, getCheckboxValue, defaultReturn, getRadioValue, getValueAndMessage, validateField, createSubject, isPrimitive, isMultipleSelect, isRadioOrCheckbox, live, objectHasFunction, getDirtyFields, getFieldValueAs, getResolverOptions, getRuleValue, hasValidation, skipValidation, unsetEmptyArray, defaultOptions2, t$14, i, n$12, o2, n4, t4, $b73a6c6685e72184$export$b04be29aa201d4f5, $b73a6c6685e72184$export$be92b6f5f03c0fe9, labelVariants, Label, Form, FormFieldContext, FormField, useFormField, FormItemContext, FormItem, FormLabel, FormControl, FormDescription, FormMessage, __defProp2, __getOwnPropSymbols, __hasOwnProp, __propIsEnum, __defNormalProp2, __spreadValues, __async, audioContainers, videoContainers, audioCodecs, videoCodecs, supportedAudioCodecs, supportedVideoCodecs, videoContainer, videoCodec, _a77, audioCodec, defaultCodec, ERROR_MESSAGES, STATUS, recordingMap, store, DEFAULT_RECORDER_OPTIONS, DEFAULT_CONSTRAINTS, $c1b5f66aac50e106$export$e840e8869344ca38, $c1b5f66aac50e106$export$be92b6f5f03c0fe9, AspectRatio, $67824d98245208a0$var$PROGRESS_NAME, $67824d98245208a0$var$DEFAULT_MAX, $67824d98245208a0$var$createProgressContext, $67824d98245208a0$export$388eb2d8f6d3261f, $67824d98245208a0$var$ProgressProvider, $67824d98245208a0$var$useProgressContext, $67824d98245208a0$export$b25a304ec7d746bb, $67824d98245208a0$var$INDICATOR_NAME, $67824d98245208a0$export$2b776f7e7ee60dbd, $67824d98245208a0$export$be92b6f5f03c0fe9, $67824d98245208a0$export$adb584737d712b70, Progress, RedProgress, $a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865, $a093c7e1ec25a057$var$usePopperScope, $a093c7e1ec25a057$var$PROVIDER_NAME, $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, $a093c7e1ec25a057$var$TOOLTIP_OPEN, $a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext, $a093c7e1ec25a057$export$f78649fb9ca566b8, $a093c7e1ec25a057$var$TOOLTIP_NAME, $a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext, $a093c7e1ec25a057$export$28c660c63b792dea, $a093c7e1ec25a057$var$TRIGGER_NAME, $a093c7e1ec25a057$export$8c610744efcf8a1d, $a093c7e1ec25a057$var$PORTAL_NAME, $a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext, $a093c7e1ec25a057$var$CONTENT_NAME, $a093c7e1ec25a057$export$e9003e2be37ec060, $a093c7e1ec25a057$var$TooltipContentHoverable, $a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext, $a093c7e1ec25a057$var$TooltipContentImpl, $a093c7e1ec25a057$export$2881499e37b75b9a, $a093c7e1ec25a057$export$be92b6f5f03c0fe9, $a093c7e1ec25a057$export$41fb9f06171c75f4, $a093c7e1ec25a057$export$7c6e2c02157bb7d2, TooltipProvider, Tooltip, TooltipTrigger, TooltipContent, VideoRecorder, VideoPreview, pdfSchema, videoSchema, formSchema, MAX_FILES, $$Astro3, $$Index, $$file2, $$url2;
var init_index_TRNjimg9 = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/pages/index_TRNjimg9.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_cvs_qudRXU8T();
    await init_trpc_GIzfMcGy();
    init_astro_BO0wYrHs();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    version$1 = "6.9.0";
    maybeParseResponseXML2 = (maybeXml) => {
      const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
      const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
      const code = codeMatch?.[1];
      const message2 = messageMatch?.[1];
      if (!code || !message2)
        return null;
      return {
        code: s3CodeToUploadThingCode2[code] ?? DEFAULT_ERROR_CODE2,
        message: message2
      };
    };
    DEFAULT_ERROR_CODE2 = "UPLOAD_FAILED";
    s3CodeToUploadThingCode2 = {
      AccessDenied: "FORBIDDEN",
      EntityTooSmall: "TOO_SMALL",
      EntityTooLarge: "TOO_LARGE",
      ExpiredToken: "FORBIDDEN",
      IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
      InternalError: "INTERNAL_SERVER_ERROR",
      KeyTooLongError: "KEY_TOO_LONG",
      MaxMessageLengthExceeded: "TOO_LARGE"
    };
    createAPIRequestUrl = (config) => {
      const url = new URL(config.url);
      const queryParams = new URLSearchParams(url.search);
      queryParams.set("actionType", config.actionType);
      queryParams.set("slug", config.slug);
      url.search = queryParams.toString();
      return url;
    };
    createUTReporter = (cfg) => {
      return async (type, payload) => {
        const url = createAPIRequestUrl({
          url: cfg.url,
          slug: cfg.endpoint,
          actionType: type
        });
        let customHeaders = typeof cfg.headers === "function" ? cfg.headers() : cfg.headers;
        if (customHeaders instanceof Promise)
          customHeaders = await customHeaders;
        const response = await cfg.fetch(url, {
          method: "POST",
          body: JSON.stringify(payload),
          headers: {
            "Content-Type": "application/json",
            "x-uploadthing-package": cfg.package,
            "x-uploadthing-version": version$1,
            ...customHeaders
          }
        });
        switch (type) {
          case "failure": {
            const p4 = payload;
            const parsed = maybeParseResponseXML2(p4.s3Error ?? "");
            if (parsed?.message) {
              throw new UploadThingError({
                code: parsed.code,
                message: parsed.message
              });
            } else {
              throw new UploadThingError({
                code: "UPLOAD_FAILED",
                message: `Failed to upload file ${p4.fileName} to S3`,
                cause: p4.s3Error
              });
            }
          }
        }
        if (!response.ok) {
          const error2 = await UploadThingError.fromResponse(response);
          throw error2;
        }
        const jsonOrError = await safeParseJSON(response);
        if (jsonOrError instanceof Error) {
          throw new UploadThingError({
            code: "BAD_REQUEST",
            message: jsonOrError.message,
            cause: response
          });
        }
        return jsonOrError;
      };
    };
    version2 = version$1;
    uploadFilesInternal2 = async (endpoint, opts2) => {
      const fetch2 = globalThis.fetch.bind(globalThis);
      const reportEventToUT = createUTReporter({
        endpoint: String(endpoint),
        url: opts2.url,
        package: opts2.package,
        fetch: fetch2,
        headers: opts2.headers
      });
      const s3ConnectionRes = await reportEventToUT("upload", {
        input: "input" in opts2 ? opts2.input : null,
        files: opts2.files.map((f3) => ({
          name: f3.name,
          size: f3.size,
          type: f3.type
        }))
      });
      if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {
        throw new UploadThingError({
          code: "BAD_REQUEST",
          message: "No URL. How did you even get here?",
          cause: s3ConnectionRes
        });
      }
      const fileUploadPromises = s3ConnectionRes.map(async (presigned) => {
        const file = opts2.files.find((f3) => f3.name === presigned.fileName);
        if (!file) {
          console.error("No file found for presigned URL", presigned);
          throw new UploadThingError({
            code: "NOT_FOUND",
            message: "No file found for presigned URL",
            cause: `Expected file with name ${presigned.fileName} but got '${opts2.files.join(",")}'`
          });
        }
        opts2.onUploadBegin?.({
          file: file.name
        });
        if ("urls" in presigned) {
          await uploadMultipart2(file, presigned, {
            reportEventToUT,
            ...opts2
          });
          await new Promise((r5) => setTimeout(r5, 750));
        } else {
          await uploadPresignedPost2(file, presigned, {
            reportEventToUT,
            ...opts2
          });
        }
        let serverData = null;
        if (!opts2.skipPolling) {
          serverData = await withExponentialBackoff(async () => {
            const res = await fetch2(presigned.pollingUrl, {
              headers: {
                authorization: presigned.pollingJwt
              }
            }).then((r5) => r5.json());
            return res.status === "done" ? res.callbackData : void 0;
          });
        }
        return {
          name: file.name,
          size: file.size,
          type: file.type,
          key: presigned.key,
          url: "https://utfs.io/f/" + presigned.key,
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          serverData,
          customId: presigned.customId
        };
      });
      return Promise.all(fileUploadPromises);
    };
    genUploader = (initOpts) => {
      return (endpoint, opts2) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        uploadFilesInternal2(endpoint, {
          ...opts2,
          url: resolveMaybeUrlArg(initOpts?.url),
          package: initOpts.package
        })
      );
    };
    peerDependencies = {
      next: "*",
      react: "^17.0.2 || ^18.0.0",
      uploadthing: "^6.5.1"
    };
    noop$12 = () => void 0;
    useInsertionEffect = typeof window !== "undefined" ? React.useInsertionEffect || React.useLayoutEffect : noop$12;
    useEndpointMetadata = (url, endpoint) => {
      const maybeServerData = globalThis.__UPLOADTHING;
      const { data } = useFetch(
        // Don't fetch if we already have the data
        maybeServerData ? void 0 : url.href
      );
      return (maybeServerData ?? data)?.find((x4) => x4.slug === endpoint);
    };
    INTERNAL_uploadthingHookGen = (initOpts) => {
      if (!semverLite(peerDependencies.uploadthing, version2)) {
        console.error(`!!!WARNING::: @uploadthing/react requires "uploadthing@${peerDependencies.uploadthing}", but version "${version2}" is installed`);
      }
      const uploadFiles = genUploader({
        url: initOpts.url,
        package: "@uploadthing/react"
      });
      const useUploadThing2 = (endpoint, opts2) => {
        const [isUploading, setUploading] = reactExports.useState(false);
        const uploadProgress = reactExports.useRef(0);
        const fileProgress = reactExports.useRef(/* @__PURE__ */ new Map());
        const permittedFileInfo = useEndpointMetadata(initOpts.url, endpoint);
        const startUpload = useEvent(async (...args) => {
          const files = await opts2?.onBeforeUploadBegin?.(args[0]) ?? args[0];
          const input = args[1];
          setUploading(true);
          opts2?.onUploadProgress?.(0);
          try {
            const res = await uploadFiles(endpoint, {
              headers: opts2?.headers,
              files,
              skipPolling: opts2?.skipPolling,
              onUploadProgress: (progress) => {
                if (!opts2?.onUploadProgress)
                  return;
                fileProgress.current.set(progress.file, progress.progress);
                let sum3 = 0;
                fileProgress.current.forEach((p4) => {
                  sum3 += p4;
                });
                const averageProgress = Math.floor(sum3 / fileProgress.current.size / 10) * 10;
                if (averageProgress !== uploadProgress.current) {
                  opts2?.onUploadProgress?.(averageProgress);
                  uploadProgress.current = averageProgress;
                }
              },
              onUploadBegin({ file }) {
                if (!opts2?.onUploadBegin)
                  return;
                opts2.onUploadBegin(file);
              },
              // @ts-expect-error - input may not be defined on the type
              input
            });
            opts2?.onClientUploadComplete?.(res);
            return res;
          } catch (e2) {
            let error2;
            if (e2 instanceof UploadThingError) {
              error2 = e2;
            } else {
              error2 = INTERNAL_DO_NOT_USE__fatalClientError(e2);
              console.error("Something went wrong. Please contact UploadThing and provide the following cause:", error2.cause instanceof Error ? error2.cause.toString() : error2.cause);
            }
            opts2?.onUploadError?.(error2);
          } finally {
            setUploading(false);
            fileProgress.current = /* @__PURE__ */ new Map();
            uploadProgress.current = 0;
          }
        });
        return {
          startUpload,
          isUploading,
          permittedFileInfo
        };
      };
      return useUploadThing2;
    };
    generateReactHelpers = (initOpts) => {
      const url = resolveMaybeUrlArg(initOpts?.url);
      return {
        useUploadThing: INTERNAL_uploadthingHookGen({
          url
        }),
        uploadFiles: genUploader({
          url,
          package: "@uploadthing/react"
        })
      };
    };
    progressWidths = {
      0: "after:w-0",
      10: "after:w-[10%]",
      20: "after:w-[20%]",
      30: "after:w-[30%]",
      40: "after:w-[40%]",
      50: "after:w-[50%]",
      60: "after:w-[60%]",
      70: "after:w-[70%]",
      80: "after:w-[80%]",
      90: "after:w-[90%]",
      100: "after:w-[100%]"
    };
    COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
      ["aac", "audio/aac"],
      ["abw", "application/x-abiword"],
      ["arc", "application/x-freearc"],
      ["avif", "image/avif"],
      ["avi", "video/x-msvideo"],
      ["azw", "application/vnd.amazon.ebook"],
      ["bin", "application/octet-stream"],
      ["bmp", "image/bmp"],
      ["bz", "application/x-bzip"],
      ["bz2", "application/x-bzip2"],
      ["cda", "application/x-cdf"],
      ["csh", "application/x-csh"],
      ["css", "text/css"],
      ["csv", "text/csv"],
      ["doc", "application/msword"],
      ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
      ["eot", "application/vnd.ms-fontobject"],
      ["epub", "application/epub+zip"],
      ["gz", "application/gzip"],
      ["gif", "image/gif"],
      ["heic", "image/heic"],
      ["heif", "image/heif"],
      ["htm", "text/html"],
      ["html", "text/html"],
      ["ico", "image/vnd.microsoft.icon"],
      ["ics", "text/calendar"],
      ["jar", "application/java-archive"],
      ["jpeg", "image/jpeg"],
      ["jpg", "image/jpeg"],
      ["js", "text/javascript"],
      ["json", "application/json"],
      ["jsonld", "application/ld+json"],
      ["mid", "audio/midi"],
      ["midi", "audio/midi"],
      ["mjs", "text/javascript"],
      ["mp3", "audio/mpeg"],
      ["mp4", "video/mp4"],
      ["mpeg", "video/mpeg"],
      ["mpkg", "application/vnd.apple.installer+xml"],
      ["odp", "application/vnd.oasis.opendocument.presentation"],
      ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
      ["odt", "application/vnd.oasis.opendocument.text"],
      ["oga", "audio/ogg"],
      ["ogv", "video/ogg"],
      ["ogx", "application/ogg"],
      ["opus", "audio/opus"],
      ["otf", "font/otf"],
      ["png", "image/png"],
      ["pdf", "application/pdf"],
      ["php", "application/x-httpd-php"],
      ["ppt", "application/vnd.ms-powerpoint"],
      ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
      ["rar", "application/vnd.rar"],
      ["rtf", "application/rtf"],
      ["sh", "application/x-sh"],
      ["svg", "image/svg+xml"],
      ["swf", "application/x-shockwave-flash"],
      ["tar", "application/x-tar"],
      ["tif", "image/tiff"],
      ["tiff", "image/tiff"],
      ["ts", "video/mp2t"],
      ["ttf", "font/ttf"],
      ["txt", "text/plain"],
      ["vsd", "application/vnd.visio"],
      ["wav", "audio/wav"],
      ["weba", "audio/webm"],
      ["webm", "video/webm"],
      ["webp", "image/webp"],
      ["woff", "font/woff"],
      ["woff2", "font/woff2"],
      ["xhtml", "application/xhtml+xml"],
      ["xls", "application/vnd.ms-excel"],
      ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
      ["xml", "application/xml"],
      ["xul", "application/vnd.mozilla.xul+xml"],
      ["zip", "application/zip"],
      ["7z", "application/x-7z-compressed"],
      // Others
      ["mkv", "video/x-matroska"],
      ["mov", "video/quicktime"],
      ["msg", "application/vnd.ms-outlook"]
    ]);
    FILES_TO_IGNORE = [
      // Thumbnail cache files for macOS and Windows
      ".DS_Store",
      "Thumbs.db"
      // Windows
    ];
    isDefined = (v4) => v4 != null;
    initialState = {
      isFocused: false,
      isFileDialogActive: false,
      isDragActive: false,
      isDragAccept: false,
      isDragReject: false,
      acceptedFiles: []
    };
    generateUploadButton = (opts2) => {
      const url = resolveMaybeUrlArg(opts2?.url);
      const TypedButton = (props) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(UploadButton, {
        ...props,
        url
      });
      return TypedButton;
    };
    generateUploadDropzone = (opts2) => {
      const url = resolveMaybeUrlArg(opts2?.url);
      const TypedDropzone = (props) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(UploadDropzone, {
        ...props,
        url
      });
      return TypedDropzone;
    };
    generateUploadButton();
    generateUploadDropzone();
    ({ useUploadThing } = generateReactHelpers());
    isCheckBoxInput = (element) => element.type === "checkbox";
    isDateObject = (value) => value instanceof Date;
    isNullOrUndefined = (value) => value == null;
    isObjectType = (value) => typeof value === "object";
    isObject3 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
    getEventValue = (event) => isObject3(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
    getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
    isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
    isPlainObject3 = (tempObject) => {
      const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
      return isObject3(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
    };
    isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
    compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
    isUndefined = (val) => val === void 0;
    get = (object2, path, defaultValue) => {
      if (!path || !isObject3(object2)) {
        return defaultValue;
      }
      const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object2);
      return isUndefined(result) || result === object2 ? isUndefined(object2[path]) ? defaultValue : object2[path] : result;
    };
    isBoolean = (value) => typeof value === "boolean";
    EVENTS = {
      BLUR: "blur",
      FOCUS_OUT: "focusout",
      CHANGE: "change"
    };
    VALIDATION_MODE = {
      onBlur: "onBlur",
      onChange: "onChange",
      onSubmit: "onSubmit",
      onTouched: "onTouched",
      all: "all"
    };
    INPUT_VALIDATION_RULES = {
      max: "max",
      min: "min",
      maxLength: "maxLength",
      minLength: "minLength",
      pattern: "pattern",
      required: "required",
      validate: "validate"
    };
    HookFormContext = React.createContext(null);
    useFormContext = () => React.useContext(HookFormContext);
    FormProvider = (props) => {
      const { children, ...data } = props;
      return React.createElement(HookFormContext.Provider, { value: data }, children);
    };
    getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
      const result = {
        defaultValues: control._defaultValues
      };
      for (const key in formState) {
        Object.defineProperty(result, key, {
          get: () => {
            const _key = key;
            if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
              control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
            }
            localProxyFormState && (localProxyFormState[_key] = true);
            return formState[_key];
          }
        });
      }
      return result;
    };
    isEmptyObject = (value) => isObject3(value) && !Object.keys(value).length;
    shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
      updateFormState(formStateData);
      const { name, ...formState } = formStateData;
      return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
    };
    convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
    shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
    isString2 = (value) => typeof value === "string";
    generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
      if (isString2(names)) {
        isGlobal && _names.watch.add(names);
        return get(formValues, names, defaultValue);
      }
      if (Array.isArray(names)) {
        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
      }
      isGlobal && (_names.watchAll = true);
      return formValues;
    };
    isKey = (value) => /^\w*$/.test(value);
    stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
    set = (object2, path, value) => {
      let index3 = -1;
      const tempPath = isKey(path) ? [path] : stringToPath(path);
      const length = tempPath.length;
      const lastIndex = length - 1;
      while (++index3 < length) {
        const key = tempPath[index3];
        let newValue = value;
        if (index3 !== lastIndex) {
          const objValue = object2[key];
          newValue = isObject3(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index3 + 1]) ? [] : {};
        }
        object2[key] = newValue;
        object2 = object2[key];
      }
      return object2;
    };
    Controller = (props) => props.render(useController(props));
    appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
      ...errors[name],
      types: {
        ...errors[name] && errors[name].types ? errors[name].types : {},
        [type]: message2 || true
      }
    } : {};
    getValidationModes = (mode) => ({
      isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
      isOnBlur: mode === VALIDATION_MODE.onBlur,
      isOnChange: mode === VALIDATION_MODE.onChange,
      isOnAll: mode === VALIDATION_MODE.all,
      isOnTouch: mode === VALIDATION_MODE.onTouched
    });
    isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
    iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
      for (const key of fieldsNames || Object.keys(fields)) {
        const field = get(fields, key);
        if (field) {
          const { _f, ...currentField } = field;
          if (_f) {
            if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
              break;
            } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
              break;
            } else {
              iterateFieldsByAction(currentField, action);
            }
          } else if (isObject3(currentField)) {
            iterateFieldsByAction(currentField, action);
          }
        }
      }
    };
    updateFieldArrayRootError = (errors, error2, name) => {
      const fieldArrayErrors = compact(get(errors, name));
      set(fieldArrayErrors, "root", error2[name]);
      set(errors, name, fieldArrayErrors);
      return errors;
    };
    isFileInput = (element) => element.type === "file";
    isFunction2 = (value) => typeof value === "function";
    isHTMLElement2 = (value) => {
      if (!isWeb) {
        return false;
      }
      const owner = value ? value.ownerDocument : 0;
      return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
    };
    isMessage = (value) => isString2(value);
    isRadioInput = (element) => element.type === "radio";
    isRegex = (value) => value instanceof RegExp;
    defaultResult = {
      value: false,
      isValid: false
    };
    validResult = { value: true, isValid: true };
    getCheckboxValue = (options) => {
      if (Array.isArray(options)) {
        if (options.length > 1) {
          const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
          return { value: values, isValid: !!values.length };
        }
        return options[0].checked && !options[0].disabled ? (
          // @ts-expect-error expected to work in the browser
          options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
        ) : defaultResult;
      }
      return defaultResult;
    };
    defaultReturn = {
      isValid: false,
      value: null
    };
    getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
      isValid: true,
      value: option.value
    } : previous, defaultReturn) : defaultReturn;
    getValueAndMessage = (validationData) => isObject3(validationData) && !isRegex(validationData) ? validationData : {
      value: validationData,
      message: ""
    };
    validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
      const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;
      const inputValue = get(formValues, name);
      if (!mount || disabled) {
        return {};
      }
      const inputRef = refs ? refs[0] : ref;
      const setCustomValidity = (message2) => {
        if (shouldUseNativeValidation && inputRef.reportValidity) {
          inputRef.setCustomValidity(isBoolean(message2) ? "" : message2 || "");
          inputRef.reportValidity();
        }
      };
      const error2 = {};
      const isRadio = isRadioInput(ref);
      const isCheckBox = isCheckBoxInput(ref);
      const isRadioOrCheckbox2 = isRadio || isCheckBox;
      const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement2(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
      const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error2);
      const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
        const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
        error2[name] = {
          type: exceedMax ? maxType : minType,
          message: message2,
          ref,
          ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
        };
      };
      if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
        const { value, message: message2 } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
        if (value) {
          error2[name] = {
            type: INPUT_VALIDATION_RULES.required,
            message: message2,
            ref: inputRef,
            ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
          };
          if (!validateAllFieldCriteria) {
            setCustomValidity(message2);
            return error2;
          }
        }
      }
      if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
        let exceedMax;
        let exceedMin;
        const maxOutput = getValueAndMessage(max2);
        const minOutput = getValueAndMessage(min2);
        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
          const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
          if (!isNullOrUndefined(maxOutput.value)) {
            exceedMax = valueNumber > maxOutput.value;
          }
          if (!isNullOrUndefined(minOutput.value)) {
            exceedMin = valueNumber < minOutput.value;
          }
        } else {
          const valueDate = ref.valueAsDate || new Date(inputValue);
          const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
          const isTime = ref.type == "time";
          const isWeek = ref.type == "week";
          if (isString2(maxOutput.value) && inputValue) {
            exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
          }
          if (isString2(minOutput.value) && inputValue) {
            exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
          }
        }
        if (exceedMax || exceedMin) {
          getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
          if (!validateAllFieldCriteria) {
            setCustomValidity(error2[name].message);
            return error2;
          }
        }
      }
      if ((maxLength || minLength) && !isEmpty && (isString2(inputValue) || isFieldArray && Array.isArray(inputValue))) {
        const maxLengthOutput = getValueAndMessage(maxLength);
        const minLengthOutput = getValueAndMessage(minLength);
        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
        if (exceedMax || exceedMin) {
          getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
          if (!validateAllFieldCriteria) {
            setCustomValidity(error2[name].message);
            return error2;
          }
        }
      }
      if (pattern && !isEmpty && isString2(inputValue)) {
        const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !inputValue.match(patternValue)) {
          error2[name] = {
            type: INPUT_VALIDATION_RULES.pattern,
            message: message2,
            ref,
            ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
          };
          if (!validateAllFieldCriteria) {
            setCustomValidity(message2);
            return error2;
          }
        }
      }
      if (validate) {
        if (isFunction2(validate)) {
          const result = await validate(inputValue, formValues);
          const validateError = getValidateError(result, inputRef);
          if (validateError) {
            error2[name] = {
              ...validateError,
              ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
            };
            if (!validateAllFieldCriteria) {
              setCustomValidity(validateError.message);
              return error2;
            }
          }
        } else if (isObject3(validate)) {
          let validationResult = {};
          for (const key in validate) {
            if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
              break;
            }
            const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
            if (validateError) {
              validationResult = {
                ...validateError,
                ...appendErrorsCurry(key, validateError.message)
              };
              setCustomValidity(validateError.message);
              if (validateAllFieldCriteria) {
                error2[name] = validationResult;
              }
            }
          }
          if (!isEmptyObject(validationResult)) {
            error2[name] = {
              ref: inputRef,
              ...validationResult
            };
            if (!validateAllFieldCriteria) {
              return error2;
            }
          }
        }
      }
      setCustomValidity(true);
      return error2;
    };
    createSubject = () => {
      let _observers = [];
      const next = (value) => {
        for (const observer of _observers) {
          observer.next && observer.next(value);
        }
      };
      const subscribe = (observer) => {
        _observers.push(observer);
        return {
          unsubscribe: () => {
            _observers = _observers.filter((o3) => o3 !== observer);
          }
        };
      };
      const unsubscribe = () => {
        _observers = [];
      };
      return {
        get observers() {
          return _observers;
        },
        next,
        subscribe,
        unsubscribe
      };
    };
    isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
    isMultipleSelect = (element) => element.type === `select-multiple`;
    isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
    live = (ref) => isHTMLElement2(ref) && ref.isConnected;
    objectHasFunction = (data) => {
      for (const key in data) {
        if (isFunction2(data[key])) {
          return true;
        }
      }
      return false;
    };
    getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
    getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString2(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
    getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
      const fields = {};
      for (const name of fieldsNames) {
        const field = get(_fields, name);
        field && set(fields, name, field._f);
      }
      return {
        criteriaMode,
        names: [...fieldsNames],
        fields,
        shouldUseNativeValidation
      };
    };
    getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject3(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
    hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
    skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
      if (mode.isOnAll) {
        return false;
      } else if (!isSubmitted && mode.isOnTouch) {
        return !(isTouched || isBlurEvent);
      } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
        return !isBlurEvent;
      } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
        return isBlurEvent;
      }
      return true;
    };
    unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
    defaultOptions2 = {
      mode: VALIDATION_MODE.onSubmit,
      reValidateMode: VALIDATION_MODE.onChange,
      shouldFocusError: true
    };
    t$14 = function(e2, t5, i2) {
      if (e2 && "reportValidity" in e2) {
        var n5 = get(i2, t5);
        e2.setCustomValidity(n5 && n5.message || ""), e2.reportValidity();
      }
    };
    i = function(r5, e2) {
      var i2 = function(i3) {
        var n6 = e2.fields[i3];
        n6 && n6.ref && "reportValidity" in n6.ref ? t$14(n6.ref, i3, r5) : n6.refs && n6.refs.forEach(function(e3) {
          return t$14(e3, i3, r5);
        });
      };
      for (var n5 in e2.fields)
        i2(n5);
    };
    n$12 = function(t5, n5) {
      n5.shouldUseNativeValidation && i(t5, n5);
      var f3 = {};
      for (var a2 in t5) {
        var s3 = get(n5.fields, a2), u4 = Object.assign(t5[a2] || {}, { ref: s3 && s3.ref });
        if (o2(n5.names || Object.keys(t5), a2)) {
          var c2 = Object.assign({}, get(f3, a2));
          set(c2, "root", u4), set(f3, a2, c2);
        } else
          set(f3, a2, u4);
      }
      return f3;
    };
    o2 = function(r5, e2) {
      return r5.some(function(r6) {
        return r6.startsWith(e2 + ".");
      });
    };
    n4 = function(e2, o3) {
      for (var n5 = {}; e2.length; ) {
        var t5 = e2[0], s3 = t5.code, i2 = t5.message, a2 = t5.path.join(".");
        if (!n5[a2])
          if ("unionErrors" in t5) {
            var u4 = t5.unionErrors[0].errors[0];
            n5[a2] = { message: u4.message, type: u4.code };
          } else
            n5[a2] = { message: i2, type: s3 };
        if ("unionErrors" in t5 && t5.unionErrors.forEach(function(r5) {
          return r5.errors.forEach(function(r6) {
            return e2.push(r6);
          });
        }), o3) {
          var c2 = n5[a2].types, f3 = c2 && c2[t5.code];
          n5[a2] = appendErrors(a2, o3, n5, s3, f3 ? [].concat(f3, t5.message) : t5.message);
        }
        e2.shift();
      }
      return n5;
    };
    t4 = function(r5, t5, s3) {
      return void 0 === s3 && (s3 = {}), function(i$1, a2, u4) {
        try {
          return Promise.resolve(function(o3, n5) {
            try {
              var a3 = Promise.resolve(r5["sync" === s3.mode ? "parse" : "parseAsync"](i$1, t5)).then(function(r6) {
                return u4.shouldUseNativeValidation && i({}, u4), { errors: {}, values: s3.raw ? i$1 : r6 };
              });
            } catch (r6) {
              return n5(r6);
            }
            return a3 && a3.then ? a3.then(void 0, n5) : a3;
          }(0, function(r6) {
            if (function(r7) {
              return null != r7.errors;
            }(r6))
              return { values: {}, errors: n$12(n4(r6.errors, !u4.shouldUseNativeValidation && "all" === u4.criteriaMode), u4) };
            throw r6;
          }));
        } catch (r6) {
          return Promise.reject(r6);
        }
      };
    };
    $b73a6c6685e72184$export$b04be29aa201d4f5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.label, _extends({}, props, {
        ref: forwardedRef,
        onMouseDown: (event) => {
          var _props$onMouseDown;
          (_props$onMouseDown = props.onMouseDown) === null || _props$onMouseDown === void 0 || _props$onMouseDown.call(props, event);
          if (!event.defaultPrevented && event.detail > 1)
            event.preventDefault();
        }
      }));
    });
    $b73a6c6685e72184$export$be92b6f5f03c0fe9 = $b73a6c6685e72184$export$b04be29aa201d4f5;
    labelVariants = cva(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
    );
    Label = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $b73a6c6685e72184$export$be92b6f5f03c0fe9,
      {
        ref,
        className: cn$1(labelVariants(), className),
        ...props
      }
    ));
    Label.displayName = $b73a6c6685e72184$export$be92b6f5f03c0fe9.displayName;
    Form = FormProvider;
    FormFieldContext = reactExports.createContext(
      {}
    );
    FormField = ({
      ...props
    }) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormFieldContext.Provider, { value: { name: props.name }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Controller, { ...props }) });
    };
    useFormField = () => {
      const fieldContext = reactExports.useContext(FormFieldContext);
      const itemContext = reactExports.useContext(FormItemContext);
      const { getFieldState, formState } = useFormContext();
      const fieldState = getFieldState(fieldContext.name, formState);
      if (!fieldContext) {
        throw new Error("useFormField should be used within <FormField>");
      }
      const { id: id3 } = itemContext;
      return {
        id: id3,
        name: fieldContext.name,
        formItemId: `${id3}-form-item`,
        formDescriptionId: `${id3}-form-item-description`,
        formMessageId: `${id3}-form-item-message`,
        ...fieldState
      };
    };
    FormItemContext = reactExports.createContext(
      {}
    );
    FormItem = reactExports.forwardRef(({ className, ...props }, ref) => {
      const id3 = reactExports.useId();
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormItemContext.Provider, { value: { id: id3 }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { ref, className: cn$1("space-y-2", className), ...props }) });
    });
    FormItem.displayName = "FormItem";
    FormLabel = reactExports.forwardRef(({ className, ...props }, ref) => {
      const { error: error2, formItemId } = useFormField();
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        Label,
        {
          ref,
          className: cn$1(error2 && "text-destructive", className),
          htmlFor: formItemId,
          ...props
        }
      );
    });
    FormLabel.displayName = "FormLabel";
    FormControl = reactExports.forwardRef(({ ...props }, ref) => {
      const { error: error2, formItemId, formDescriptionId, formMessageId } = useFormField();
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        {
          ref,
          id: formItemId,
          "aria-describedby": !error2 ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
          "aria-invalid": !!error2,
          ...props
        }
      );
    });
    FormControl.displayName = "FormControl";
    FormDescription = reactExports.forwardRef(({ className, ...props }, ref) => {
      const { formDescriptionId } = useFormField();
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "p",
        {
          ref,
          id: formDescriptionId,
          className: cn$1("text-sm text-muted-foreground", className),
          ...props
        }
      );
    });
    FormDescription.displayName = "FormDescription";
    FormMessage = reactExports.forwardRef(({ className, children, ...props }, ref) => {
      const { error: error2, formMessageId } = useFormField();
      const body = error2 ? String(error2?.message) : children;
      if (!body) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "p",
        {
          ref,
          id: formMessageId,
          className: cn$1("text-sm font-medium text-destructive", className),
          ...props,
          children: body
        }
      );
    });
    FormMessage.displayName = "FormMessage";
    __defProp2 = Object.defineProperty;
    __getOwnPropSymbols = Object.getOwnPropertySymbols;
    __hasOwnProp = Object.prototype.hasOwnProperty;
    __propIsEnum = Object.prototype.propertyIsEnumerable;
    __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __spreadValues = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b2)) {
          if (__propIsEnum.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var step = (x4) => x4.done ? resolve(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    audioContainers = [
      "ogg",
      "aac",
      "flac",
      "wav",
      "mp4"
    ];
    videoContainers = [
      "webm",
      "mp4",
      "x-matroska",
      "3gpp",
      "3gpp2",
      "3gp2",
      "quicktime",
      "mpeg"
    ];
    audioCodecs = ["opus", "pcm", "aac", "mp4a"];
    videoCodecs = [
      "vp9",
      "vp8",
      "avc1",
      "av1",
      "h265",
      "h.264",
      "h264",
      "mpeg"
    ];
    supportedAudioCodecs = getSupportedMediaFormats(
      audioContainers,
      audioCodecs,
      "audio"
    );
    supportedVideoCodecs = getSupportedMediaFormats(
      videoContainers,
      videoCodecs,
      "video"
    );
    videoContainer = supportedVideoCodecs.container[0];
    videoCodec = supportedVideoCodecs.codec[0];
    audioCodec = (_a77 = supportedAudioCodecs == null ? void 0 : supportedAudioCodecs.codec) == null ? void 0 : _a77[0];
    defaultCodec = `video/${videoContainer};codecs=${videoCodec}${audioCodec ? `,${audioCodec}` : ""}`;
    ERROR_MESSAGES = {
      CODEC_NOT_SUPPORTED: "CODEC_NOT_SUPPORTED",
      SESSION_EXISTS: "SESSION_EXISTS",
      NO_RECORDING_WITH_ID: "NO_RECORDING_WITH_ID",
      NO_USER_PERMISSION: "NO_USER_PERMISSION"
    };
    STATUS = {
      INITIAL: "INITIAL",
      CLOSED: "CLOSED",
      OPEN: "OPEN",
      RECORDING: "RECORDING",
      STOPPED: "STOPPED",
      ERROR: "ERROR",
      PAUSED: "PAUSED"
    };
    recordingMap = /* @__PURE__ */ new Map();
    store = createStore(recordingMap);
    DEFAULT_RECORDER_OPTIONS = {
      audioBitsPerSecond: 128e3,
      videoBitsPerSecond: 25e5,
      mimeType: defaultCodec
    };
    DEFAULT_CONSTRAINTS = {
      aspectRatio: 1.7,
      echoCancellation: true,
      height: 720,
      width: 1280
    };
    $c1b5f66aac50e106$export$e840e8869344ca38 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { ratio = 1, style, ...aspectRatioProps } = props;
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          // ensures inner element is contained
          position: "relative",
          // ensures padding bottom trick maths works
          width: "100%",
          paddingBottom: `${100 / ratio}%`
        },
        "data-radix-aspect-ratio-wrapper": ""
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, aspectRatioProps, {
        ref: forwardedRef,
        style: {
          ...style,
          // ensures children expand in ratio
          position: "absolute",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      })));
    });
    $c1b5f66aac50e106$export$be92b6f5f03c0fe9 = $c1b5f66aac50e106$export$e840e8869344ca38;
    AspectRatio = $c1b5f66aac50e106$export$be92b6f5f03c0fe9;
    $67824d98245208a0$var$PROGRESS_NAME = "Progress";
    $67824d98245208a0$var$DEFAULT_MAX = 100;
    [$67824d98245208a0$var$createProgressContext, $67824d98245208a0$export$388eb2d8f6d3261f] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($67824d98245208a0$var$PROGRESS_NAME);
    [$67824d98245208a0$var$ProgressProvider, $67824d98245208a0$var$useProgressContext] = $67824d98245208a0$var$createProgressContext($67824d98245208a0$var$PROGRESS_NAME);
    $67824d98245208a0$export$b25a304ec7d746bb = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeProgress, value: valueProp, max: maxProp, getValueLabel = $67824d98245208a0$var$defaultGetValueLabel, ...progressProps } = props;
      const max2 = $67824d98245208a0$var$isValidMaxNumber(maxProp) ? maxProp : $67824d98245208a0$var$DEFAULT_MAX;
      const value = $67824d98245208a0$var$isValidValueNumber(valueProp, max2) ? valueProp : null;
      const valueLabel = $67824d98245208a0$var$isNumber(value) ? getValueLabel(value, max2) : void 0;
      return /* @__PURE__ */ reactExports.createElement($67824d98245208a0$var$ProgressProvider, {
        scope: __scopeProgress,
        value,
        max: max2
      }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "aria-valuemax": max2,
        "aria-valuemin": 0,
        "aria-valuenow": $67824d98245208a0$var$isNumber(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": $67824d98245208a0$var$getProgressState(value, max2),
        "data-value": value !== null && value !== void 0 ? value : void 0,
        "data-max": max2
      }, progressProps, {
        ref: forwardedRef
      })));
    });
    $67824d98245208a0$export$b25a304ec7d746bb.propTypes = {
      max(props, propName, componentName) {
        const propValue = props[propName];
        const strVal = String(propValue);
        if (propValue && !$67824d98245208a0$var$isValidMaxNumber(propValue))
          return new Error($67824d98245208a0$var$getInvalidMaxError(strVal, componentName));
        return null;
      },
      value(props, propName, componentName) {
        const valueProp = props[propName];
        const strVal = String(valueProp);
        const max2 = $67824d98245208a0$var$isValidMaxNumber(props.max) ? props.max : $67824d98245208a0$var$DEFAULT_MAX;
        if (valueProp != null && !$67824d98245208a0$var$isValidValueNumber(valueProp, max2))
          return new Error($67824d98245208a0$var$getInvalidValueError(strVal, componentName));
        return null;
      }
    };
    $67824d98245208a0$var$INDICATOR_NAME = "ProgressIndicator";
    $67824d98245208a0$export$2b776f7e7ee60dbd = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      var _context$value;
      const { __scopeProgress, ...indicatorProps } = props;
      const context = $67824d98245208a0$var$useProgressContext($67824d98245208a0$var$INDICATOR_NAME, __scopeProgress);
      return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-state": $67824d98245208a0$var$getProgressState(context.value, context.max),
        "data-value": (_context$value = context.value) !== null && _context$value !== void 0 ? _context$value : void 0,
        "data-max": context.max
      }, indicatorProps, {
        ref: forwardedRef
      }));
    });
    $67824d98245208a0$export$be92b6f5f03c0fe9 = $67824d98245208a0$export$b25a304ec7d746bb;
    $67824d98245208a0$export$adb584737d712b70 = $67824d98245208a0$export$2b776f7e7ee60dbd;
    Progress = reactExports.forwardRef(({ className, value, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $67824d98245208a0$export$be92b6f5f03c0fe9,
      {
        ref,
        className: cn$1(
          "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          $67824d98245208a0$export$adb584737d712b70,
          {
            className: "h-full w-full flex-1 bg-primary transition-all",
            style: { transform: `translateX(-${100 - (value || 0)}%)` }
          }
        )
      }
    ));
    Progress.displayName = $67824d98245208a0$export$be92b6f5f03c0fe9.displayName;
    RedProgress = reactExports.forwardRef(({ className, value, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $67824d98245208a0$export$be92b6f5f03c0fe9,
      {
        ref,
        className: cn$1(
          "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          $67824d98245208a0$export$adb584737d712b70,
          {
            className: "h-full w-full flex-1 bg-red-400 transition-all",
            style: { transform: `translateX(-${100 - (value || 0)}%)` }
          }
        )
      }
    ));
    RedProgress.displayName = $67824d98245208a0$export$be92b6f5f03c0fe9.displayName;
    [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1("Tooltip", [
      $cf1ac5d9fe0e8206$export$722aac194ae923
    ]);
    $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
    $a093c7e1ec25a057$var$PROVIDER_NAME = "TooltipProvider";
    $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;
    $a093c7e1ec25a057$var$TOOLTIP_OPEN = "tooltip.open";
    [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);
    $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props) => {
      const { __scopeTooltip, delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;
      const [isOpenDelayed, setIsOpenDelayed] = reactExports.useState(true);
      const isPointerInTransitRef = reactExports.useRef(false);
      const skipDelayTimerRef = reactExports.useRef(0);
      reactExports.useEffect(() => {
        const skipDelayTimer = skipDelayTimerRef.current;
        return () => window.clearTimeout(skipDelayTimer);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipProviderContextProvider, {
        scope: __scopeTooltip,
        isOpenDelayed,
        delayDuration,
        onOpen: reactExports.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          setIsOpenDelayed(false);
        }, []),
        onClose: reactExports.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => setIsOpenDelayed(true),
            skipDelayDuration
          );
        }, [
          skipDelayDuration
        ]),
        isPointerInTransitRef,
        onPointerInTransitChange: reactExports.useCallback((inTransit) => {
          isPointerInTransitRef.current = inTransit;
        }, []),
        disableHoverableContent
      }, children);
    };
    $a093c7e1ec25a057$var$TOOLTIP_NAME = "Tooltip";
    [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);
    $a093c7e1ec25a057$export$28c660c63b792dea = (props) => {
      const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;
      const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);
      const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
      const [trigger, setTrigger] = reactExports.useState(null);
      const contentId = $1746a345f3d73bb7$export$f680877a34711e37();
      const openTimerRef = reactExports.useRef(0);
      const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;
      const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;
      const wasOpenDelayedRef = reactExports.useRef(false);
      const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: (open) => {
          if (open) {
            providerContext.onOpen();
            document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));
          } else
            providerContext.onClose();
          onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);
        }
      });
      const stateAttribute = reactExports.useMemo(() => {
        return open1 ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
      }, [
        open1
      ]);
      const handleOpen = reactExports.useCallback(() => {
        window.clearTimeout(openTimerRef.current);
        wasOpenDelayedRef.current = false;
        setOpen(true);
      }, [
        setOpen
      ]);
      const handleClose = reactExports.useCallback(() => {
        window.clearTimeout(openTimerRef.current);
        setOpen(false);
      }, [
        setOpen
      ]);
      const handleDelayedOpen = reactExports.useCallback(() => {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = window.setTimeout(() => {
          wasOpenDelayedRef.current = true;
          setOpen(true);
        }, delayDuration);
      }, [
        delayDuration,
        setOpen
      ]);
      reactExports.useEffect(() => {
        return () => window.clearTimeout(openTimerRef.current);
      }, []);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContextProvider, {
        scope: __scopeTooltip,
        contentId,
        open: open1,
        stateAttribute,
        trigger,
        onTriggerChange: setTrigger,
        onTriggerEnter: reactExports.useCallback(() => {
          if (providerContext.isOpenDelayed)
            handleDelayedOpen();
          else
            handleOpen();
        }, [
          providerContext.isOpenDelayed,
          handleDelayedOpen,
          handleOpen
        ]),
        onTriggerLeave: reactExports.useCallback(() => {
          if (disableHoverableContent)
            handleClose();
          else
            window.clearTimeout(openTimerRef.current);
        }, [
          handleClose,
          disableHoverableContent
        ]),
        onOpen: handleOpen,
        onClose: handleClose,
        disableHoverableContent
      }, children));
    };
    $a093c7e1ec25a057$var$TRIGGER_NAME = "TooltipTrigger";
    $a093c7e1ec25a057$export$8c610744efcf8a1d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTooltip, ...triggerProps } = props;
      const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
      const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
      const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);
      const isPointerDownRef = reactExports.useRef(false);
      const hasPointerMoveOpenedRef = reactExports.useRef(false);
      const handlePointerUp = reactExports.useCallback(
        () => isPointerDownRef.current = false,
        []
      );
      reactExports.useEffect(() => {
        return () => document.removeEventListener("pointerup", handlePointerUp);
      }, [
        handlePointerUp
      ]);
      return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
        asChild: true
      }, popperScope), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
        // We purposefully avoid adding `type=button` here because tooltip triggers are also
        // commonly anchors and the anchor `type` attribute signifies MIME type.
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute
      }, triggerProps, {
        ref: composedRefs,
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
          if (event.pointerType === "touch")
            return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, {
            once: true
          });
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
          if (!isPointerDownRef.current)
            context.onOpen();
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onClose)
      })));
    });
    $a093c7e1ec25a057$var$PORTAL_NAME = "TooltipPortal";
    [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {
      forceMount: void 0
    });
    $a093c7e1ec25a057$var$CONTENT_NAME = "TooltipContent";
    $a093c7e1ec25a057$export$e9003e2be37ec060 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
      const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
      const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
      return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, context.disableHoverableContent ? /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends({
        side
      }, contentProps, {
        ref: forwardedRef
      })) : /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentHoverable, _extends({
        side
      }, contentProps, {
        ref: forwardedRef
      })));
    });
    $a093c7e1ec25a057$var$TooltipContentHoverable = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
      const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
      const ref = reactExports.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
      const { trigger, onClose } = context;
      const content = ref.current;
      const { onPointerInTransitChange } = providerContext;
      const handleRemoveGraceArea = reactExports.useCallback(() => {
        setPointerGraceArea(null);
        onPointerInTransitChange(false);
      }, [
        onPointerInTransitChange
      ]);
      const handleCreateGraceArea = reactExports.useCallback((event, hoverTarget) => {
        const currentTarget = event.currentTarget;
        const exitPoint = {
          x: event.clientX,
          y: event.clientY
        };
        const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
        const paddedExitPoints = $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide);
        const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());
        const graceArea = $a093c7e1ec25a057$var$getHull([
          ...paddedExitPoints,
          ...hoverTargetPoints
        ]);
        setPointerGraceArea(graceArea);
        onPointerInTransitChange(true);
      }, [
        onPointerInTransitChange
      ]);
      reactExports.useEffect(() => {
        return () => handleRemoveGraceArea();
      }, [
        handleRemoveGraceArea
      ]);
      reactExports.useEffect(() => {
        if (trigger && content) {
          const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
          const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
          trigger.addEventListener("pointerleave", handleTriggerLeave);
          content.addEventListener("pointerleave", handleContentLeave);
          return () => {
            trigger.removeEventListener("pointerleave", handleTriggerLeave);
            content.removeEventListener("pointerleave", handleContentLeave);
          };
        }
      }, [
        trigger,
        content,
        handleCreateGraceArea,
        handleRemoveGraceArea
      ]);
      reactExports.useEffect(() => {
        if (pointerGraceArea) {
          const handleTrackPointerGrace = (event) => {
            const target = event.target;
            const pointerPosition = {
              x: event.clientX,
              y: event.clientY
            };
            const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));
            const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);
            if (hasEnteredTarget)
              handleRemoveGraceArea();
            else if (isPointerOutsideGraceArea) {
              handleRemoveGraceArea();
              onClose();
            }
          };
          document.addEventListener("pointermove", handleTrackPointerGrace);
          return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
        }
      }, [
        trigger,
        content,
        pointerGraceArea,
        onClose,
        handleRemoveGraceArea
      ]);
      return /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends({}, props, {
        ref: composedRefs
      }));
    });
    [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {
      isInside: false
    });
    $a093c7e1ec25a057$var$TooltipContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
      const { __scopeTooltip, children, "aria-label": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;
      const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);
      const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
      const { onClose } = context;
      reactExports.useEffect(() => {
        document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
        return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
      }, [
        onClose
      ]);
      reactExports.useEffect(() => {
        if (context.trigger) {
          const handleScroll2 = (event) => {
            const target = event.target;
            if (target !== null && target !== void 0 && target.contains(context.trigger))
              onClose();
          };
          window.addEventListener("scroll", handleScroll2, {
            capture: true
          });
          return () => window.removeEventListener("scroll", handleScroll2, {
            capture: true
          });
        }
      }, [
        context.trigger,
        onClose
      ]);
      return /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose
      }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
        "data-state": context.stateAttribute
      }, popperScope, contentProps, {
        ref: forwardedRef,
        style: {
          ...contentProps.style,
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }), /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {
        scope: __scopeTooltip,
        isInside: true
      }, /* @__PURE__ */ reactExports.createElement($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {
        id: context.contentId,
        role: "tooltip"
      }, ariaLabel || children))));
    });
    $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;
    $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;
    $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;
    $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;
    TooltipProvider = $a093c7e1ec25a057$export$2881499e37b75b9a;
    Tooltip = $a093c7e1ec25a057$export$be92b6f5f03c0fe9;
    TooltipTrigger = $a093c7e1ec25a057$export$41fb9f06171c75f4;
    TooltipContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      $a093c7e1ec25a057$export$7c6e2c02157bb7d2,
      {
        ref,
        sideOffset,
        className: cn$1(
          "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        ),
        ...props
      }
    ));
    TooltipContent.displayName = $a093c7e1ec25a057$export$7c6e2c02157bb7d2.displayName;
    VideoRecorder = reactExports.forwardRef(
      ({
        status,
        progress,
        formattedTime,
        onStart,
        onStop,
        onPause,
        onResume
      }, ref) => {
        return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(AspectRatio, { className: "relative overflow-hidden", ratio: 16 / 9, children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("video", { className: "w-full rounded-md", ref }),
          (status === "RECORDING" || status === "PAUSED") && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center justify-center gap-2 absolute top-1 left-0 right-0", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(RedProgress, { value: progress, className: "h-1 max-w-[50%]" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center justify-between p-1 bg-slate-800/50 w-[60px] rounded-full", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "text-xs text-white", children: formattedTime }),
              status === "PAUSED" && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Pause, { className: "w-3.5 h-3.5 text-red-400" }),
              status === "RECORDING" && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-3 h-3 rounded-full bg-red-400" })
            ] })
          ] }),
          status === "INITIAL" || status === "OPEN" && /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Button$1,
              {
                size: "icon",
                variant: "outline",
                type: "button",
                className: "border-none bg-gray-800/20 hover:bg-gray-800/80 rounded-full absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2",
                onClick: async (e2) => {
                  await onStart();
                },
                children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-3 h-3 rounded-full bg-red-600 " })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipContent, { children: "Comenzar grabaci\xF3n" })
          ] }) }),
          status === "RECORDING" && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "absolute bottom-2 bg-transparent transform left-1/2 -translate-x-1/2 space-x-2 ", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                Button$1,
                {
                  size: "icon",
                  variant: "outline",
                  type: "button",
                  className: "rounded-full border-none bg-gray-800/20 hover:bg-gray-800/80 group",
                  onClick: async (e2) => {
                    await onPause();
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Pause, { className: "w-3.5 h-3.5 text-gray-200 group-hover:text-white" })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipContent, { children: "Pausar grabaci\xF3n" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                Button$1,
                {
                  size: "icon",
                  variant: "outline",
                  type: "button",
                  className: "rounded-full border-none bg-gray-800/20 hover:bg-gray-800/80 group",
                  onClick: async (e2) => {
                    await onStop();
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Square, { className: "w-3.5 h-3.5 text-gray-200 group-hover:text-white" })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipContent, { children: "Finalizar grabaci\xF3n" })
            ] }) })
          ] }),
          status === "PAUSED" && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "absolute bottom-2 bg-transparent transform left-1/2 -translate-x-1/2 space-x-2 ", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                Button$1,
                {
                  size: "icon",
                  variant: "outline",
                  type: "button",
                  className: "border-none rounded-full bg-gray-800/20 hover:bg-gray-800/80 group",
                  onClick: async (e2) => {
                    await onResume();
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SwitchCamera, { className: "w-3.5 h-3.5 text-gray-200 group-hover:text-white" })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipContent, { children: "Reanudar grabaci\xF3n" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
                Button$1,
                {
                  size: "icon",
                  variant: "outline",
                  type: "button",
                  className: "rounded-full border-none bg-gray-800/20 hover:bg-gray-800/80 group",
                  onClick: async (e2) => {
                    await onStop();
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Square, { className: "w-3.5 h-3.5 text-gray-200 group-hover:text-white" })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(TooltipContent, { children: "Finalizar grabaci\xF3n" })
            ] }) })
          ] })
        ] });
      }
    );
    VideoPreview = reactExports.forwardRef(
      ({ onAddToForm, onNewRecording }, ref) => {
        return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(AspectRatio, { ratio: 16 / 9, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("video", { className: "w-full rounded-md", ref, controls: true }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex justify-center items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              Button$1,
              {
                size: "sm",
                variant: "outline",
                type: "button",
                onClick: async (e2) => {
                  onAddToForm();
                },
                children: [
                  "Guardar",
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(Download, { className: "ml-2 w-3.5 h-3.5" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
              Button$1,
              {
                size: "sm",
                variant: "secondary",
                type: "button",
                onClick: async (e2) => {
                  onNewRecording();
                },
                children: [
                  "Nueva",
                  /* @__PURE__ */ jsxRuntimeExports$1.jsx(Plus, { className: "ml-2 w-3.5 h-3.5" })
                ]
              }
            )
          ] })
        ] });
      }
    );
    pdfSchema = z.any();
    videoSchema = z.any().optional();
    formSchema = z.object({
      name: nameSchema,
      email: emailSchema,
      place: placeSchema,
      position: positionSchema,
      pdf: pdfSchema,
      video: videoSchema
    });
    MAX_FILES = 2;
    $$Astro3 = createAstro();
    $$Index = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro3, $$props, $$slots);
      Astro2.self = $$Index;
      return renderTemplate`${renderComponent($$result, "BaseLayout", $$Base, { "title": "Diaz Cadenas - Trabaja con nosotros", "classNames": "min-h-screen grid place-items-center" }, { "default": ($$result2) => renderTemplate` ${renderComponent($$result2, "CVFormIsland", CVFormIsland, { "client:load": true, "client:component-hydration": "load", "client:component-path": "@/components/cv-form/form.island", "client:component-export": "default" })} ` })}`;
    }, "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/index.astro", void 0);
    $$file2 = "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/index.astro";
    $$url2 = "";
  }
});

// .wrangler/tmp/pages-KkpaTB/chunks/index_Bmb7h_Ya.mjs
var index_Bmb7h_Ya_exports = {};
__export(index_Bmb7h_Ya_exports, {
  page: () => page5,
  renderers: () => renderers
});
var page5;
var init_index_Bmb7h_Ya = __esm({
  async ".wrangler/tmp/pages-KkpaTB/chunks/index_Bmb7h_Ya.mjs"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    await init_renderers();
    globalThis.process ??= {};
    globalThis.process.env ??= {};
    page5 = () => init_index_TRNjimg9().then(() => index_TRNjimg9_exports);
  }
});

// .wrangler/tmp/bundle-1HjA2m/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-1HjA2m/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/pages-KkpaTB/6l909w2no6.js
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/pages-KkpaTB/bundledWorker-0.23128614273024284.mjs
init_checked_fetch();
init_modules_watch_stub();
await init_renderers();

// .wrangler/tmp/pages-KkpaTB/manifest_cEa7mJNr.mjs
init_checked_fetch();
init_modules_watch_stub();
init_astro_BO0wYrHs();
globalThis.process ??= {};
globalThis.process.env ??= {};
var dateTimeFormat = new Intl.DateTimeFormat([], {
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  hour12: false
});
var levels = {
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  silent: 90
};
function log(opts2, level, label, message2, newLine = true) {
  const logLevel = opts2.level;
  const dest = opts2.dest;
  const event = {
    label,
    level,
    message: message2,
    newLine
  };
  if (!isLogLevelEnabled(logLevel, level)) {
    return;
  }
  dest.write(event);
}
function isLogLevelEnabled(configuredLogLevel, level) {
  return levels[configuredLogLevel] <= levels[level];
}
function info(opts2, label, message2, newLine = true) {
  return log(opts2, "info", label, message2, newLine);
}
function warn(opts2, label, message2, newLine = true) {
  return log(opts2, "warn", label, message2, newLine);
}
function error(opts2, label, message2, newLine = true) {
  return log(opts2, "error", label, message2, newLine);
}
function debug2(...args) {
  if ("_astroGlobalDebug" in globalThis) {
    globalThis._astroGlobalDebug(...args);
  }
}
function getEventPrefix({ level, label }) {
  const timestamp = `${dateTimeFormat.format(/* @__PURE__ */ new Date())}`;
  const prefix = [];
  if (level === "error" || level === "warn") {
    prefix.push(bold(timestamp));
    prefix.push(`[${level.toUpperCase()}]`);
  } else {
    prefix.push(timestamp);
  }
  if (label) {
    prefix.push(`[${label}]`);
  }
  if (level === "error") {
    return red(prefix.join(" "));
  }
  if (level === "warn") {
    return yellow(prefix.join(" "));
  }
  if (prefix.length === 1) {
    return dim(prefix[0]);
  }
  return dim(prefix[0]) + " " + blue(prefix.splice(1).join(" "));
}
if (typeof process !== "undefined") {
  let proc = process;
  if ("argv" in proc && Array.isArray(proc.argv)) {
    if (proc.argv.includes("--verbose"))
      ;
    else if (proc.argv.includes("--silent"))
      ;
    else
      ;
  }
}
var Logger = class {
  options;
  constructor(options) {
    this.options = options;
  }
  info(label, message2, newLine = true) {
    info(this.options, label, message2, newLine);
  }
  warn(label, message2, newLine = true) {
    warn(this.options, label, message2, newLine);
  }
  error(label, message2, newLine = true) {
    error(this.options, label, message2, newLine);
  }
  debug(label, ...messages) {
    debug2(label, ...messages);
  }
  level() {
    return this.options.level;
  }
  forkIntegrationLogger(label) {
    return new AstroIntegrationLogger(this.options, label);
  }
};
var AstroIntegrationLogger = class {
  options;
  label;
  constructor(logging, label) {
    this.options = logging;
    this.label = label;
  }
  /**
   * Creates a new logger instance with a new label, but the same log options.
   */
  fork(label) {
    return new AstroIntegrationLogger(this.options, label);
  }
  info(message2) {
    info(this.options, this.label, message2);
  }
  warn(message2) {
    warn(this.options, this.label, message2);
  }
  error(message2) {
    error(this.options, this.label, message2);
  }
  debug(message2) {
    debug2(this.label, message2);
  }
};
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j3 = i2 + 1;
      while (j3 < str.length) {
        var code = str.charCodeAt(j3);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j3++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j3;
      continue;
    }
    if (char === "(") {
      var count3 = 1;
      var pattern = "";
      var j3 = i2 + 1;
      if (str[j3] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j3));
      }
      while (j3 < str.length) {
        if (str[j3] === "\\") {
          pattern += str[j3++] + str[j3++];
          continue;
        }
        if (str[j3] === ")") {
          count3--;
          if (count3 === 0) {
            j3++;
            break;
          }
        } else if (str[j3] === "(") {
          count3++;
          if (str[j3 + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j3));
          }
        }
        pattern += str[j3++];
      }
      if (count3)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j3;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse2(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a78 = options.prefixes, prefixes = _a78 === void 0 ? "./" : _a78;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a79 = tokens[i2], nextType = _a79.type, index3 = _a79.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index3, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse2(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a78 = options.encode, encode2 = _a78 === void 0 ? function(x4) {
    return x4;
  } : _a78, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
    }
  });
  return function(data) {
    var path = "";
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data ? data[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value)) {
        if (!repeat) {
          throw new TypeError('Expected "'.concat(token.name, '" to not repeat, but got an array'));
        }
        if (value.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "'.concat(token.name, '" to not be empty'));
        }
        for (var j3 = 0; j3 < value.length; j3++) {
          var segment = encode2(value[j3], token);
          if (validate && !matches[i2].test(segment)) {
            throw new TypeError('Expected all "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
          }
          path += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value === "string" || typeof value === "number") {
        var segment = encode2(String(value), token);
        if (validate && !matches[i2].test(segment)) {
          throw new TypeError('Expected "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
        }
        path += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "'.concat(token.name, '" to be ').concat(typeOfMessage));
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function getRouteGenerator(segments, addTrailingSlash) {
  const template = segments.map((segment) => {
    return "/" + segment.map((part) => {
      if (part.spread) {
        return `:${part.content.slice(3)}(.*)?`;
      } else if (part.dynamic) {
        return `:${part.content}`;
      } else {
        return part.content.normalize().replace(/\?/g, "%3F").replace(/#/g, "%23").replace(/%5B/g, "[").replace(/%5D/g, "]").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    }).join("");
  }).join("");
  let trailing = "";
  if (addTrailingSlash === "always" && segments.length) {
    trailing = "/";
  }
  const toPath = compile(template + trailing);
  return (params) => {
    const path = toPath(params);
    return path || "/";
  };
}
function deserializeRouteData(rawRouteData) {
  return {
    route: rawRouteData.route,
    type: rawRouteData.type,
    pattern: new RegExp(rawRouteData.pattern),
    params: rawRouteData.params,
    component: rawRouteData.component,
    generate: getRouteGenerator(rawRouteData.segments, rawRouteData._meta.trailingSlash),
    pathname: rawRouteData.pathname || void 0,
    segments: rawRouteData.segments,
    prerender: rawRouteData.prerender,
    redirect: rawRouteData.redirect,
    redirectRoute: rawRouteData.redirectRoute ? deserializeRouteData(rawRouteData.redirectRoute) : void 0,
    fallbackRoutes: rawRouteData.fallbackRoutes.map((fallback) => {
      return deserializeRouteData(fallback);
    }),
    isIndex: rawRouteData.isIndex
  };
}
function deserializeManifest(serializedManifest) {
  const routes2 = [];
  for (const serializedRoute of serializedManifest.routes) {
    routes2.push({
      ...serializedRoute,
      routeData: deserializeRouteData(serializedRoute.routeData)
    });
    const route = serializedRoute;
    route.routeData = deserializeRouteData(serializedRoute.routeData);
  }
  const assets = new Set(serializedManifest.assets);
  const componentMetadata = new Map(serializedManifest.componentMetadata);
  const inlinedScripts = new Map(serializedManifest.inlinedScripts);
  const clientDirectives = new Map(serializedManifest.clientDirectives);
  return {
    // in case user middleware exists, this no-op middleware will be reassigned (see plugin-ssr.ts)
    middleware(_3, next) {
      return next();
    },
    ...serializedManifest,
    assets,
    componentMetadata,
    inlinedScripts,
    clientDirectives,
    routes: routes2
  };
}
var manifest = deserializeManifest({ "adapterName": "@astrojs/cloudflare", "routes": [{ "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "type": "endpoint", "isIndex": false, "route": "/_image", "pattern": "^\\/_image$", "segments": [[{ "content": "_image", "dynamic": false, "spread": false }]], "params": [], "component": "node_modules/astro/dist/assets/endpoint/generic.js", "pathname": "/_image", "prerender": false, "fallbackRoutes": [], "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/trpc/[trpc]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/trpc\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "trpc", "dynamic": false, "spread": false }], [{ "content": "trpc", "dynamic": true, "spread": false }]], "params": ["trpc"], "component": "src/pages/api/trpc/[trpc].ts", "prerender": false, "fallbackRoutes": [], "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/uploadthing", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/uploadthing\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "uploadthing", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/uploadthing.ts", "pathname": "/api/uploadthing", "prerender": false, "fallbackRoutes": [], "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/cvs.scW-0QiN.css" }], "routeData": { "route": "/cvs", "isIndex": false, "type": "page", "pattern": "^\\/cvs\\/?$", "segments": [[{ "content": "cvs", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/cvs.astro", "pathname": "/cvs", "prerender": false, "fallbackRoutes": [], "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/cvs.scW-0QiN.css" }], "routeData": { "route": "/", "isIndex": true, "type": "page", "pattern": "^\\/$", "segments": [], "params": [], "component": "src/pages/index.astro", "pathname": "/", "prerender": false, "fallbackRoutes": [], "_meta": { "trailingSlash": "ignore" } } }], "base": "/", "trailingSlash": "ignore", "compressHTML": true, "componentMetadata": [["/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/cvs.astro", { "propagation": "none", "containsHead": true }], ["/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/src/pages/index.astro", { "propagation": "none", "containsHead": true }]], "renderers": [], "clientDirectives": [["idle", '(()=>{var i=t=>{let e=async()=>{await(await t())()};"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)};(self.Astro||(self.Astro={})).idle=i;window.dispatchEvent(new Event("astro:idle"));})();'], ["load", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();'], ["media", '(()=>{var s=(i,t)=>{let a=async()=>{await(await i())()};if(t.value){let e=matchMedia(t.value);e.matches?a():e.addEventListener("change",a,{once:!0})}};(self.Astro||(self.Astro={})).media=s;window.dispatchEvent(new Event("astro:media"));})();'], ["only", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();'], ["visible", '(()=>{var l=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let a of e)if(a.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=l;window.dispatchEvent(new Event("astro:visible"));})();']], "entryModules": { "\0@astrojs-ssr-virtual-entry": "index.js", "\0@astro-renderers": "renderers.mjs", "\0noop-middleware": "_noop-middleware.mjs", "/node_modules/astro/dist/assets/endpoint/generic.js": "chunks/pages/generic_Dk8lQKaX.mjs", "/src/pages/index.astro": "chunks/pages/index_TRNjimg9.mjs", "/src/pages/api/uploadthing.ts": "chunks/pages/uploadthing_B1mybNP8.mjs", "\0@astrojs-manifest": "manifest_cEa7mJNr.mjs", "/Users/manuel/Desktop/juanma/diaz-cadenas-cvs/node_modules/@astrojs/react/vnode-children.js": "chunks/vnode-children_Gh7ykD0n.mjs", "\0@astro-page:node_modules/astro/dist/assets/endpoint/generic@_@js": "chunks/generic_DuQmGclJ.mjs", "\0@astro-page:src/pages/api/trpc/[trpc]@_@ts": "chunks/_trpc__LU1rZ36Q.mjs", "\0@astro-page:src/pages/api/uploadthing@_@ts": "chunks/uploadthing_ByMMhEFg.mjs", "\0@astro-page:src/pages/cvs@_@astro": "chunks/cvs_Dmiwg382.mjs", "\0@astro-page:src/pages/index@_@astro": "chunks/index_Bmb7h_Ya.mjs", "@astrojs/react/client.js": "_astro/client.YizQUA8j.js", "@/components/cv-form/form.island": "_astro/form.DV2jZ0jy.js", "@/components/cv-table/table.island": "_astro/table.B7mfsUDN.js", "astro:scripts/before-hydration.js": "" }, "inlinedScripts": [], "assets": ["/_astro/cvs.scW-0QiN.css", "/favicon.svg", "/_worker.js/_noop-middleware.mjs", "/_worker.js/index.js", "/_worker.js/renderers.mjs", "/_astro/client.YizQUA8j.js", "/_astro/form.DV2jZ0jy.js", "/_astro/index.CROWQEy9.js", "/_astro/select.Cs0hN4GJ.js", "/_astro/table.B7mfsUDN.js", "/_worker.js/_astro/cvs.scW-0QiN.css", "/_worker.js/chunks/_trpc__LU1rZ36Q.mjs", "/_worker.js/chunks/astro_BO0wYrHs.mjs", "/_worker.js/chunks/cvs_Dmiwg382.mjs", "/_worker.js/chunks/generic_DuQmGclJ.mjs", "/_worker.js/chunks/index_Bmb7h_Ya.mjs", "/_worker.js/chunks/uploadthing_ByMMhEFg.mjs", "/_worker.js/chunks/vnode-children_Gh7ykD0n.mjs", "/_worker.js/chunks/astro/assets-service_i7oLR0nI.mjs", "/_worker.js/chunks/pages/_trpc__GIzfMcGy.mjs", "/_worker.js/chunks/pages/cvs_qudRXU8T.mjs", "/_worker.js/chunks/pages/generic_Dk8lQKaX.mjs", "/_worker.js/chunks/pages/index_TRNjimg9.mjs", "/_worker.js/chunks/pages/uploadthing_B1mybNP8.mjs"], "buildFormat": "directory", "checkOrigin": false });

// .wrangler/tmp/pages-KkpaTB/bundledWorker-0.23128614273024284.mjs
init_assets_service_i7oLR0nI();
init_astro_BO0wYrHs();

// .wrangler/tmp/pages-KkpaTB/_noop-middleware.mjs
init_checked_fetch();
init_modules_watch_stub();
globalThis.process ??= {};
globalThis.process.env ??= {};
var onRequest = (_3, next) => next();

// .wrangler/tmp/pages-KkpaTB/bundledWorker-0.23128614273024284.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
globalThis.process ??= {};
globalThis.process.env ??= {};
function shouldAppendForwardSlash(trailingSlash, buildFormat) {
  switch (trailingSlash) {
    case "always":
      return true;
    case "never":
      return false;
    case "ignore": {
      switch (buildFormat) {
        case "directory":
          return true;
        case "preserve":
        case "file":
          return false;
      }
    }
  }
}
function createI18nMiddleware(i18n, base, trailingSlash, format2) {
  if (!i18n)
    return (_3, next) => next();
  const payload = {
    ...i18n,
    trailingSlash,
    base,
    format: format2,
    domains: {}
  };
  const _redirectToDefaultLocale = redirectToDefaultLocale(payload);
  const _noFoundForNonLocaleRoute = notFound(payload);
  const _requestHasLocale = requestHasLocale(payload.locales);
  const _redirectToFallback = redirectToFallback(payload);
  const prefixAlways = (context) => {
    const url = context.url;
    if (url.pathname === base + "/" || url.pathname === base) {
      return _redirectToDefaultLocale(context);
    } else if (!_requestHasLocale(context)) {
      return _noFoundForNonLocaleRoute(context);
    }
    return void 0;
  };
  const prefixOtherLocales = (context, response) => {
    let pathnameContainsDefaultLocale = false;
    const url = context.url;
    for (const segment of url.pathname.split("/")) {
      if (normalizeTheLocale(segment) === normalizeTheLocale(i18n.defaultLocale)) {
        pathnameContainsDefaultLocale = true;
        break;
      }
    }
    if (pathnameContainsDefaultLocale) {
      const newLocation = url.pathname.replace(`/${i18n.defaultLocale}`, "");
      response.headers.set("Location", newLocation);
      return _noFoundForNonLocaleRoute(context);
    }
    return void 0;
  };
  return async (context, next) => {
    const response = await next();
    const type = response.headers.get(ROUTE_TYPE_HEADER);
    if (type !== "page" && type !== "fallback") {
      return response;
    }
    const { currentLocale } = context;
    switch (i18n.strategy) {
      case "manual": {
        return response;
      }
      case "domains-prefix-other-locales": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = prefixOtherLocales(context, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-other-locales": {
        const result = prefixOtherLocales(context, response);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always-no-redirect": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = _noFoundForNonLocaleRoute(context, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-always-no-redirect": {
        const result = _noFoundForNonLocaleRoute(context, response);
        if (result) {
          return result;
        }
        break;
      }
      case "pathname-prefix-always": {
        const result = prefixAlways(context);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = prefixAlways(context);
          if (result) {
            return result;
          }
        }
        break;
      }
    }
    return _redirectToFallback(context, response);
  };
}
function localeHasntDomain(i18n, currentLocale) {
  for (const domainLocale of Object.values(i18n.domainLookupTable)) {
    if (domainLocale === currentLocale) {
      return false;
    }
  }
  return true;
}
function requestHasLocale(locales) {
  return function(context) {
    return pathHasLocale(context.url.pathname, locales);
  };
}
function pathHasLocale(path, locales) {
  const segments = path.split("/");
  for (const segment of segments) {
    for (const locale of locales) {
      if (typeof locale === "string") {
        if (normalizeTheLocale(segment) === normalizeTheLocale(locale)) {
          return true;
        }
      } else if (segment === locale.path) {
        return true;
      }
    }
  }
  return false;
}
function getPathByLocale(locale, locales) {
  for (const loopLocale of locales) {
    if (typeof loopLocale === "string") {
      if (loopLocale === locale) {
        return loopLocale;
      }
    } else {
      for (const code of loopLocale.codes) {
        if (code === locale) {
          return loopLocale.path;
        }
      }
    }
  }
  throw new Unreachable();
}
function normalizeTheLocale(locale) {
  return locale.replaceAll("_", "-").toLowerCase();
}
function toCodes(locales) {
  return locales.map((loopLocale) => {
    if (typeof loopLocale === "string") {
      return loopLocale;
    } else {
      return loopLocale.codes[0];
    }
  });
}
var Unreachable = class extends Error {
  constructor() {
    super(
      "Astro encountered an unexpected line of code.\nIn most cases, this is not your fault, but a bug in astro code.\nIf there isn't one already, please create an issue.\nhttps://astro.build/issues"
    );
  }
};
function redirectToDefaultLocale({
  trailingSlash,
  format: format2,
  base,
  defaultLocale
}) {
  return function(context, statusCode) {
    if (shouldAppendForwardSlash(trailingSlash, format2)) {
      return context.redirect(`${appendForwardSlash(joinPaths(base, defaultLocale))}`, statusCode);
    } else {
      return context.redirect(`${joinPaths(base, defaultLocale)}`, statusCode);
    }
  };
}
function notFound({ base, locales }) {
  return function(context, response) {
    if (response?.headers.get(REROUTE_DIRECTIVE_HEADER) === "no")
      return response;
    const url = context.url;
    const isRoot = url.pathname === base + "/" || url.pathname === base;
    if (!(isRoot || pathHasLocale(url.pathname, locales))) {
      if (response) {
        response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
        return new Response(null, {
          status: 404,
          headers: response.headers
        });
      } else {
        return new Response(null, {
          status: 404,
          headers: {
            [REROUTE_DIRECTIVE_HEADER]: "no"
          }
        });
      }
    }
    return void 0;
  };
}
function redirectToFallback({
  fallback,
  locales,
  defaultLocale,
  strategy
}) {
  return function(context, response) {
    if (response.status >= 300 && fallback) {
      const fallbackKeys = fallback ? Object.keys(fallback) : [];
      const segments = context.url.pathname.split("/");
      const urlLocale = segments.find((segment) => {
        for (const locale of locales) {
          if (typeof locale === "string") {
            if (locale === segment) {
              return true;
            }
          } else if (locale.path === segment) {
            return true;
          }
        }
        return false;
      });
      if (urlLocale && fallbackKeys.includes(urlLocale)) {
        const fallbackLocale = fallback[urlLocale];
        const pathFallbackLocale = getPathByLocale(fallbackLocale, locales);
        let newPathname;
        if (pathFallbackLocale === defaultLocale && strategy === "pathname-prefix-other-locales") {
          newPathname = context.url.pathname.replace(`/${urlLocale}`, ``);
        } else {
          newPathname = context.url.pathname.replace(`/${urlLocale}`, `/${pathFallbackLocale}`);
        }
        return context.redirect(newPathname);
      }
    }
    return response;
  };
}
var parse_1 = parse3;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse3(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode;
  var index3 = 0;
  while (index3 < str.length) {
    var eqIdx = str.indexOf("=", index3);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index3);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index3 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index3, eqIdx).trim();
    if (void 0 === obj[key]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index3 = endIdx + 1;
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate2(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate2(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e2) {
    return str;
  }
}
var DELETED_EXPIRATION = /* @__PURE__ */ new Date(0);
var DELETED_VALUE = "deleted";
var responseSentSymbol2 = Symbol.for("astro.responseSent");
var AstroCookie = class {
  constructor(value) {
    this.value = value;
  }
  json() {
    if (this.value === void 0) {
      throw new Error(`Cannot convert undefined to an object.`);
    }
    return JSON.parse(this.value);
  }
  number() {
    return Number(this.value);
  }
  boolean() {
    if (this.value === "false")
      return false;
    if (this.value === "0")
      return false;
    return Boolean(this.value);
  }
};
var AstroCookies = class {
  #request;
  #requestValues;
  #outgoing;
  #consumed;
  constructor(request) {
    this.#request = request;
    this.#requestValues = null;
    this.#outgoing = null;
    this.#consumed = false;
  }
  /**
   * Astro.cookies.delete(key) is used to delete a cookie. Using this method will result
   * in a Set-Cookie header added to the response.
   * @param key The cookie to delete
   * @param options Options related to this deletion, such as the path of the cookie.
   */
  delete(key, options) {
    const {
      // @ts-expect-error
      maxAge: _ignoredMaxAge,
      // @ts-expect-error
      expires: _ignoredExpires,
      ...sanitizedOptions
    } = options || {};
    const serializeOptions = {
      expires: DELETED_EXPIRATION,
      ...sanitizedOptions
    };
    this.#ensureOutgoingMap().set(key, [
      DELETED_VALUE,
      serialize_1(key, DELETED_VALUE, serializeOptions),
      false
    ]);
  }
  /**
   * Astro.cookies.get(key) is used to get a cookie value. The cookie value is read from the
   * request. If you have set a cookie via Astro.cookies.set(key, value), the value will be taken
   * from that set call, overriding any values already part of the request.
   * @param key The cookie to get.
   * @returns An object containing the cookie value as well as convenience methods for converting its value.
   */
  get(key, options = void 0) {
    if (this.#outgoing?.has(key)) {
      let [serializedValue, , isSetValue] = this.#outgoing.get(key);
      if (isSetValue) {
        return new AstroCookie(serializedValue);
      } else {
        return void 0;
      }
    }
    const values = this.#ensureParsed(options);
    if (key in values) {
      const value = values[key];
      return new AstroCookie(value);
    }
  }
  /**
   * Astro.cookies.has(key) returns a boolean indicating whether this cookie is either
   * part of the initial request or set via Astro.cookies.set(key)
   * @param key The cookie to check for.
   * @returns
   */
  has(key, options = void 0) {
    if (this.#outgoing?.has(key)) {
      let [, , isSetValue] = this.#outgoing.get(key);
      return isSetValue;
    }
    const values = this.#ensureParsed(options);
    return !!values[key];
  }
  /**
   * Astro.cookies.set(key, value) is used to set a cookie's value. If provided
   * an object it will be stringified via JSON.stringify(value). Additionally you
   * can provide options customizing how this cookie will be set, such as setting httpOnly
   * in order to prevent the cookie from being read in client-side JavaScript.
   * @param key The name of the cookie to set.
   * @param value A value, either a string or other primitive or an object.
   * @param options Options for the cookie, such as the path and security settings.
   */
  set(key, value, options) {
    if (this.#consumed) {
      const warning = new Error(
        "Astro.cookies.set() was called after the cookies had already been sent to the browser.\nThis may have happened if this method was called in an imported component.\nPlease make sure that Astro.cookies.set() is only called in the frontmatter of the main page."
      );
      warning.name = "Warning";
      console.warn(warning);
    }
    let serializedValue;
    if (typeof value === "string") {
      serializedValue = value;
    } else {
      let toStringValue = value.toString();
      if (toStringValue === Object.prototype.toString.call(value)) {
        serializedValue = JSON.stringify(value);
      } else {
        serializedValue = toStringValue;
      }
    }
    const serializeOptions = {};
    if (options) {
      Object.assign(serializeOptions, options);
    }
    this.#ensureOutgoingMap().set(key, [
      serializedValue,
      serialize_1(key, serializedValue, serializeOptions),
      true
    ]);
    if (this.#request[responseSentSymbol2]) {
      throw new AstroError({
        ...ResponseSentError
      });
    }
  }
  /**
   * Astro.cookies.header() returns an iterator for the cookies that have previously
   * been set by either Astro.cookies.set() or Astro.cookies.delete().
   * This method is primarily used by adapters to set the header on outgoing responses.
   * @returns
   */
  *headers() {
    if (this.#outgoing == null)
      return;
    for (const [, value] of this.#outgoing) {
      yield value[1];
    }
  }
  /**
   * Behaves the same as AstroCookies.prototype.headers(),
   * but allows a warning when cookies are set after the instance is consumed.
   */
  static consume(cookies) {
    cookies.#consumed = true;
    return cookies.headers();
  }
  #ensureParsed(options = void 0) {
    if (!this.#requestValues) {
      this.#parse(options);
    }
    if (!this.#requestValues) {
      this.#requestValues = {};
    }
    return this.#requestValues;
  }
  #ensureOutgoingMap() {
    if (!this.#outgoing) {
      this.#outgoing = /* @__PURE__ */ new Map();
    }
    return this.#outgoing;
  }
  #parse(options = void 0) {
    const raw = this.#request.headers.get("cookie");
    if (!raw) {
      return;
    }
    this.#requestValues = parse_1(raw, options);
  }
};
var astroCookiesSymbol = Symbol.for("astro.cookies");
function attachCookiesToResponse(response, cookies) {
  Reflect.set(response, astroCookiesSymbol, cookies);
}
function getFromResponse(response) {
  let cookies = Reflect.get(response, astroCookiesSymbol);
  if (cookies != null) {
    return cookies;
  } else {
    return void 0;
  }
}
function* getSetCookiesFromResponse(response) {
  const cookies = getFromResponse(response);
  if (!cookies) {
    return [];
  }
  for (const headerValue of AstroCookies.consume(cookies)) {
    yield headerValue;
  }
  return [];
}
var consoleLogDestination = {
  write(event) {
    let dest = console.error;
    if (levels[event.level] < levels["error"]) {
      dest = console.log;
    }
    if (event.label === "SKIP_FORMAT") {
      dest(event.message);
    } else {
      dest(getEventPrefix(event) + " " + event.message);
    }
    return true;
  }
};
function parseLocale(header) {
  if (header === "*") {
    return [{ locale: header, qualityValue: void 0 }];
  }
  const result = [];
  const localeValues = header.split(",").map((str) => str.trim());
  for (const localeValue of localeValues) {
    const split = localeValue.split(";").map((str) => str.trim());
    const localeName = split[0];
    const qualityValue = split[1];
    if (!split) {
      continue;
    }
    if (qualityValue && qualityValue.startsWith("q=")) {
      const qualityValueAsFloat = Number.parseFloat(qualityValue.slice("q=".length));
      if (Number.isNaN(qualityValueAsFloat) || qualityValueAsFloat > 1) {
        result.push({
          locale: localeName,
          qualityValue: void 0
        });
      } else {
        result.push({
          locale: localeName,
          qualityValue: qualityValueAsFloat
        });
      }
    } else {
      result.push({
        locale: localeName,
        qualityValue: void 0
      });
    }
  }
  return result;
}
function sortAndFilterLocales(browserLocaleList, locales) {
  const normalizedLocales = toCodes(locales).map(normalizeTheLocale);
  return browserLocaleList.filter((browserLocale) => {
    if (browserLocale.locale !== "*") {
      return normalizedLocales.includes(normalizeTheLocale(browserLocale.locale));
    }
    return true;
  }).sort((a2, b2) => {
    if (a2.qualityValue && b2.qualityValue) {
      return Math.sign(b2.qualityValue - a2.qualityValue);
    }
    return 0;
  });
}
function computePreferredLocale(request, locales) {
  const acceptHeader = request.headers.get("Accept-Language");
  let result = void 0;
  if (acceptHeader) {
    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);
    const firstResult = browserLocaleList.at(0);
    if (firstResult && firstResult.locale !== "*") {
      for (const currentLocale of locales) {
        if (typeof currentLocale === "string") {
          if (normalizeTheLocale(currentLocale) === normalizeTheLocale(firstResult.locale)) {
            result = currentLocale;
          }
        } else {
          for (const currentCode of currentLocale.codes) {
            if (normalizeTheLocale(currentCode) === normalizeTheLocale(firstResult.locale)) {
              result = currentLocale.path;
            }
          }
        }
      }
    }
  }
  return result;
}
function computePreferredLocaleList(request, locales) {
  const acceptHeader = request.headers.get("Accept-Language");
  let result = [];
  if (acceptHeader) {
    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);
    if (browserLocaleList.length === 1 && browserLocaleList.at(0).locale === "*") {
      return locales.map((locale) => {
        if (typeof locale === "string") {
          return locale;
        } else {
          return locale.codes.at(0);
        }
      });
    } else if (browserLocaleList.length > 0) {
      for (const browserLocale of browserLocaleList) {
        for (const loopLocale of locales) {
          if (typeof loopLocale === "string") {
            if (normalizeTheLocale(loopLocale) === normalizeTheLocale(browserLocale.locale)) {
              result.push(loopLocale);
            }
          } else {
            for (const code of loopLocale.codes) {
              if (code === browserLocale.locale) {
                result.push(loopLocale.path);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
function computeCurrentLocale(pathname, locales) {
  for (const segment of pathname.split("/")) {
    for (const locale of locales) {
      if (typeof locale === "string") {
        if (!segment.includes(locale))
          continue;
        if (normalizeTheLocale(locale) === normalizeTheLocale(segment)) {
          return locale;
        }
      } else {
        if (locale.path === segment) {
          return locale.codes.at(0);
        } else {
          for (const code of locale.codes) {
            if (normalizeTheLocale(code) === normalizeTheLocale(segment)) {
              return code;
            }
          }
        }
      }
    }
  }
}
function sequence(...handlers2) {
  const filtered = handlers2.filter((h2) => !!h2);
  const length = filtered.length;
  if (!length) {
    const handler = defineMiddleware((context, next) => {
      return next();
    });
    return handler;
  }
  return defineMiddleware((context, next) => {
    return applyHandle(0, context);
    function applyHandle(i2, handleContext) {
      const handle = filtered[i2];
      const result = handle(handleContext, async () => {
        if (i2 < length - 1) {
          return applyHandle(i2 + 1, handleContext);
        } else {
          return next();
        }
      });
      return result;
    }
  });
}
function defineMiddleware(fn2) {
  return fn2;
}
var RedirectComponentInstance = {
  default() {
    return new Response(null, {
      status: 301
    });
  }
};
var RedirectSinglePageBuiltModule = {
  page: () => Promise.resolve(RedirectComponentInstance),
  onRequest: (_3, next) => next(),
  renderers: []
};
function routeIsRedirect(route) {
  return route?.type === "redirect";
}
function routeIsFallback(route) {
  return route?.type === "fallback";
}
async function renderRedirect(renderContext) {
  const {
    request: { method },
    routeData
  } = renderContext;
  const { redirect, redirectRoute } = routeData;
  const status = redirectRoute && typeof redirect === "object" ? redirect.status : method === "GET" ? 301 : 308;
  const headers = { location: encodeURI(redirectRouteGenerate(renderContext)) };
  return new Response(null, { status, headers });
}
function redirectRouteGenerate(renderContext) {
  const {
    params,
    routeData: { redirect, redirectRoute }
  } = renderContext;
  if (typeof redirectRoute !== "undefined") {
    return redirectRoute?.generate(params) || redirectRoute?.pathname || "/";
  } else if (typeof redirect === "string") {
    let target = redirect;
    for (const param of Object.keys(params)) {
      const paramValue = params[param];
      target = target.replace(`[${param}]`, paramValue);
      target = target.replace(`[...${param}]`, paramValue);
    }
    return target;
  } else if (typeof redirect === "undefined") {
    return "/";
  }
  return redirect.destination;
}
async function callMiddleware(onRequest2, apiContext, responseFunction) {
  let nextCalled = false;
  let responseFunctionPromise = void 0;
  const next = async () => {
    nextCalled = true;
    responseFunctionPromise = responseFunction();
    return responseFunctionPromise;
  };
  let middlewarePromise = onRequest2(apiContext, next);
  return await Promise.resolve(middlewarePromise).then(async (value) => {
    if (nextCalled) {
      if (typeof value !== "undefined") {
        if (value instanceof Response === false) {
          throw new AstroError(MiddlewareNotAResponse);
        }
        return value;
      } else {
        if (responseFunctionPromise) {
          return responseFunctionPromise;
        } else {
          throw new AstroError(MiddlewareNotAResponse);
        }
      }
    } else if (typeof value === "undefined") {
      throw new AstroError(MiddlewareNoDataOrNextCalled);
    } else if (value instanceof Response === false) {
      throw new AstroError(MiddlewareNotAResponse);
    } else {
      return value;
    }
  });
}
var VALID_PARAM_TYPES = ["string", "number", "undefined"];
function validateGetStaticPathsParameter([key, value], route) {
  if (!VALID_PARAM_TYPES.includes(typeof value)) {
    throw new AstroError({
      ...GetStaticPathsInvalidRouteParam,
      message: GetStaticPathsInvalidRouteParam.message(key, value, typeof value),
      location: {
        file: route
      }
    });
  }
}
function validateDynamicRouteModule(mod, {
  ssr,
  route
}) {
  if ((!ssr || route.prerender) && !mod.getStaticPaths) {
    throw new AstroError({
      ...GetStaticPathsRequired,
      location: { file: route.component }
    });
  }
}
function validateGetStaticPathsResult(result, logger2, route) {
  if (!Array.isArray(result)) {
    throw new AstroError({
      ...InvalidGetStaticPathsReturn,
      message: InvalidGetStaticPathsReturn.message(typeof result),
      location: {
        file: route.component
      }
    });
  }
  result.forEach((pathObject) => {
    if (typeof pathObject === "object" && Array.isArray(pathObject) || pathObject === null) {
      throw new AstroError({
        ...InvalidGetStaticPathsEntry,
        message: InvalidGetStaticPathsEntry.message(
          Array.isArray(pathObject) ? "array" : typeof pathObject
        )
      });
    }
    if (pathObject.params === void 0 || pathObject.params === null || pathObject.params && Object.keys(pathObject.params).length === 0) {
      throw new AstroError({
        ...GetStaticPathsExpectedParams,
        location: {
          file: route.component
        }
      });
    }
    for (const [key, val] of Object.entries(pathObject.params)) {
      if (!(typeof val === "undefined" || typeof val === "string" || typeof val === "number")) {
        logger2.warn(
          "router",
          `getStaticPaths() returned an invalid path param: "${key}". A string, number or undefined value was expected, but got \`${JSON.stringify(
            val
          )}\`.`
        );
      }
      if (typeof val === "string" && val === "") {
        logger2.warn(
          "router",
          `getStaticPaths() returned an invalid path param: "${key}". \`undefined\` expected for an optional param, but got empty string.`
        );
      }
    }
  });
}
function stringifyParams(params, route) {
  const validatedParams = Object.entries(params).reduce((acc, next) => {
    validateGetStaticPathsParameter(next, route.component);
    const [key, value] = next;
    if (value !== void 0) {
      acc[key] = typeof value === "string" ? trimSlashes2(value) : value.toString();
    }
    return acc;
  }, {});
  return JSON.stringify(route.generate(validatedParams));
}
function generatePaginateFunction(routeMatch) {
  return function paginateUtility(data, args = {}) {
    let { pageSize: _pageSize, params: _params, props: _props } = args;
    const pageSize = _pageSize || 10;
    const paramName = "page";
    const additionalParams = _params || {};
    const additionalProps = _props || {};
    let includesFirstPageNumber;
    if (routeMatch.params.includes(`...${paramName}`)) {
      includesFirstPageNumber = false;
    } else if (routeMatch.params.includes(`${paramName}`)) {
      includesFirstPageNumber = true;
    } else {
      throw new AstroError({
        ...PageNumberParamNotFound,
        message: PageNumberParamNotFound.message(paramName)
      });
    }
    const lastPage = Math.max(1, Math.ceil(data.length / pageSize));
    const result = [...Array(lastPage).keys()].map((num) => {
      const pageNum = num + 1;
      const start = pageSize === Infinity ? 0 : (pageNum - 1) * pageSize;
      const end = Math.min(start + pageSize, data.length);
      const params = {
        ...additionalParams,
        [paramName]: includesFirstPageNumber || pageNum > 1 ? String(pageNum) : void 0
      };
      const current = correctIndexRoute(routeMatch.generate({ ...params }));
      const next = pageNum === lastPage ? void 0 : correctIndexRoute(routeMatch.generate({ ...params, page: String(pageNum + 1) }));
      const prev = pageNum === 1 ? void 0 : correctIndexRoute(
        routeMatch.generate({
          ...params,
          page: !includesFirstPageNumber && pageNum - 1 === 1 ? void 0 : String(pageNum - 1)
        })
      );
      return {
        params,
        props: {
          ...additionalProps,
          page: {
            data: data.slice(start, end),
            start,
            end: end - 1,
            size: pageSize,
            total: data.length,
            currentPage: pageNum,
            lastPage,
            url: { current, next, prev }
          }
        }
      };
    });
    return result;
  };
}
function correctIndexRoute(route) {
  if (route === "") {
    return "/";
  }
  return route;
}
async function callGetStaticPaths({
  mod,
  route,
  routeCache,
  logger: logger2,
  ssr
}) {
  const cached = routeCache.get(route);
  if (!mod) {
    throw new Error("This is an error caused by Astro and not your code. Please file an issue.");
  }
  if (cached?.staticPaths) {
    return cached.staticPaths;
  }
  validateDynamicRouteModule(mod, { ssr, route });
  if (ssr && !route.prerender) {
    const entry = Object.assign([], { keyed: /* @__PURE__ */ new Map() });
    routeCache.set(route, { ...cached, staticPaths: entry });
    return entry;
  }
  let staticPaths = [];
  if (!mod.getStaticPaths) {
    throw new Error("Unexpected Error.");
  }
  staticPaths = await mod.getStaticPaths({
    // Q: Why the cast?
    // A: So users downstream can have nicer typings, we have to make some sacrifice in our internal typings, which necessitate a cast here
    paginate: generatePaginateFunction(route)
  });
  validateGetStaticPathsResult(staticPaths, logger2, route);
  const keyedStaticPaths = staticPaths;
  keyedStaticPaths.keyed = /* @__PURE__ */ new Map();
  for (const sp of keyedStaticPaths) {
    const paramsKey = stringifyParams(sp.params, route);
    keyedStaticPaths.keyed.set(paramsKey, sp);
  }
  routeCache.set(route, { ...cached, staticPaths: keyedStaticPaths });
  return keyedStaticPaths;
}
var RouteCache = class {
  logger;
  cache = {};
  mode;
  constructor(logger2, mode = "production") {
    this.logger = logger2;
    this.mode = mode;
  }
  /** Clear the cache. */
  clearAll() {
    this.cache = {};
  }
  set(route, entry) {
    const key = this.key(route);
    if (this.mode === "production" && this.cache[key]?.staticPaths) {
      this.logger.warn(null, `Internal Warning: route cache overwritten. (${key})`);
    }
    this.cache[key] = entry;
  }
  get(route) {
    return this.cache[this.key(route)];
  }
  key(route) {
    return `${route.route}_${route.component}`;
  }
};
function findPathItemByKey(staticPaths, params, route, logger2) {
  const paramsKey = stringifyParams(params, route);
  const matchedStaticPath = staticPaths.keyed.get(paramsKey);
  if (matchedStaticPath) {
    return matchedStaticPath;
  }
  logger2.debug("router", `findPathItemByKey() - Unexpected cache miss looking for ${paramsKey}`);
}
var Pipeline = class {
  constructor(logger2, manifest2, mode, renderers2, resolve, serverLike, streaming, adapterName = manifest2.adapterName, clientDirectives = manifest2.clientDirectives, inlinedScripts = manifest2.inlinedScripts, compressHTML = manifest2.compressHTML, i18n = manifest2.i18n, middleware = manifest2.middleware, routeCache = new RouteCache(logger2, mode), site = manifest2.site ? new URL(manifest2.site) : void 0) {
    this.logger = logger2;
    this.manifest = manifest2;
    this.mode = mode;
    this.renderers = renderers2;
    this.resolve = resolve;
    this.serverLike = serverLike;
    this.streaming = streaming;
    this.adapterName = adapterName;
    this.clientDirectives = clientDirectives;
    this.inlinedScripts = inlinedScripts;
    this.compressHTML = compressHTML;
    this.i18n = i18n;
    this.middleware = middleware;
    this.routeCache = routeCache;
    this.site = site;
    this.internalMiddleware = [];
    if (i18n?.strategy !== "manual") {
      this.internalMiddleware.push(
        createI18nMiddleware(i18n, manifest2.base, manifest2.trailingSlash, manifest2.buildFormat)
      );
    }
  }
  internalMiddleware;
};
async function getProps(opts2) {
  const { logger: logger2, mod, routeData: route, routeCache, pathname, serverLike } = opts2;
  if (!route || route.pathname) {
    return {};
  }
  if (routeIsRedirect(route) || routeIsFallback(route) || route.component === DEFAULT_404_COMPONENT) {
    return {};
  }
  const params = getParams(route, pathname);
  if (mod) {
    validatePrerenderEndpointCollision(route, mod, params);
  }
  const staticPaths = await callGetStaticPaths({
    mod,
    route,
    routeCache,
    logger: logger2,
    ssr: serverLike
  });
  const matchedStaticPath = findPathItemByKey(staticPaths, params, route, logger2);
  if (!matchedStaticPath && (serverLike ? route.prerender : true)) {
    throw new AstroError({
      ...NoMatchingStaticPathFound,
      message: NoMatchingStaticPathFound.message(pathname),
      hint: NoMatchingStaticPathFound.hint([route.component])
    });
  }
  const props = matchedStaticPath?.props ? { ...matchedStaticPath.props } : {};
  return props;
}
function getParams(route, pathname) {
  if (!route.params.length)
    return {};
  const paramsMatch = route.pattern.exec(decodeURIComponent(pathname));
  if (!paramsMatch)
    return {};
  const params = {};
  route.params.forEach((key, i2) => {
    if (key.startsWith("...")) {
      params[key.slice(3)] = paramsMatch[i2 + 1] ? paramsMatch[i2 + 1] : void 0;
    } else {
      params[key] = paramsMatch[i2 + 1];
    }
  });
  return params;
}
function validatePrerenderEndpointCollision(route, mod, params) {
  if (route.type === "endpoint" && mod.getStaticPaths) {
    const lastSegment = route.segments[route.segments.length - 1];
    const paramValues = Object.values(params);
    const lastParam = paramValues[paramValues.length - 1];
    if (lastSegment.length === 1 && lastSegment[0].dynamic && lastParam === void 0) {
      throw new AstroError({
        ...PrerenderDynamicEndpointPathCollide,
        message: PrerenderDynamicEndpointPathCollide.message(route.route),
        hint: PrerenderDynamicEndpointPathCollide.hint(route.component),
        location: {
          file: route.component
        }
      });
    }
  }
}
function getFunctionExpression(slot) {
  if (!slot)
    return;
  const expressions = slot?.expressions?.filter((e2) => isRenderInstruction(e2) === false);
  if (expressions?.length !== 1)
    return;
  return expressions[0];
}
var Slots = class {
  #result;
  #slots;
  #logger;
  constructor(result, slots, logger2) {
    this.#result = result;
    this.#slots = slots;
    this.#logger = logger2;
    if (slots) {
      for (const key of Object.keys(slots)) {
        if (this[key] !== void 0) {
          throw new AstroError({
            ...ReservedSlotName,
            message: ReservedSlotName.message(key)
          });
        }
        Object.defineProperty(this, key, {
          get() {
            return true;
          },
          enumerable: true
        });
      }
    }
  }
  has(name) {
    if (!this.#slots)
      return false;
    return Boolean(this.#slots[name]);
  }
  async render(name, args = []) {
    if (!this.#slots || !this.has(name))
      return;
    const result = this.#result;
    if (!Array.isArray(args)) {
      this.#logger.warn(
        null,
        `Expected second parameter to be an array, received a ${typeof args}. If you're trying to pass an array as a single argument and getting unexpected results, make sure you're passing your array as a item of an array. Ex: Astro.slots.render('default', [["Hello", "World"]])`
      );
    } else if (args.length > 0) {
      const slotValue = this.#slots[name];
      const component = typeof slotValue === "function" ? await slotValue(result) : await slotValue;
      const expression = getFunctionExpression(component);
      if (expression) {
        const slot = async () => typeof expression === "function" ? expression(...args) : expression;
        return await renderSlotToString(result, slot).then((res) => {
          return res;
        });
      }
      if (typeof component === "function") {
        return await renderJSX(result, component(...args)).then(
          (res) => res != null ? String(res) : res
        );
      }
    }
    const content = await renderSlotToString(result, this.#slots[name]);
    const outHTML = chunkToString(result, content);
    return outHTML;
  }
};
var RenderContext = class {
  constructor(pipeline, locals, middleware, pathname, request, routeData, status, cookies = new AstroCookies(request), params = getParams(routeData, pathname), url = new URL(request.url)) {
    this.pipeline = pipeline;
    this.locals = locals;
    this.middleware = middleware;
    this.pathname = pathname;
    this.request = request;
    this.routeData = routeData;
    this.status = status;
    this.cookies = cookies;
    this.params = params;
    this.url = url;
  }
  static create({
    locals = {},
    middleware,
    pathname,
    pipeline,
    request,
    routeData,
    status = 200
  }) {
    return new RenderContext(
      pipeline,
      locals,
      sequence(...pipeline.internalMiddleware, middleware ?? pipeline.middleware),
      pathname,
      request,
      routeData,
      status
    );
  }
  /**
   * The main function of the RenderContext.
   *
   * Use this function to render any route known to Astro.
   * It attempts to render a route. A route can be a:
   *
   * - page
   * - redirect
   * - endpoint
   * - fallback
   */
  async render(componentInstance) {
    const { cookies, middleware, pathname, pipeline, routeData } = this;
    const { logger: logger2, routeCache, serverLike, streaming } = pipeline;
    const props = await getProps({
      mod: componentInstance,
      routeData,
      routeCache,
      pathname,
      logger: logger2,
      serverLike
    });
    const apiContext = this.createAPIContext(props);
    const lastNext = async () => {
      switch (routeData.type) {
        case "endpoint":
          return renderEndpoint(componentInstance, apiContext, serverLike, logger2);
        case "redirect":
          return renderRedirect(this);
        case "page": {
          const result = await this.createResult(componentInstance);
          let response2;
          try {
            response2 = await renderPage(
              result,
              componentInstance?.default,
              props,
              {},
              streaming,
              routeData
            );
          } catch (e2) {
            result.cancelled = true;
            throw e2;
          }
          response2.headers.set(ROUTE_TYPE_HEADER, "page");
          if (routeData.route === "/404" || routeData.route === "/500") {
            response2.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
          }
          return response2;
        }
        case "fallback": {
          return new Response(null, { status: 500, headers: { [ROUTE_TYPE_HEADER]: "fallback" } });
        }
      }
    };
    const response = await callMiddleware(middleware, apiContext, lastNext);
    if (response.headers.get(ROUTE_TYPE_HEADER)) {
      response.headers.delete(ROUTE_TYPE_HEADER);
    }
    attachCookiesToResponse(response, cookies);
    return response;
  }
  createAPIContext(props) {
    const renderContext = this;
    const { cookies, params, pipeline, request, url } = this;
    const generator = `Astro v${ASTRO_VERSION}`;
    const redirect = (path, status = 302) => new Response(null, { status, headers: { Location: path } });
    return {
      cookies,
      get clientAddress() {
        return renderContext.clientAddress();
      },
      get currentLocale() {
        return renderContext.computeCurrentLocale();
      },
      generator,
      get locals() {
        return renderContext.locals;
      },
      // TODO(breaking): disallow replacing the locals object
      set locals(val) {
        if (typeof val !== "object") {
          throw new AstroError(LocalsNotAnObject);
        } else {
          renderContext.locals = val;
          Reflect.set(request, clientLocalsSymbol, val);
        }
      },
      params,
      get preferredLocale() {
        return renderContext.computePreferredLocale();
      },
      get preferredLocaleList() {
        return renderContext.computePreferredLocaleList();
      },
      props,
      redirect,
      request,
      site: pipeline.site,
      url
    };
  }
  async createResult(mod) {
    const { cookies, pathname, pipeline, routeData, status } = this;
    const { clientDirectives, inlinedScripts, compressHTML, manifest: manifest2, renderers: renderers2, resolve } = pipeline;
    const { links, scripts, styles } = await pipeline.headElements(routeData);
    const componentMetadata = await pipeline.componentMetadata(routeData) ?? manifest2.componentMetadata;
    const headers = new Headers({ "Content-Type": "text/html" });
    const partial = Boolean(mod.partial);
    const response = {
      status,
      statusText: "OK",
      get headers() {
        return headers;
      },
      // Disallow `Astro.response.headers = new Headers`
      set headers(_3) {
        throw new AstroError(AstroResponseHeadersReassigned);
      }
    };
    const result = {
      cancelled: false,
      clientDirectives,
      inlinedScripts,
      componentMetadata,
      compressHTML,
      cookies,
      /** This function returns the `Astro` faux-global */
      createAstro: (astroGlobal, props, slots) => this.createAstro(result, astroGlobal, props, slots),
      links,
      partial,
      pathname,
      renderers: renderers2,
      resolve,
      response,
      scripts,
      styles,
      _metadata: {
        hasHydrationScript: false,
        rendererSpecificHydrationScripts: /* @__PURE__ */ new Set(),
        hasRenderedHead: false,
        renderedScripts: /* @__PURE__ */ new Set(),
        hasDirectives: /* @__PURE__ */ new Set(),
        headInTree: false,
        extraHead: [],
        propagators: /* @__PURE__ */ new Set()
      }
    };
    return result;
  }
  createAstro(result, astroGlobalPartial, props, slotValues) {
    const renderContext = this;
    const { cookies, locals, params, pipeline, request, url } = this;
    const { response } = result;
    const redirect = (path, status = 302) => {
      if (request[responseSentSymbol]) {
        throw new AstroError({
          ...ResponseSentError
        });
      }
      return new Response(null, { status, headers: { Location: path } });
    };
    const slots = new Slots(result, slotValues, pipeline.logger);
    const astroGlobalCombined = {
      ...astroGlobalPartial,
      cookies,
      get clientAddress() {
        return renderContext.clientAddress();
      },
      get currentLocale() {
        return renderContext.computeCurrentLocale();
      },
      params,
      get preferredLocale() {
        return renderContext.computePreferredLocale();
      },
      get preferredLocaleList() {
        return renderContext.computePreferredLocaleList();
      },
      props,
      locals,
      redirect,
      request,
      response,
      slots,
      site: pipeline.site,
      url
    };
    return astroGlobalCombined;
  }
  clientAddress() {
    const { pipeline, request } = this;
    if (clientAddressSymbol in request) {
      return Reflect.get(request, clientAddressSymbol);
    }
    if (pipeline.adapterName) {
      throw new AstroError({
        ...ClientAddressNotAvailable,
        message: ClientAddressNotAvailable.message(pipeline.adapterName)
      });
    } else {
      throw new AstroError(StaticClientAddressNotAvailable);
    }
  }
  /**
   * API Context may be created multiple times per request, i18n data needs to be computed only once.
   * So, it is computed and saved here on creation of the first APIContext and reused for later ones.
   */
  #currentLocale;
  computeCurrentLocale() {
    const {
      url,
      pipeline: { i18n },
      routeData
    } = this;
    if (!i18n)
      return;
    const { defaultLocale, locales, strategy } = i18n;
    const fallbackTo = strategy === "pathname-prefix-other-locales" || strategy === "domains-prefix-other-locales" ? defaultLocale : void 0;
    return this.#currentLocale ??= computeCurrentLocale(routeData.route, locales) ?? computeCurrentLocale(url.pathname, locales) ?? fallbackTo;
  }
  #preferredLocale;
  computePreferredLocale() {
    const {
      pipeline: { i18n },
      request
    } = this;
    if (!i18n)
      return;
    return this.#preferredLocale ??= computePreferredLocale(request, i18n.locales);
  }
  #preferredLocaleList;
  computePreferredLocaleList() {
    const {
      pipeline: { i18n },
      request
    } = this;
    if (!i18n)
      return;
    return this.#preferredLocaleList ??= computePreferredLocaleList(request, i18n.locales);
  }
};
function getAssetsPrefix(fileExtension2, assetsPrefix) {
  if (!assetsPrefix)
    return "";
  if (typeof assetsPrefix === "string")
    return assetsPrefix;
  const dotLessFileExtension = fileExtension2.slice(1);
  if (assetsPrefix[dotLessFileExtension]) {
    return assetsPrefix[dotLessFileExtension];
  }
  return assetsPrefix.fallback;
}
function createAssetLink(href, base, assetsPrefix) {
  if (assetsPrefix) {
    const pf2 = getAssetsPrefix(fileExtension(href), assetsPrefix);
    return joinPaths(pf2, slash(href));
  } else if (base) {
    return prependForwardSlash(joinPaths(base, slash(href)));
  } else {
    return href;
  }
}
function createStylesheetElement(stylesheet, base, assetsPrefix) {
  if (stylesheet.type === "inline") {
    return {
      props: {},
      children: stylesheet.content
    };
  } else {
    return {
      props: {
        rel: "stylesheet",
        href: createAssetLink(stylesheet.src, base, assetsPrefix)
      },
      children: ""
    };
  }
}
function createStylesheetElementSet(stylesheets, base, assetsPrefix) {
  return new Set(stylesheets.map((s3) => createStylesheetElement(s3, base, assetsPrefix)));
}
function createModuleScriptElement(script, base, assetsPrefix) {
  if (script.type === "external") {
    return createModuleScriptElementWithSrc(script.value, base, assetsPrefix);
  } else {
    return {
      props: {
        type: "module"
      },
      children: script.value
    };
  }
}
function createModuleScriptElementWithSrc(src, base, assetsPrefix) {
  return {
    props: {
      type: "module",
      src: createAssetLink(src, base, assetsPrefix)
    },
    children: ""
  };
}
function ensure404Route(manifest2) {
  if (!manifest2.routes.some((route) => route.route === "/404")) {
    manifest2.routes.push({
      component: DEFAULT_404_COMPONENT,
      generate: () => "",
      params: [],
      pattern: /\/404/,
      prerender: false,
      segments: [[{ content: "404", dynamic: false, spread: false }]],
      type: "page",
      route: "/404",
      fallbackRoutes: [],
      isIndex: false
    });
  }
  return manifest2;
}
function matchRoute(pathname, manifest2) {
  const decodedPathname = decodeURI(pathname);
  return manifest2.routes.find((route) => {
    return route.pattern.test(decodedPathname) || route.fallbackRoutes.some((fallbackRoute) => fallbackRoute.pattern.test(decodedPathname));
  });
}
var FORM_CONTENT_TYPES = [
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
];
function createOriginCheckMiddleware() {
  return defineMiddleware((context, next) => {
    const { request, url } = context;
    const contentType = request.headers.get("content-type");
    if (contentType) {
      if (FORM_CONTENT_TYPES.includes(contentType.toLowerCase())) {
        const forbidden = (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
        if (forbidden) {
          return new Response(`Cross-site ${request.method} form submissions are forbidden`, {
            status: 403
          });
        }
      }
    }
    return next();
  });
}
var AppPipeline = class extends Pipeline {
  static create({
    logger: logger2,
    manifest: manifest2,
    mode,
    renderers: renderers2,
    resolve,
    serverLike,
    streaming
  }) {
    return new AppPipeline(logger2, manifest2, mode, renderers2, resolve, serverLike, streaming);
  }
  headElements(routeData) {
    const routeInfo = this.manifest.routes.find((route) => route.routeData === routeData);
    const links = /* @__PURE__ */ new Set();
    const scripts = /* @__PURE__ */ new Set();
    const styles = createStylesheetElementSet(routeInfo?.styles ?? []);
    for (const script of routeInfo?.scripts ?? []) {
      if ("stage" in script) {
        if (script.stage === "head-inline") {
          scripts.add({
            props: {},
            children: script.children
          });
        }
      } else {
        scripts.add(createModuleScriptElement(script));
      }
    }
    return { links, styles, scripts };
  }
  componentMetadata() {
  }
};
var _manifest;
var _manifestData;
var _logger;
var _baseWithoutTrailingSlash;
var _pipeline;
var _adapterLogger;
var _renderOptionsDeprecationWarningShown;
var _createPipeline;
var createPipeline_fn;
var _getPathnameFromRequest;
var getPathnameFromRequest_fn;
var _computePathnameFromDomain;
var computePathnameFromDomain_fn;
var _logRenderOptionsDeprecationWarning;
var logRenderOptionsDeprecationWarning_fn;
var _renderError;
var renderError_fn;
var _mergeResponses;
var mergeResponses_fn;
var _getDefaultStatusCode;
var getDefaultStatusCode_fn;
var _getModuleForRoute;
var getModuleForRoute_fn;
var _App = class {
  constructor(manifest2, streaming = true) {
    __privateAdd(this, _createPipeline);
    __privateAdd(this, _getPathnameFromRequest);
    __privateAdd(this, _computePathnameFromDomain);
    __privateAdd(this, _logRenderOptionsDeprecationWarning);
    __privateAdd(this, _renderError);
    __privateAdd(this, _mergeResponses);
    __privateAdd(this, _getDefaultStatusCode);
    __privateAdd(this, _getModuleForRoute);
    __privateAdd(this, _manifest, void 0);
    __privateAdd(this, _manifestData, void 0);
    __privateAdd(this, _logger, new Logger({
      dest: consoleLogDestination,
      level: "info"
    }));
    __privateAdd(this, _baseWithoutTrailingSlash, void 0);
    __privateAdd(this, _pipeline, void 0);
    __privateAdd(this, _adapterLogger, void 0);
    __privateAdd(this, _renderOptionsDeprecationWarningShown, false);
    __privateSet(this, _manifest, manifest2);
    __privateSet(this, _manifestData, ensure404Route({
      routes: manifest2.routes.map((route) => route.routeData)
    }));
    __privateSet(this, _baseWithoutTrailingSlash, removeTrailingForwardSlash(__privateGet(this, _manifest).base));
    __privateSet(this, _pipeline, __privateMethod(this, _createPipeline, createPipeline_fn).call(this, streaming));
    __privateSet(this, _adapterLogger, new AstroIntegrationLogger(
      __privateGet(this, _logger).options,
      __privateGet(this, _manifest).adapterName
    ));
  }
  getAdapterLogger() {
    return __privateGet(this, _adapterLogger);
  }
  set setManifestData(newManifestData) {
    __privateSet(this, _manifestData, newManifestData);
  }
  removeBase(pathname) {
    if (pathname.startsWith(__privateGet(this, _manifest).base)) {
      return pathname.slice(__privateGet(this, _baseWithoutTrailingSlash).length + 1);
    }
    return pathname;
  }
  match(request) {
    const url = new URL(request.url);
    if (__privateGet(this, _manifest).assets.has(url.pathname))
      return void 0;
    let pathname = __privateMethod(this, _computePathnameFromDomain, computePathnameFromDomain_fn).call(this, request);
    if (!pathname) {
      pathname = prependForwardSlash(this.removeBase(url.pathname));
    }
    let routeData = matchRoute(pathname, __privateGet(this, _manifestData));
    if (!routeData || routeData.prerender)
      return void 0;
    return routeData;
  }
  async render(request, routeDataOrOptions, maybeLocals) {
    let routeData;
    let locals;
    let clientAddress;
    let addCookieHeader;
    if (routeDataOrOptions && ("addCookieHeader" in routeDataOrOptions || "clientAddress" in routeDataOrOptions || "locals" in routeDataOrOptions || "routeData" in routeDataOrOptions)) {
      if ("addCookieHeader" in routeDataOrOptions) {
        addCookieHeader = routeDataOrOptions.addCookieHeader;
      }
      if ("clientAddress" in routeDataOrOptions) {
        clientAddress = routeDataOrOptions.clientAddress;
      }
      if ("routeData" in routeDataOrOptions) {
        routeData = routeDataOrOptions.routeData;
      }
      if ("locals" in routeDataOrOptions) {
        locals = routeDataOrOptions.locals;
      }
    } else {
      routeData = routeDataOrOptions;
      locals = maybeLocals;
      if (routeDataOrOptions || locals) {
        __privateMethod(this, _logRenderOptionsDeprecationWarning, logRenderOptionsDeprecationWarning_fn).call(this);
      }
    }
    if (locals) {
      if (typeof locals !== "object") {
        __privateGet(this, _logger).error(null, new AstroError(LocalsNotAnObject).stack);
        return __privateMethod(this, _renderError, renderError_fn).call(this, request, { status: 500 });
      }
      Reflect.set(request, clientLocalsSymbol, locals);
    }
    if (clientAddress) {
      Reflect.set(request, clientAddressSymbol, clientAddress);
    }
    if (request.url !== collapseDuplicateSlashes(request.url)) {
      request = new Request(collapseDuplicateSlashes(request.url), request);
    }
    if (!routeData) {
      routeData = this.match(request);
    }
    if (!routeData) {
      return __privateMethod(this, _renderError, renderError_fn).call(this, request, { locals, status: 404 });
    }
    const pathname = __privateMethod(this, _getPathnameFromRequest, getPathnameFromRequest_fn).call(this, request);
    const defaultStatus = __privateMethod(this, _getDefaultStatusCode, getDefaultStatusCode_fn).call(this, routeData, pathname);
    const mod = await __privateMethod(this, _getModuleForRoute, getModuleForRoute_fn).call(this, routeData);
    let response;
    try {
      const renderContext = RenderContext.create({
        pipeline: __privateGet(this, _pipeline),
        locals,
        pathname,
        request,
        routeData,
        status: defaultStatus
      });
      response = await renderContext.render(await mod.page());
    } catch (err) {
      __privateGet(this, _logger).error(null, err.stack || err.message || String(err));
      return __privateMethod(this, _renderError, renderError_fn).call(this, request, { locals, status: 500 });
    }
    if (REROUTABLE_STATUS_CODES.includes(response.status) && response.headers.get(REROUTE_DIRECTIVE_HEADER) !== "no") {
      return __privateMethod(this, _renderError, renderError_fn).call(this, request, {
        locals,
        response,
        status: response.status
      });
    }
    if (response.headers.has(REROUTE_DIRECTIVE_HEADER)) {
      response.headers.delete(REROUTE_DIRECTIVE_HEADER);
    }
    if (addCookieHeader) {
      for (const setCookieHeaderValue of _App.getSetCookieFromResponse(response)) {
        response.headers.append("set-cookie", setCookieHeaderValue);
      }
    }
    Reflect.set(response, responseSentSymbol, true);
    return response;
  }
  setCookieHeaders(response) {
    return getSetCookiesFromResponse(response);
  }
};
var App = _App;
_manifest = /* @__PURE__ */ new WeakMap();
_manifestData = /* @__PURE__ */ new WeakMap();
_logger = /* @__PURE__ */ new WeakMap();
_baseWithoutTrailingSlash = /* @__PURE__ */ new WeakMap();
_pipeline = /* @__PURE__ */ new WeakMap();
_adapterLogger = /* @__PURE__ */ new WeakMap();
_renderOptionsDeprecationWarningShown = /* @__PURE__ */ new WeakMap();
_createPipeline = /* @__PURE__ */ new WeakSet();
createPipeline_fn = function(streaming = false) {
  if (__privateGet(this, _manifest).checkOrigin) {
    __privateGet(this, _manifest).middleware = sequence(
      createOriginCheckMiddleware(),
      __privateGet(this, _manifest).middleware
    );
  }
  return AppPipeline.create({
    logger: __privateGet(this, _logger),
    manifest: __privateGet(this, _manifest),
    mode: "production",
    renderers: __privateGet(this, _manifest).renderers,
    resolve: async (specifier) => {
      if (!(specifier in __privateGet(this, _manifest).entryModules)) {
        throw new Error(`Unable to resolve [${specifier}]`);
      }
      const bundlePath = __privateGet(this, _manifest).entryModules[specifier];
      switch (true) {
        case bundlePath.startsWith("data:"):
        case bundlePath.length === 0: {
          return bundlePath;
        }
        default: {
          return createAssetLink(bundlePath, __privateGet(this, _manifest).base, __privateGet(this, _manifest).assetsPrefix);
        }
      }
    },
    serverLike: true,
    streaming
  });
};
_getPathnameFromRequest = /* @__PURE__ */ new WeakSet();
getPathnameFromRequest_fn = function(request) {
  const url = new URL(request.url);
  const pathname = prependForwardSlash(this.removeBase(url.pathname));
  return pathname;
};
_computePathnameFromDomain = /* @__PURE__ */ new WeakSet();
computePathnameFromDomain_fn = function(request) {
  let pathname = void 0;
  const url = new URL(request.url);
  if (__privateGet(this, _manifest).i18n && (__privateGet(this, _manifest).i18n.strategy === "domains-prefix-always" || __privateGet(this, _manifest).i18n.strategy === "domains-prefix-other-locales" || __privateGet(this, _manifest).i18n.strategy === "domains-prefix-always-no-redirect")) {
    let host = request.headers.get("X-Forwarded-Host");
    let protocol = request.headers.get("X-Forwarded-Proto");
    if (protocol) {
      protocol = protocol + ":";
    } else {
      protocol = url.protocol;
    }
    if (!host) {
      host = request.headers.get("Host");
    }
    if (host && protocol) {
      host = host.split(":")[0];
      try {
        let locale;
        const hostAsUrl = new URL(`${protocol}//${host}`);
        for (const [domainKey, localeValue] of Object.entries(
          __privateGet(this, _manifest).i18n.domainLookupTable
        )) {
          const domainKeyAsUrl = new URL(domainKey);
          if (hostAsUrl.host === domainKeyAsUrl.host && hostAsUrl.protocol === domainKeyAsUrl.protocol) {
            locale = localeValue;
            break;
          }
        }
        if (locale) {
          pathname = prependForwardSlash(
            joinPaths(normalizeTheLocale(locale), this.removeBase(url.pathname))
          );
          if (url.pathname.endsWith("/")) {
            pathname = appendForwardSlash(pathname);
          }
        }
      } catch (e2) {
        __privateGet(this, _logger).error(
          "router",
          `Astro tried to parse ${protocol}//${host} as an URL, but it threw a parsing error. Check the X-Forwarded-Host and X-Forwarded-Proto headers.`
        );
        __privateGet(this, _logger).error("router", `Error: ${e2}`);
      }
    }
  }
  return pathname;
};
_logRenderOptionsDeprecationWarning = /* @__PURE__ */ new WeakSet();
logRenderOptionsDeprecationWarning_fn = function() {
  if (__privateGet(this, _renderOptionsDeprecationWarningShown))
    return;
  __privateGet(this, _logger).warn(
    "deprecated",
    `The adapter ${__privateGet(this, _manifest).adapterName} is using a deprecated signature of the 'app.render()' method. From Astro 4.0, locals and routeData are provided as properties on an optional object to this method. Using the old signature will cause an error in Astro 5.0. See https://github.com/withastro/astro/pull/9199 for more information.`
  );
  __privateSet(this, _renderOptionsDeprecationWarningShown, true);
};
_renderError = /* @__PURE__ */ new WeakSet();
renderError_fn = async function(request, { locals, status, response: originalResponse, skipMiddleware = false }) {
  const errorRoutePath = `/${status}${__privateGet(this, _manifest).trailingSlash === "always" ? "/" : ""}`;
  const errorRouteData = matchRoute(errorRoutePath, __privateGet(this, _manifestData));
  const url = new URL(request.url);
  if (errorRouteData) {
    if (errorRouteData.prerender) {
      const maybeDotHtml = errorRouteData.route.endsWith(`/${status}`) ? ".html" : "";
      const statusURL = new URL(
        `${__privateGet(this, _baseWithoutTrailingSlash)}/${status}${maybeDotHtml}`,
        url
      );
      const response2 = await fetch(statusURL.toString());
      const override = { status };
      return __privateMethod(this, _mergeResponses, mergeResponses_fn).call(this, response2, originalResponse, override);
    }
    const mod = await __privateMethod(this, _getModuleForRoute, getModuleForRoute_fn).call(this, errorRouteData);
    try {
      const renderContext = RenderContext.create({
        locals,
        pipeline: __privateGet(this, _pipeline),
        middleware: skipMiddleware ? (_3, next) => next() : void 0,
        pathname: __privateMethod(this, _getPathnameFromRequest, getPathnameFromRequest_fn).call(this, request),
        request,
        routeData: errorRouteData,
        status
      });
      const response2 = await renderContext.render(await mod.page());
      return __privateMethod(this, _mergeResponses, mergeResponses_fn).call(this, response2, originalResponse);
    } catch {
      if (skipMiddleware === false) {
        return __privateMethod(this, _renderError, renderError_fn).call(this, request, {
          locals,
          status,
          response: originalResponse,
          skipMiddleware: true
        });
      }
    }
  }
  const response = __privateMethod(this, _mergeResponses, mergeResponses_fn).call(this, new Response(null, { status }), originalResponse);
  Reflect.set(response, responseSentSymbol, true);
  return response;
};
_mergeResponses = /* @__PURE__ */ new WeakSet();
mergeResponses_fn = function(newResponse, originalResponse, override) {
  if (!originalResponse) {
    if (override !== void 0) {
      return new Response(newResponse.body, {
        status: override.status,
        statusText: newResponse.statusText,
        headers: newResponse.headers
      });
    }
    return newResponse;
  }
  const status = override?.status ? override.status : originalResponse.status === 200 ? newResponse.status : originalResponse.status;
  try {
    originalResponse.headers.delete("Content-type");
  } catch {
  }
  return new Response(newResponse.body, {
    status,
    statusText: status === 200 ? newResponse.statusText : originalResponse.statusText,
    // If you're looking at here for possible bugs, it means that it's not a bug.
    // With the middleware, users can meddle with headers, and we should pass to the 404/500.
    // If users see something weird, it's because they are setting some headers they should not.
    //
    // Although, we don't want it to replace the content-type, because the error page must return `text/html`
    headers: new Headers([
      ...Array.from(newResponse.headers),
      ...Array.from(originalResponse.headers)
    ])
  });
};
_getDefaultStatusCode = /* @__PURE__ */ new WeakSet();
getDefaultStatusCode_fn = function(routeData, pathname) {
  if (!routeData.pattern.exec(pathname)) {
    for (const fallbackRoute of routeData.fallbackRoutes) {
      if (fallbackRoute.pattern.test(pathname)) {
        return 302;
      }
    }
  }
  const route = removeTrailingForwardSlash(routeData.route);
  if (route.endsWith("/404"))
    return 404;
  if (route.endsWith("/500"))
    return 500;
  return 200;
};
_getModuleForRoute = /* @__PURE__ */ new WeakSet();
getModuleForRoute_fn = async function(route) {
  if (route.component === DEFAULT_404_COMPONENT) {
    return {
      page: async () => ({ default: () => new Response(null, { status: 404 }) }),
      renderers: []
    };
  }
  if (route.type === "redirect") {
    return RedirectSinglePageBuiltModule;
  } else {
    if (__privateGet(this, _manifest).pageMap) {
      const importComponentInstance = __privateGet(this, _manifest).pageMap.get(route.component);
      if (!importComponentInstance) {
        throw new Error(
          `Unexpectedly unable to find a component instance for route ${route.route}`
        );
      }
      const pageModule = await importComponentInstance();
      return pageModule;
    } else if (__privateGet(this, _manifest).pageModule) {
      const importComponentInstance = __privateGet(this, _manifest).pageModule;
      return importComponentInstance;
    } else {
      throw new Error(
        "Astro couldn't find the correct page to render, probably because it wasn't correctly mapped for SSR usage. This is an internal error, please file an issue."
      );
    }
  }
};
__publicField2(App, "getSetCookieFromResponse", getSetCookiesFromResponse);
function createExports(manifest2) {
  const app = new App(manifest2);
  const fetch2 = async (request, env, context) => {
    const { pathname } = new URL(request.url);
    if (manifest2.assets.has(pathname)) {
      return env.ASSETS.fetch(request.url.replace(/\.html$/, ""));
    }
    const routeData = app.match(request);
    if (!routeData) {
      const asset = await env.ASSETS.fetch(request.url.replace(/index.html$/, "").replace(/\.html$/, ""));
      if (asset.status !== 404) {
        return asset;
      }
    }
    Reflect.set(request, Symbol.for("astro.clientAddress"), request.headers.get("cf-connecting-ip"));
    process.env.ASTRO_STUDIO_APP_TOKEN ??= (() => {
      if (typeof env.ASTRO_STUDIO_APP_TOKEN === "string") {
        return env.ASTRO_STUDIO_APP_TOKEN;
      }
    })();
    const locals = {
      runtime: {
        env,
        cf: request.cf,
        caches,
        ctx: {
          waitUntil: (promise) => context.waitUntil(promise),
          passThroughOnException: () => context.passThroughOnException()
        }
      }
    };
    const response = await app.render(request, { routeData, locals });
    if (app.setCookieHeaders) {
      for (const setCookieHeader of app.setCookieHeaders(response)) {
        response.headers.append("Set-Cookie", setCookieHeader);
      }
    }
    return response;
  };
  return { default: { fetch: fetch2 } };
}
var serverEntrypointModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExports
}, Symbol.toStringTag, { value: "Module" }));
var _page0 = () => init_generic_DuQmGclJ().then(() => generic_DuQmGclJ_exports);
var _page1 = () => init_trpc_LU1rZ36Q().then(() => trpc_LU1rZ36Q_exports);
var _page2 = () => init_uploadthing_ByMMhEFg().then(() => uploadthing_ByMMhEFg_exports);
var _page3 = () => init_cvs_Dmiwg382().then(() => cvs_Dmiwg382_exports);
var _page4 = () => init_index_Bmb7h_Ya().then(() => index_Bmb7h_Ya_exports);
var pageMap = /* @__PURE__ */ new Map([
  ["node_modules/astro/dist/assets/endpoint/generic.js", _page0],
  ["src/pages/api/trpc/[trpc].ts", _page1],
  ["src/pages/api/uploadthing.ts", _page2],
  ["src/pages/cvs.astro", _page3],
  ["src/pages/index.astro", _page4]
]);
var _manifest2 = Object.assign(manifest, {
  pageMap,
  renderers,
  middleware: onRequest
});
var _args = void 0;
var _exports = createExports(_manifest2);
var __astrojsSsrVirtualEntry = _exports.default;
var _start = "start";
if (_start in serverEntrypointModule) {
  serverEntrypointModule[_start](_manifest2, _args);
}

// node_modules/wrangler/templates/pages-dev-util.ts
init_checked_fetch();
init_modules_watch_stub();
function isRoutingRuleMatch(pathname, routingRule) {
  if (!pathname) {
    throw new Error("Pathname is undefined.");
  }
  if (!routingRule) {
    throw new Error("Routing rule is undefined.");
  }
  const ruleRegExp = transformRoutingRuleToRegExp(routingRule);
  return pathname.match(ruleRegExp) !== null;
}
function transformRoutingRuleToRegExp(rule) {
  let transformedRule;
  if (rule === "/" || rule === "/*") {
    transformedRule = rule;
  } else if (rule.endsWith("/*")) {
    transformedRule = `${rule.substring(0, rule.length - 2)}(/*)?`;
  } else if (rule.endsWith("/")) {
    transformedRule = `${rule.substring(0, rule.length - 1)}(/)?`;
  } else if (rule.endsWith("*")) {
    transformedRule = rule;
  } else {
    transformedRule = `${rule}(/)?`;
  }
  transformedRule = `^${transformedRule.replaceAll(/\./g, "\\.").replaceAll(/\*/g, ".*")}$`;
  return new RegExp(transformedRule);
}

// .wrangler/tmp/pages-KkpaTB/6l909w2no6.js
var define_ROUTES_default = {
  version: 1,
  include: [
    "/*"
  ],
  exclude: [
    "/_astro/*",
    "/favicon.svg"
  ]
};
var routes = define_ROUTES_default;
var pages_dev_pipeline_default = {
  fetch(request, env, context) {
    const { pathname } = new URL(request.url);
    for (const exclude of routes.exclude) {
      if (isRoutingRuleMatch(pathname, exclude)) {
        return env.ASSETS.fetch(request);
      }
    }
    for (const include of routes.include) {
      if (isRoutingRuleMatch(pathname, include)) {
        if (__astrojsSsrVirtualEntry.fetch === void 0) {
          throw new TypeError("Entry point missing `fetch` handler");
        }
        return __astrojsSsrVirtualEntry.fetch(request, env, context);
      }
    }
    return env.ASSETS.fetch(request);
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_checked_fetch();
init_modules_watch_stub();
var drainBody = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
};
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e2) {
    const error2 = reduceError(e2);
    return Response.json(error2, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-1HjA2m/middleware-insertion-facade.js
pages_dev_pipeline_default.middleware = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default,
  ...pages_dev_pipeline_default.middleware ?? []
].filter(Boolean);
var middleware_insertion_facade_default = pages_dev_pipeline_default;

// node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-1HjA2m/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (worker.middleware === void 0 || worker.middleware.length === 0) {
    return worker;
  }
  for (const middleware of worker.middleware) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  };
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = function(type, init2) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
function wrapWorkerEntrypoint(klass) {
  if (klass.middleware === void 0 || klass.middleware.length === 0) {
    return klass;
  }
  for (const middleware of klass.middleware) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type, init2) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  middleware_loader_entry_default as default,
  pageMap
};
/**
 * shortdash - https://github.com/bibig/node-shorthash
 *
 * @license
 *
 * (The MIT License)
 *
 * Copyright (c) 2013 Bibig <bibig@me.com>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/* istanbul ignore if -- @preserve */
/* istanbul ignore next -- @preserve */
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
/**
 * @license lucide-react v0.358.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
/*! Bundled license information:

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.0.10 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.10/LICENSE *)
*/
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
//# sourceMappingURL=6l909w2no6.js.map
